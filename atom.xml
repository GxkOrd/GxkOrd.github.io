<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MyBlog - GxkOrd</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://GxkOrd.github.io/"/>
  <updated>2020-02-02T06:27:03.442Z</updated>
  <id>https://GxkOrd.github.io/</id>
  
  <author>
    <name>GxkOrd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1. Java BIO编程</title>
    <link href="https://GxkOrd.github.io/2020/02/02/Java/Netty/1.%20Java%20BIO%E7%BC%96%E7%A8%8B/"/>
    <id>https://GxkOrd.github.io/2020/02/02/Java/Netty/1. Java BIO编程/</id>
    <published>2020-02-02T04:57:00.000Z</published>
    <updated>2020-02-02T06:27:03.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h1><ol><li><p>I/O 模型的简单理解：用什么样的通道进行数据的发送和接收。它很大程度上决定了程序通信的性能。</p></li><li><p>Java共支持3种网络编程模型（I/O模式）：BIO、NIO、AIO</p><ul><li><p>Java BIO ：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。</p></li><li><p>Java NIO ：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理。</p></li><li><p>Java AIO(NIO.2) ：异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor  模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</p></li></ul></li></ol><h1 id="BIO、NIO、AIO适用场景分析"><a href="#BIO、NIO、AIO适用场景分析" class="headerlink" title="BIO、NIO、AIO适用场景分析"></a>BIO、NIO、AIO适用场景分析</h1><ol><li><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。</p></li><li><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。</p></li><li><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p></li></ol><h1 id="Java-BIO基本介绍"><a href="#Java-BIO基本介绍" class="headerlink" title="Java BIO基本介绍"></a>Java BIO基本介绍</h1><ol><li><p>Java BIO 就是传统的java io  编程，其相关的类和接口在 java.io。</p></li><li><p>BIO（blocking I/O）： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。 【<em>后面有应用实例</em>】</p></li><li><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解。</p></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2020/02/02/Java/Netty/1. Java BIO编程/BIO工作原理图.png" alt="BIO工作原理图" title>                </div>                <div class="image-caption">BIO工作原理图</div>            </figure><blockquote><p>BIO编程简单流程：</p><ol><li><p>服务器端启动一个ServerSocket。</p></li><li><p>客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯。</p></li><li><p>客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</p></li><li><p>如果有响应，客户端线程会等待请求结束后，在继续执行。</p></li></ol></blockquote><h1 id="Java-BIO应用实例"><a href="#Java-BIO应用实例" class="headerlink" title="Java BIO应用实例"></a>Java BIO应用实例</h1><ol><li><p>编写服务器端：BIOServer，并运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 线程池机制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.创建一个线程池</span></span><br><span class="line">        <span class="comment">// 2.如果有客户端连接，就创建一个线程，与之通讯</span></span><br><span class="line">        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息 id="</span> + Thread.currentThread().getId() + <span class="string">"，name="</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">// 等待客户端连接</span></span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端"</span>);</span><br><span class="line">            <span class="comment">// 创建一个线程，与之通信</span></span><br><span class="line">            newCachedThreadPool.execute(() -&gt; &#123;</span><br><span class="line">                handler(socket);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息 id="</span> + Thread.currentThread().getId() + <span class="string">"，name="</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">// 通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">// 循环读取客户端发送的数据</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭和client的连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动服务器端</p><p>在cmd命令行中输入：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet <span class="number">127.0</span>.<span class="number">0.1</span> <span class="number">6666</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="Java-BIO问题分析"><a href="#Java-BIO问题分析" class="headerlink" title="Java BIO问题分析"></a>Java BIO问题分析</h1><ol><li><p>每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。</p></li><li><p>当并发数较大时，需要<strong>创建大量线程来处理连接</strong>，系统资源占用较大。</p></li><li><p>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;I-O模型&quot;&gt;&lt;a href=&quot;#I-O模型&quot; class=&quot;headerlink&quot; title=&quot;I/O模型&quot;&gt;&lt;/a&gt;I/O模型&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;I/O 模型的简单理解：用什么样的通道进行数据的发送和接收。它很大程度上决定了程序通信的性能。&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="https://GxkOrd.github.io/categories/Java/"/>
    
    
      <category term="Netty" scheme="https://GxkOrd.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>0. Netty介绍</title>
    <link href="https://GxkOrd.github.io/2020/01/31/Java/Netty/0.%20Netty%E4%BB%8B%E7%BB%8D/"/>
    <id>https://GxkOrd.github.io/2020/01/31/Java/Netty/0. Netty介绍/</id>
    <published>2020-01-31T05:05:00.000Z</published>
    <updated>2020-01-31T07:35:25.726Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习要求"><a href="#学习要求" class="headerlink" title="学习要求"></a>学习要求</h1><ol><li><p>学习Netty要求已经掌握了 Java 基础编程， 如：Java OOP、Java 多线程、Java IO、Java 网络编程、常用的Java设计模式（观察者模式 ，命令模式，职责链模式等）、常用的数据结构（链表等）。</p></li><li><p>最好有<strong>开发项目</strong>和<strong>阅读源码</strong>的经历。</p></li></ol><h1 id="Netty介绍"><a href="#Netty介绍" class="headerlink" title="Netty介绍"></a>Netty介绍</h1><ol><li><p>Netty  是由 JBOSS 开源的 Java 框架，现为 Github上的独立项目。</p></li><li><p>官方介绍：</p><p><em>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</em></p><p>Netty是一个<strong>异步事件驱动</strong>的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</p></li><li><p>Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。</p></li><li><p>Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景。</p></li><li><p>要透彻理解Netty，需要先学习NIO，这样才能阅读 Netty 的源码。</p></li></ol><h1 id="Netty的应用场景"><a href="#Netty的应用场景" class="headerlink" title="Netty的应用场景"></a>Netty的应用场景</h1><h2 id="互联网行业"><a href="#互联网行业" class="headerlink" title="互联网行业"></a>互联网行业</h2><ol><li><p>在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。</p></li><li><p>典型的应用：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty  作为基础通信组件，用于实现各进程节点之间的内部通信。</p></li></ol><h2 id="游戏行业"><a href="#游戏行业" class="headerlink" title="游戏行业"></a>游戏行业</h2><ol><li><p>无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用。</p></li><li><p>Netty 作为高性能的基础通信组件，提供了 TCP/UDP 和 HTTP 协议栈，方便定制和开发私有协议栈，账号登录服务器。</p></li><li><p>地图服务器之间可以方便的通过 Netty  进行高性能的通信。</p></li></ol><h2 id="大数据领域"><a href="#大数据领域" class="headerlink" title="大数据领域"></a>大数据领域</h2><ol><li><p>经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty  进行跨界点通信。</p></li><li><p>它的 Netty Service 基于 Netty 框架二次封装实现。</p></li></ol><h2 id="其他开源项目"><a href="#其他开源项目" class="headerlink" title="其他开源项目"></a>其他开源项目</h2><p><a href="https://netty.io/wiki/related-projects.html" target="_blank" rel="noopener">https://</a><a href="https://netty.io/wiki/related-projects.html" target="_blank" rel="noopener">netty.io/wiki/related-projects.html</a></p><h1 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h1><p>Norman Maurer/Marvin Allen Wolfthal.《Netty In Action》.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习要求&quot;&gt;&lt;a href=&quot;#学习要求&quot; class=&quot;headerlink&quot; title=&quot;学习要求&quot;&gt;&lt;/a&gt;学习要求&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;学习Netty要求已经掌握了 Java 基础编程， 如：Java OOP、Java 多线程、Java IO
      
    
    </summary>
    
      <category term="Java" scheme="https://GxkOrd.github.io/categories/Java/"/>
    
    
      <category term="Netty" scheme="https://GxkOrd.github.io/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>21. Merge Two Sorted Lists(Easy)</title>
    <link href="https://GxkOrd.github.io/2019/10/16/%E7%AE%97%E6%B3%95/LeetCode/21.%20Merge%20Two%20Sorted%20Lists(Easy)/"/>
    <id>https://GxkOrd.github.io/2019/10/16/算法/LeetCode/21. Merge Two Sorted Lists(Easy)/</id>
    <published>2019-10-16T07:28:00.000Z</published>
    <updated>2019-10-16T07:36:45.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description:</strong></p><blockquote><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p></blockquote><p><strong>Example:</strong></p><blockquote><p><strong>Input:</strong> 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>Output:</strong> 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述：</strong></p><blockquote><p>合并两个排序好的链表，并将其作为新链表返回。新链表应该由原链表的节点拼接在一起来创建。</p></blockquote><p><strong>例如：</strong></p><blockquote><p><strong>输入：</strong>1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br><strong>输出：</strong>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p></blockquote></blockquote><h1 id="解法一（mine）"><a href="#解法一（mine）" class="headerlink" title="解法一（mine）"></a>解法一（mine）</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>双指针同时遍历两链表。</p><blockquote><p>运行速度：超过了100%的解答。</p><p>内存使用：超过了16.16%的解答。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">            temp = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode head = temp;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &gt; l2.val) &#123;</span><br><span class="line">                temp.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.next = l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://GxkOrd.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://GxkOrd.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Easy" scheme="https://GxkOrd.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>20. Valid Parentheses(Easy)</title>
    <link href="https://GxkOrd.github.io/2019/10/15/%E7%AE%97%E6%B3%95/LeetCode/20.%20Valid%20Parentheses(Easy)/"/>
    <id>https://GxkOrd.github.io/2019/10/15/算法/LeetCode/20. Valid Parentheses(Easy)/</id>
    <published>2019-10-15T08:45:00.000Z</published>
    <updated>2019-10-16T07:33:30.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description:</strong></p><blockquote><p>Given a string containing just the characters <code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>, determine if the input string is valid.</p><p>An input string is valid if:</p><ol><li>Open brackets must be closed by the same type of brackets.</li><li>Open brackets must be closed in the correct order.</li></ol><p>Note that an empty string is also considered valid.</p></blockquote><blockquote><p><strong>Example 1:</strong></p><blockquote><p><strong>Input:</strong> “()”</p><p><strong>Output:</strong> true</p></blockquote><p><strong>Example 2:</strong></p><blockquote><p><strong>Input:</strong> “()[]{}”</p><p><strong>Output:</strong> true</p></blockquote><p><strong>Example 3:</strong></p><blockquote><p><strong>Input:</strong> “(]”</p><p><strong>Output:</strong> false</p></blockquote><p><strong>Example 4:</strong></p><blockquote><p><strong>Input:</strong> “([)]”</p><p><strong>Output:</strong> false</p></blockquote><p><strong>Example 5:</strong></p><blockquote><p><strong>Input:</strong> “{[]}”</p><p><strong>Output:</strong> true</p></blockquote></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述：</strong></p><blockquote><p>给定一个String字符串，其只包含以下字符：<code>&#39;(&#39;</code>, <code>&#39;)&#39;</code>, <code>&#39;{&#39;</code>, <code>&#39;}&#39;</code>, <code>&#39;[&#39;</code> and <code>&#39;]&#39;</code>，判断该字符串是否有效.</p><p>若一个字符串有效，则:</p><ol><li>开括号必须用相同类型的括号封闭。</li><li>开括号必须以正确的顺序关闭。</li></ol><p>请注意，空字符串也被视为有效。</p></blockquote><blockquote><p><strong>例1：</strong></p><blockquote><p><strong>输入：</strong> “()”</p><p><strong>输出：</strong> true</p></blockquote><p><strong>例2：</strong></p><blockquote><p><strong>输入：</strong> “()[]{}”</p><p><strong>输出：</strong> true</p></blockquote><p><strong>例3：</strong></p><blockquote><p><strong>输入：</strong> “(]”</p><p><strong>输出：</strong> false</p></blockquote><p><strong>例4：</strong></p><blockquote><p><strong>输入：</strong> “([)]”</p><p><strong>输出：</strong> false</p></blockquote><p><strong>例5：</strong></p><blockquote><p><strong>输入：</strong> “{[]}”</p><p><strong>输出：</strong> true</p></blockquote></blockquote></blockquote><h1 id="解法一（mine）"><a href="#解法一（mine）" class="headerlink" title="解法一（mine）"></a>解法一（mine）</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><ol><li><p>定义一个栈，遍历s对应的char数组放入栈中.</p></li><li><p>遇到右括号，弹出栈顶元素，若不是对应的左括号，返回false。</p></li></ol><blockquote><p>运行速度：超过了98.71%的解答。</p><p>内存使用：超过了100%的解答。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">')'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.empty() || stack.pop() != <span class="string">'('</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'&#125;'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.empty() || stack.pop() != <span class="string">'&#123;'</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">']'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.empty() || stack.pop() != <span class="string">'['</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.add(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://GxkOrd.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://GxkOrd.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Easy" scheme="https://GxkOrd.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>19. Remove Nth Node From End of List(Medium)</title>
    <link href="https://GxkOrd.github.io/2019/10/13/%E7%AE%97%E6%B3%95/LeetCode/19.%20Remove%20Nth%20Node%20From%20End%20of%20List(Medium)/"/>
    <id>https://GxkOrd.github.io/2019/10/13/算法/LeetCode/19. Remove Nth Node From End of List(Medium)/</id>
    <published>2019-10-13T09:06:00.000Z</published>
    <updated>2019-10-16T07:33:58.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description:</strong></p><blockquote><p>Given a linked list, remove the <em>n</em>-th node from the end of list and return its head.</p></blockquote><p><strong>Example:</strong></p><blockquote><p>Given linked list: <strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, and <strong><em>n</em> = 2</strong>.</p><p>After removing the second node from the end, the linked list becomes <strong>1-&gt;2-&gt;3-&gt;5</strong>.</p></blockquote><p><strong>Note:</strong></p><blockquote><p>Given  <em>n</em>  will always be valid.</p></blockquote><p><strong>Follow up:</strong></p><blockquote><p>Could you do this in one pass?</p></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述：</strong></p><blockquote><p>给定一个链表，请删除链表尾部起第n个节点，然后返回其头部。</p></blockquote><p><strong>例如：</strong></p><blockquote><p>给定链表：<strong>1-&gt;2-&gt;3-&gt;4-&gt;5</strong>, 和 <strong><em>n</em> = 2</strong>。</p><p>删除尾部第二个节点后，链表变成 <strong>1-&gt;2-&gt;3-&gt;5</strong>。</p></blockquote><p><strong>另外：</strong></p><blockquote><p>给定n将始终有效。</p></blockquote><p><strong>提高：</strong></p><blockquote><p>你能否一次通过？</p></blockquote></blockquote><h1 id="解法一（mine）"><a href="#解法一（mine）" class="headerlink" title="解法一（mine）"></a>解法一（mine）</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><ol><li><p>创建一个队列，先进先出，长度固定为n+1。</p></li><li><p>遍历链表，将元素放入队列。</p></li><li><p>遍历完成后，队列中第二个元素即为要删除的元素。</p></li></ol><blockquote><p>运行速度：超过了10.92%的解答。</p><p>内存使用：超过了100%的解答。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;ListNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;ListNode&gt;(); </span><br><span class="line">        ListNode temp = head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.add(temp);</span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt; n + <span class="number">1</span>) &#123;</span><br><span class="line">                queue.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if (queue.size() &lt; n) &#123; // 若队列长度小于n，则原链表长度小于n，不存在倒数第n个元素</span></span><br><span class="line">        <span class="comment">//     return head;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">if</span> (queue.size() == n) &#123; <span class="comment">// 若队列长度等于n，则需删除原链表第一个元素</span></span><br><span class="line">            <span class="keyword">return</span> head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若队列长度等于n+1，则需删除队列中第二个元素</span></span><br><span class="line">        temp = queue.getFirst();</span><br><span class="line">        temp.next = temp.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><p>使用快慢指针</p><ol><li><p>先使用快指针遍历链表。</p></li><li><p>当快指针指向要删除的目标元素时，开始使用慢指针遍历链表。</p></li><li><p>当快指针结束时，慢指针刚好指向要删除的元素的前一个。</p></li><li><p>修改慢指针所指向元素的next即可。</p></li></ol><blockquote><p>运行速度：超过了100%的解答。</p><p>内存使用：超过了100%的解答。</p></blockquote><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n-- &lt; <span class="number">0</span>) &#123; <span class="comment">// 当fast指向要删除的目标元素时，开始移动slow。</span></span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) </span><br><span class="line">            slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            head = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://GxkOrd.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://GxkOrd.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Medium" scheme="https://GxkOrd.github.io/tags/LeetCode-Medium/"/>
    
  </entry>
  
  <entry>
    <title>18. 4Sum(Medium)</title>
    <link href="https://GxkOrd.github.io/2019/09/30/%E7%AE%97%E6%B3%95/LeetCode/18.%204Sum(Medium)/"/>
    <id>https://GxkOrd.github.io/2019/09/30/算法/LeetCode/18. 4Sum(Medium)/</id>
    <published>2019-09-30T11:03:00.000Z</published>
    <updated>2020-02-02T06:47:37.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description:</strong></p><blockquote><p>Given an array <code>nums</code> of <em>n</em> integers and an integer <code>target</code>, are there elements <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> in <code>nums</code> such that <em>a</em> + <em>b</em> + <em>c</em> + <em>d</em> = <code>target</code>? </p><p>Find all unique quadruplets in the array which gives the sum of <code>target</code>.</p></blockquote><p><strong>Note:</strong></p><blockquote><p>The solution set must not contain duplicate quadruplets.</p></blockquote><p><strong>Example:</strong></p><blockquote><p>Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.<br>A solution set is:<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述：</strong></p><blockquote><p>给定一个包含n个实数的数组nums和一个实数target，nums中是否存在元素a，b，c，d，使得a + b + c + d = target？</p><p>找到数组中所有唯一的四元组，它们的总和为target。</p></blockquote><p><strong>另外：</strong></p><blockquote><p>结果集中不得包含重复的四元组。</p></blockquote><p><strong>例如：</strong></p><blockquote><p>给定一个数组nums = [1, 0, -1, 0, -2, 2] 和 target = 0. </p><p>一个解决方案集合为：<br>[<br>  [-1,  0, 0, 1],<br>  [-2, -1, 1, 2],<br>  [-2,  0, 0, 2]<br>]</p></blockquote></blockquote><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>在3sum的基础上，外层多嵌套一层for循环。</p><blockquote><p>运行速度：超过了89.97%的解答。</p><p>内存使用：超过了52.17%的解答。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; fourSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">4</span> * nums[<span class="number">0</span>] &gt; target || <span class="number">4</span> * nums[nums.length - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length - <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * <span class="number">4</span> &gt; target) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * <span class="number">4</span> == target) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>] &amp;&amp; nums[i] == nums[i + <span class="number">2</span>] &amp;&amp; nums[i] == nums[i+<span class="number">3</span>]) &#123;</span><br><span class="line">                    List&lt;Integer&gt; unit = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                    unit.add(nums[i]);</span><br><span class="line">                    unit.add(nums[i]);</span><br><span class="line">                    unit.add(nums[i]);</span><br><span class="line">                    unit.add(nums[i]);</span><br><span class="line">                    res.add(unit);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>]) &#123; <span class="comment">// 避免重复遍历</span></span><br><span class="line">                <span class="keyword">int</span> target2 = target - nums[i];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= nums.length - <span class="number">3</span>; j++) &#123; <span class="comment">// 与3sum相同</span></span><br><span class="line">                    <span class="keyword">if</span> (nums[j] * <span class="number">3</span> &gt; target2) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] * <span class="number">3</span> == target2) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nums[j] == nums[j + <span class="number">1</span>] &amp;&amp; nums[j] == nums[j + <span class="number">2</span>]) &#123;</span><br><span class="line">                            List&lt;Integer&gt; unit = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                            unit.add(nums[i]);</span><br><span class="line">                            unit.add(nums[j]);</span><br><span class="line">                            unit.add(nums[j]);</span><br><span class="line">                            unit.add(nums[j]);</span><br><span class="line">                            res.add(unit);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (j == i + <span class="number">1</span> || nums[j] != nums[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                        <span class="keyword">int</span> low = j + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                            <span class="keyword">int</span> sum = nums[j] + nums[low] + nums[high];</span><br><span class="line">                            <span class="keyword">if</span> (sum == target2) &#123;</span><br><span class="line">                                List&lt;Integer&gt; unit = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                                unit.add(nums[i]);</span><br><span class="line">                                unit.add(nums[j]);</span><br><span class="line">                                unit.add(nums[low]);</span><br><span class="line">                                unit.add(nums[high]);</span><br><span class="line">                                res.add(unit);</span><br><span class="line">                                low++;</span><br><span class="line">                                high--;</span><br><span class="line">                                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == nums[low - <span class="number">1</span>]) &#123; <span class="comment">// 避免重复</span></span><br><span class="line">                                    low++;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] == nums[high + <span class="number">1</span>]) &#123; <span class="comment">// 避免重复</span></span><br><span class="line">                                    high--;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; target2)&#123;</span><br><span class="line">                                high--;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                low++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://GxkOrd.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://GxkOrd.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Medium" scheme="https://GxkOrd.github.io/tags/LeetCode-Medium/"/>
    
  </entry>
  
  <entry>
    <title>第2章 创建和销毁对象</title>
    <link href="https://GxkOrd.github.io/2019/08/24/Java/Java%E5%9F%BA%E7%A1%80/%E3%80%8AEffiective%20Java%E3%80%8B%E7%AC%AC3%E7%89%88/%E7%AC%AC2%E7%AB%A0%20%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/"/>
    <id>https://GxkOrd.github.io/2019/08/24/Java/Java基础/《Effiective Java》第3版/第2章 创建和销毁对象/</id>
    <published>2019-08-24T02:20:00.000Z</published>
    <updated>2019-09-13T11:41:43.073Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明：本专题为Joshua Bloch所著《Effiective Java》的笔记。</p></blockquote><blockquote><ol><li><p>James Gosling（Java之父）：“我很希望10年前就拥有这本书。可能有人认为我不需要任何Java方面的书籍，但是我需要这本书。”</p></li><li><p>这本书完全称得上是编程神作，无关编程语言。</p></li><li><p>它唯一的缺点就是中文翻译有些瑕疵，但如果发现了这些瑕疵，就说明你的技术又深入了一步。</p></li><li><p>这本书是在我刚接触编程时获得的，但那时读起来确实不知所云。</p><p>在我独自做过javase，javaee的项目后，再来读仍觉得它难以读懂。</p><p>直到我学过了数据结构、设计模式、spring、springboot等等，有了更多的项目经验，再来了解它，才发现原来自己曾经在编程上遇到的多数疑问，它早已有解答。幸得阅之于学生时代，少走些弯路。</p></li></ol></blockquote><h1 id="第2章-创建和销毁对象"><a href="#第2章-创建和销毁对象" class="headerlink" title="第2章 创建和销毁对象"></a>第2章 创建和销毁对象</h1><blockquote><p>本章的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何能够保证它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清理动作。</p></blockquote><h2 id="第1条：考虑使用静态工厂方法替代构造方法"><a href="#第1条：考虑使用静态工厂方法替代构造方法" class="headerlink" title="第1条：考虑使用静态工厂方法替代构造方法"></a>第1条：考虑使用静态工厂方法替代构造方法</h2><h3 id="什么是静态工厂方法"><a href="#什么是静态工厂方法" class="headerlink" title="什么是静态工厂方法"></a>什么是静态工厂方法</h3><p>某个<em>类</em>允许客户端获得其实例的传统方式是提供一个<em>公共的（public）构造方法</em>。</p><p>除此之外，还有一种方法是必须要考虑的，即类可以提供一个<em>公共的（public）静态工厂方法（static factory method）</em>，它是一个返回类的实例的静态方法。</p><p>下面是一个来自Boolean（基本类型boolean的包装类）的简单例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作用：将boolean基本类型值转化成一个Boolean对象引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Boolean <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? Boolean.TRUE : Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态工厂方法的优点"><a href="#静态工厂方法的优点" class="headerlink" title="静态工厂方法的优点"></a>静态工厂方法的优点</h3><ol><li><p><strong>静态工厂方法与构造方法不同的第一大优点在于，它们有名称。</strong>如果构造方法的参数无法确切地描述被返回的对象，那么具有适当名称的静态工厂方法会更容易使用，并且生成的客户端代码也将更易于阅读。</p><p>例如，<code>BigInteger</code>的构造方法<code>BigInteger(int. int. Random)</code>返回的是一个可能为素数的值，如果使用一个名为<code>BigInteger.probablePrime</code>的静态方法来表示，显然更为清楚。（1.4的发行版本中增加了这个方法。）</p><p>一个类只能有一个给定<strong>签名</strong>（方法名和参数列表）的构造方法，编程人员都知道如何避免这个限制：<em>提供两个不同参数列表顺序的构造方法</em>。实际上这是一个非常糟糕的主意。这样的API，使用者永远记不清该用哪个构造方法。阅读和使用这些构造方法的人只有在有参考文档时才知道这些代码的作用。</p><p>由于静态方法有名称，所以它们不受上述的限制。<strong>当一个类需要多个相同签名的构造方法时，用静态工厂方法代替构造方法，并且慎重地选择方法名称以突出它们之间的区别。</strong></p></li><li><p><strong>静态工厂方法与构造方法不同的第二大优点在于，不必在每次调用时都创建一个新对象。</strong></p><p>这允许不可变类（详见第17条）可以使用预先构建的实例，或者将构造好的实例缓存起来，并反复分配它们以避免创建不必要对象。<code>Boolean.valueOf(boolean)</code>很好地说明了这种技术。这种技术类似于<code>Flyweight</code>模式。如果程序经常创建相同对象，并且创建对象的代价很高，则这项技术可以极大地提升性能。</p><p>静态工厂方法能够为重复地调用返回同一对象，这样有助于类总能严格控制在某个时刻哪些实例存在。这种类被称为<em>实例受控的</em>（instance-controlled）。编写实例受控类有以下原因：</p><ol><li><p>确保这个类是<em>单例的</em>（Singleton）（见第3条）或者不可实例化的（详见第4条）。</p></li><li><p>它还可确保不可变的类（详见第17条）不会存在两个相同的实例，即当且仅当<code>a==b</code>时，<code>e.equals(b)</code>，我们可以使用<code>==</code>替代<code>equals(Object)</code>，从而提升程序运行速度而不影响正确性。<code>Enum</code>类型正使用了这一点。</p></li></ol></li><li><p><strong>静态工厂方法与构造方法不同的第三大优点在于，它们可以返回其返回类型的任一子类的对象。</strong>这样，我们在选择返回的对象时就有了更大的灵活性。</p><p>这种灵活性的一个应用是，API可以返回对象，而不必把对象的类变成公共的，以这种方式隐藏实现类会使API更加简洁。这种技术适用于基于接口的框架（详见第20条），其中的接口为静态工厂方法提供了自然返回类型。</p><blockquote><p>这里的”自然“（原文为natural），并非一种专用术语，而是指在定义接口时，所希望的返回类型。</p></blockquote><p>在Java 8之前，接口不能有静态方法。按照惯例，一个名为<code>Type</code>的接口的静态工厂方法放在名为<code>Types</code>的不可实例化的<em>伴随类</em>（companion class）（详见第4条）中。</p><p>例如，<em>java集合框架</em>（Java Collections Framework）的接口有45个实现类，分别提供了不可修改的集合、同步集合等等。几乎所有的实现类都是通过在一个不可实例化的类（java.util.Collections）中的静态工厂方法导出的。所有静态工厂方法返回对象的类都是<em>非公共</em>（nonpublic）的。</p><p>Collections Framework API 的规模要比单独导出45 个公共类要小得多，一个API方便了所有实现类。不仅是 API 的数量的减少，还包括<em>概念重量</em>（conceptual weight）：编程者使用API所必须掌握的概念的数量和难度​​。编程者知道了要返回的对象恰好有接口指定的API，就不再需要阅读实现类的文档。此外，这种静态工厂方法要求编程者通过一个该接口类的变量来引用返回的对象，而不是实现类，这是一种良好的习惯（详见第 64 条）。</p><p>从 Java 8 开始，取消了接口不能包含静态方法的限制，所以不必再提供一个不可实例化的伴随类。很多公共的静态成员应该放在这个接口之中。但是，请注意，将这些静态方法的大部分实现代码放在单独的包私有类中仍然是必要的，这是因为 Java 8 要求所有接口的静态成员都是公共的。Java 9 允许私有静态方法，但静态属性和静态成员类仍然需要设为公共。</p></li><li><p><strong>静态工厂方法与构造方法不同的第四大优点在于，返回对象的类可以根据输入参数的不同而不同。</strong>声明的返回类型的任何子类都是允许的。为了提升软件的可维护性和性能，返回对象的类也可能随每次发行版本而不同。</p><p>例如，<code>EnumSet</code>类（详见第 36 条），它没有公共构造方法，只有静态工厂方法。在OpenJDK 的实现中，是根据底层枚举类型的大小返回两个子类中的一个的实例：如果大多数枚举类型具有 64 个或更少的元素，静态工厂方法将返回一个<code>RegularEnumSet</code>实例，返回一个<code>long</code>类型；如果枚举类型具有六十五个或更多元素，则将返回一个<code>JumboEnumSet</code>实例，返回一个<code>long</code>类型的数组。</p><p>这两个实现类的存在对于客户是不可见的。 如果<code>RegularEnumSet</code>不再为小枚举类型提供性能优势，则可以在未来版本中将其淘汰，而不会产生任何不良影响。同样，未来的版本可能会为了提高性能而添加<code>EnumSet</code>的第三个或第四个实现。 编程者既不知道也不需要关心他们从工厂返回的对象的类别；他们只关心它是<code>EnumSet</code>的一些子类。</p></li><li><p><strong>静态工厂方法与构造方法不同的第五大优点在于，在编写包含该方法的类时，返回的对象的类不需要存在。</strong>这种灵活的静态工厂方法构成了<em>服务提供者框架</em>（Service Provider Framework）的基础，例如 JDBC（Java 数据库连接，Java Database Connectivity）API。服务提供者框架，是提供者实现服务的系统，使实现对于编程者可用，将编程者与实现进行分离。</p><p>服务提供者框架中有三个基本组：<em>服务接口</em>（Service Interface），<em>提供者注册 API</em>（Provider Registration API），<em>服务访问 API</em>（Service Access API）。以及一个可选的第四个组件：<em>服务提供者接口</em>（Service Provider API）。</p><ol><li><p>服务接口：定义了需要实现的服务。</p></li><li><p>提供者注册 API：提供者实现服务后，向管理者注册的API。</p></li><li><p>服务访问 API：编程者获得服务的API。</p></li><li><p>服务提供者接口：它描述了一个生成服务接口实例的工厂对象。在没有服务提供者接口的情况下，实现必须通过反射进行实例化（详见第 65 条）。</p></li></ol><p>以下为一个完整服务提供者框架的简单实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务接口具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"登陆成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"注册成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务提供者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line">    <span class="function">UserService <span class="title">getUserService</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务提供者接口具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProviderImpl</span> <span class="keyword">implements</span> <span class="title">ServiceProvider</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        ServiceManager.registerProvider(<span class="string">"GxkOrd"</span>, <span class="keyword">new</span> ServiceProviderImpl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">getUserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务管理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ServiceProvider&gt; SERVICE_PROVIDER_MAP = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerProvider</span><span class="params">(String name, ServiceProvider provider)</span> </span>&#123;</span><br><span class="line">        SERVICE_PROVIDER_MAP.put(name, provider);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">getUserService</span><span class="params">(String providerName)</span> </span>&#123;</span><br><span class="line">        ServiceProvider provider = SERVICE_PROVIDER_MAP.get(providerName);</span><br><span class="line">        <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No provider registered with name = "</span> + providerName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> provider.getUserService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"包名.ServiceProviderImpl"</span>);</span><br><span class="line">            UserService userService = ServiceManager.getUserService(<span class="string">"登陆注册"</span>);</span><br><span class="line">            userService.register();</span><br><span class="line">            userService.login();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   服务提供者框架模式有许多变种。 例如，服务访问 API 可以向客户端返回比提供者提供的更丰富的服务接口，这是桥接（Bridge）模式。</p><p>   依赖注入框架（详见第 5 条）可以被看作强大的服务提供者。 </p><p>   从 Java 6 开始，jdk包含一个通用的服务提供者框架<code>java.util.ServiceLoader</code>，所以你不需要，一般也不应该自己编写（详见59条）。<code>JDBC</code>没有使用<code>ServiceLoader</code>，因为前者早于后者。</p><h3 id="静态工厂方法的缺点"><a href="#静态工厂方法的缺点" class="headerlink" title="静态工厂方法的缺点"></a>静态工厂方法的缺点</h3><ol><li><p><strong>静态工厂方法的主要缺点在于，类如果不含公共的或者受保护的构造器，就不能被实例化。</strong>对于公共的静态工厂方法所返回的非公共类，也同样如此。</p><p>例如，不可能将Collections Framework中任何方便的实现类子类化。但这也许因祸得福，因为它鼓励了程序员使用复合（composition）而不是继承（详见第 18 条），而且它是不可变的（详见第 17 条）。</p></li><li><p><strong>静态工厂方法的第二个缺点是，程序员很难找到它们。</strong>它们不像构造方法那样在 API 文档中突出，因此很难实例化一个提供了静态工厂方法而没有构造方法的类。可能有一天，Javadoc 工具会注意到静态工厂方法。同时，你可以通过将注意力吸引到类或接口文档中的静态工厂以及遵守通用的命名约定来减轻这个问题。下面是一些静态工厂方法的常用名称：</p><ul><li><p><strong>from</strong> —— 一个类型转换方法，它接受单个参数并返回此类型的相应实例，例如：<code>Date d = Date.from(instant);</code></p></li><li><p><strong>of</strong> —— 一个聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：<code>Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</code></p></li><li><p><strong>valueOf</strong> —— from 和 to 更为详细的替代方式，例如：<code>BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);</code></p></li><li><p><strong>instance</strong> 或 <strong>getInstance</strong> —— 返回一个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值，例如：<code>StackWalker luke = StackWalker.getInstance(options);</code></p></li><li><p><strong>create</strong> 或 <strong>newInstance</strong> —— 与 instance 或 getInstance 类似，但该方法保证每个调用返回一个新的实例，例如：<code>Object newArray = Array.newInstance(classObject, arrayLen);</code></p></li><li><p><strong>getType</strong> —— 与 getInstance 类似，但是如果在工厂方法中不同的类中使用。Type 是工厂方法返回的对象类型，例如：<code>FileStore fs = Files.getFileStore(path);</code></p></li><li><p><strong>newType</strong> —— 与 newInstance 类似，但是如果在工厂方法中不同的类中使用。Type 是工厂方法返回的对象类型，例如：<code>BufferedReader br = Files.newBufferedReader(path);</code></p></li><li><p><strong>type</strong> —— getType 和 newType 简洁的替代方式，例如：<code>List&lt;Complaint&gt; litany = Collections.list(legacyLitany);</code></p></li></ul><p>总之，静态工厂方法和公共构造方法都有它们的用途，并且了解它们的相对优点是值得的。但通常，静态工厂更可取，因此避免在没有考虑静态工厂方法的情况下使用公共构造方法。</p></li></ol><h2 id="第2条：当构造方法参数过多时使用builder模式"><a href="#第2条：当构造方法参数过多时使用builder模式" class="headerlink" title="第2条：当构造方法参数过多时使用builder模式"></a>第2条：当构造方法参数过多时使用builder模式</h2><p>静态工厂方法和构造方法都有一个局限性：它们不能很好地扩展很多可选参数。请考虑一个表示包装食品外面显示营养成分的标签类，这些标签有几个必需的属性（每份的含量，每罐的含量以及每份的卡路里等），还有20多个可选的属性（总脂肪、饱和脂肪、反式脂肪等）。大多数产品的几个可选属性都为非零值。</p><p>对于这样的类，我们该选用什么样的构造方法或者静态工厂方法？</p><h3 id="方法1：重叠构造方法模式"><a href="#方法1：重叠构造方法模式" class="headerlink" title="方法1：重叠构造方法模式"></a>方法1：重叠构造方法模式</h3><p>多数编程者习惯采用<em>重叠构造方法</em>（telescoping constructor）模式：先提供一个必要参数的构造方法，然后第二个构造方法有一个可选参数，第三个构造方法有两个可选参数，依此类推。最后一个构造方法中包含所有可选参数。</p><p>以下有一个示例，为了简单起见，它只显示了四个可选属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize; <span class="comment">// (mL) 必选</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings; <span class="comment">// (per container) 必选</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories; <span class="comment">// (per serving) 可选</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat; <span class="comment">// (g/serving) 可选</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium; <span class="comment">// (mg/serving) 可选</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate; <span class="comment">// (g/serving) 可选</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(servingSize, servings, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, </span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> calories)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(servingSize, servings, calories, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> calories, <span class="keyword">int</span> fat)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(servingSize, servings, calories, fat, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(servingSize, servings, calories, fat, sodium, <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> calories, <span class="keyword">int</span> fat, <span class="keyword">int</span> sodium, <span class="keyword">int</span> carbohydrate &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">this</span>.servingSize = servingSize;</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">this</span>.servings = servings;</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">this</span>.calories = calories;</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">this</span>.fat = fat;</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">this</span>.sodium = sodium;</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">this</span>.carbohydrate = carbohydrate;</span></span></span><br><span class="line"><span class="function"><span class="params">   &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><p>当想要创建一个实例时，可以使用包含所有要设置的参数的最短参数列表的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = </span><br><span class="line">    <span class="keyword">new</span> NutritionFacts(<span class="number">240</span>, <span class="number">8</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="number">35</span>, <span class="number">27</span>);</span><br></pre></td></tr></table></figure><p>调用这个构造方法通常要设置许多你本不想设置的参数，在上述情况下，我们就为 fat 属性设置了 0 值。在只有六个参数的情况下，看起来可能也不算太糟糕，但随着参数数量的增加，它很快就会失控。</p><p>简而言之，<strong>虽然重叠构造方法模式是有效的，但当有很多参数时，就会变得很难用，而且不易读。</strong></p><h3 id="方法2：JavaBeans模式"><a href="#方法2：JavaBeans模式" class="headerlink" title="方法2：JavaBeans模式"></a>方法2：JavaBeans模式</h3><p>当在构造方法中遇到许多可选参数时，另一种选择是 JavaBeans 模式：调用一个无参数的构造方法来创建对象，然后调用 setter 方法来设置每个必需的参数和可选参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters initialized to default values (if any)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servingSize = -<span class="number">1</span>; <span class="comment">// 必填; 无默认值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> servings = -<span class="number">1</span>; <span class="comment">// 必填; 无默认值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setters</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServingSize</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; servingSize = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServings</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; servings = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCalories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; calories = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; fat = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSodium</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; sodium = val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCarbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; carbohydrate = val; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式没有重叠构造方法模式的缺点，虽然有点冗长，但创建实例很容易，并且编写的代码也易于阅读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts();</span><br><span class="line">cocaCola.setServingSize(<span class="number">240</span>);</span><br><span class="line">cocaCola.setServings(<span class="number">8</span>);</span><br><span class="line">cocaCola.setCalories(<span class="number">100</span>);</span><br><span class="line">cocaCola.setSodium(<span class="number">35</span>);</span><br><span class="line">cocaCola.setCarbohydrate(<span class="number">27</span>);</span><br></pre></td></tr></table></figure><p>不幸的是，JavaBeans 模式本身有着严重的缺陷。</p><p>首先，多个setter方法的调用，分割了对象的构造过程，在这个构造过程中 JavaBean 很可能处于不一致的状态。类也失去了通过检查构造参数的有效性来保证一致性的能力。在不一致的状态下尝试使用对象，可能会导致错误（这并非一种代码上的bug，因此很难调试）。</p><p>另一个与此相关的缺点是，JavaBeans 模式排除了让类不可变的可能性（见第17条），这就需要编程者花费额外精力来确保线程安全。</p><p>通过在对象构建完成时手动”冻结“对象，并且不允许它在”解冻“之前使用，可以弥补这些缺点，但这种方法十分笨拙，在实践中很少使用。 而且由于编译器无法确保编程者在使用对象之前调用了<code>freeze()</code>方法（冻结对象），在运行时会很容易报错。</p><h3 id="方法3：Builder模式"><a href="#方法3：Builder模式" class="headerlink" title="方法3：Builder模式"></a>方法3：Builder模式</h3><p>幸运的是，还有第三种选择，它既保证了像重叠构造方法模式一样的安全性又具有 JavaBean 模式一般的可读性。这就是<em>Builder模式</em>：</p><p>不直接获得所需的对象，而是先使用所有必需的参数调用构造方法 (或静态工厂)获得一个 builder 对象。然后调用 builder 对象的一种类似于setter的方法来设置每个可选参数。最后，客户端调用一个无参的 build 方法来生成对象，该对象通常是不可变的。Builder 通常是它所构建的类的一个静态成员类 (详见第24条)。以下是它在实践中的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 必选参数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可选参数，初始化默认值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            calories = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            fat = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            sodium = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            carbohydrate = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.servingSize = builder.servingSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.servings = builder.servings;</span><br><span class="line">        <span class="keyword">this</span>.calories = builder.calories;</span><br><span class="line">        <span class="keyword">this</span>.fat = builder.fat;</span><br><span class="line">        <span class="keyword">this</span>.sodium = builder.sodium;</span><br><span class="line">        <span class="keyword">this</span>.carbohydrate = builder.carbohydrate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>NutritionFacts</code>类是不可变的，所有的参数默认值都在一个地方。builder 的 setter 方法返回 builder 本身，这样调用就被链接了起来，从而生成一个流畅的 API。下面是构造代码的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>, <span class="number">8</span>)</span><br><span class="line">    .calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build();</span><br></pre></td></tr></table></figure><p>这样，构造代码很容易编写，且更易于阅读。 Builder 模式模拟 Python 和 Scala 中的具名的可选参数。<br>为了简洁起见，省略了有效性检查。可在builder的构造函数和其他方法中检查参数有效性，以快速检测出无效参数。 可在build方法调用的构造方法中检查包含多个参数的不变性。为了确保这些不变性不受攻击，从 builder 复制参数后要对对象属性进行检查（见第50条）。如果检查失败，则抛出 IllegalArgumentException 异常（见第 72条），异常信息指示哪些参数无效（见第75条）。<br>Builder模式非常适合类层次结构。 使用平行层次的 builder，每个嵌套在相应的类中。抽象类有抽象的builder，具体的类有具体的 builder。例如，代表各种比萨饼的根层次结构的抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Topping &#123;HAM, MUSHROOM, ONION, PEPPER, SAUSAGE&#125;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;Topping&gt; toppings;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">        EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">addTopping</span><span class="params">(Topping topping)</span> </span>&#123;</span><br><span class="line">            toppings.add(Objects.requireNonNull(topping));</span><br><span class="line">            <span class="keyword">return</span> self();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> Pizza <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子类必须覆盖此方法才能返回“this”</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title">self</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Pizza(Builder&lt;?&gt; builder) &#123;</span><br><span class="line">        toppings = builder.toppings.clone(); <span class="comment">// 见第50条</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>Pizza.Builder</code>是一个带有递归型参数（ recursive type parameter）（见第30条）的泛型类型。它与抽象的<code>self</code>方法一起，允许方法链在子类中也能正常使用，而不需要强制类型转换。由于Java缺少自我类型，习惯上称这种变通的方法为<em>模拟自我类型</em>（simulated self-type）。</p><p>这里有两个具体的 Pizza 的子类，其中一个代表纯正纽约风格的披萨，另一个是半圆形烤乳酪披萨。前者有一个所需的尺寸参数，而后者则需要指定酱汁在里面还是在外面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NyPizza</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Size &#123; SMALL, MEDIUM, LARGE &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Pizza</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Size size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Size size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.size = Objects.requireNonNull(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> NyPizza <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NyPizza(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NyPizza</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(builder);</span><br><span class="line">        size = builder.size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calzone</span> <span class="keyword">extends</span> <span class="title">Pizza</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sauceInside;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> <span class="keyword">extends</span> <span class="title">Pizza</span>.<span class="title">Builder</span>&lt;<span class="title">Builder</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> sauceInside = <span class="keyword">false</span>; <span class="comment">// 默认</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sauceInside</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sauceInside = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Calzone <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Calzone(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Builder <span class="title">self</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Calzone</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(builder);</span><br><span class="line">        sauceInside = builder.sauceInside;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，每个子类 builder 中的<code>build</code>方法被声明为返回正确的子类：<code>NyPizza.Builder</code>的<code>build</code>方法返回<code>NyPizza</code>，而<code>Calzone.Builder</code>中的<code>build</code>方法返回<code>Calzone</code>。子类中的方法被声明为返回的类型，是在父类中声明的返回类型的子类型，这种技术称为<em>协变返回类型</em>（covariant return typing）。它允许创建时使用这些builder，而不需要强制转换。</p><p>以下为创建对象的代码示例（为了简洁起见，假设枚举常量已<em>静态导入</em>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NyPizza pizza = <span class="keyword">new</span> NyPizza.Builder(SMALL)</span><br><span class="line">    .addTopping(SAUSAGE).addTopping(ONION).build();</span><br><span class="line"></span><br><span class="line">Calzone calzone = <span class="keyword">new</span> Calzone.Builder()</span><br><span class="line">    .addTopping(HAM).sauceInside().build();</span><br></pre></td></tr></table></figure><p>相对于构造方法，builder还有一个微小的优势：builder 可以有多个可变参数，因为参数都是在它自己的方法中指定的。另外，builder 可以将多个方法的参数聚合到单个属性中，正如前面的<code>addTopping</code>方法那样。</p><p>Builder 模式非常灵活。单个 builder 可以重复使用来构建多个对象。builder 的参数可以在构建方法的调用之前进行调整，以改变创建的对象。builder 可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。</p><p>Builder 模式也有缺点。</p><p>为了创建对象，首先必须创建它的 builder。虽然创建这个 builder 的成本在实践中不太可能被注意到，但在性能很关键的情况下可能会出现问题。</p><p>而且，builder 模式比重叠构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。但请记住，务必未雨绸缪。如果在将来会添加更多的参数，请尽快将构造方法（或静态工厂）切换到 builder，当类演化到参数数量失控的时候，过时的构造方法或静态工厂会处于很鸡肋的处境。因此，最好从一开始就创建一个 builder。</p><p>总而言之，当发现类的构造方法或静态工厂的参数已经足够多时，特别是在许多参数是可选的或相同类型的情况下，Builder 模式是一个不错的选择。因为<strong>Builder的创建代码比重叠构造方法更容易读写，而且比 JavaBeans 更安全。</strong></p><h2 id="第3条：使用私有构造方法或枚类实现-Singleton属性"><a href="#第3条：使用私有构造方法或枚类实现-Singleton属性" class="headerlink" title="第3条：使用私有构造方法或枚类实现 Singleton属性"></a>第3条：使用私有构造方法或枚类实现 Singleton属性</h2><p>单例是指一个仅实例化一次的类。单例对象通常表示无状态对象，如函数（见第24条） 或一个本质上唯一的系统组件。让一个类成为单例会使测试变得十分困难，因为除非它实现了一个充当其类型的接口，否则不可能模拟实现它。</p><p>有以下两种常见的方法来实现单例。<strong>两者都是通过私有化构造方法和导出公共静态成员来来提供对这个唯一实例的访问。</strong></p><p><strong>第一种方法，使用final修饰的公共成员变量</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>私有构造方法只调用一次，来初始化 <code>INSTANCE</code>对象的属性。没有公共的或受保护的构造方法，保证了全局的唯一性：一旦 Elvis 类被初始化，就永远只存在一个实例。客户端的任何行为都不能改变这一点，但需要<strong>注意</strong>的是：有特权的客户端，可以使用<code>AccessibleObject.setAccessible</code>方法，以反射方式调用私有构造方法（详见第 65 条）。如果需要防止此攻击，可以修改构造方法，使其在被请求创建第二个实例时<br>抛出异常。</p><p><strong>第二种方法，使用静态工厂方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有对<code>getInstance</code>的调用都会返回相同的对象引用，而且不会创建其他的 Elvis 实例（当然，上一种方法需要注意的点依然存在）。<br>第一种方法（公共成员变量）的主要优点是，API 可以明确表示该类是一个单例：公共成员变量是 final 的，所以它总是包含相同的对象引用。 第二个好处是它更简单。</p><p>第二种方法（静态工厂）的一个优点是，它可以随着你的想法灵活地改变，无论该类是否为单例的，都不必修改其 API。静态工厂方法返回唯一的实例，但是可以修改，比如，修改为返回调用它的每个线程的单独实例。 第二个好处是，如果你的应用程序需要它，可以编写一个<em>泛型单例工厂</em>（generic singleton factory ）（详见第30 条）。使用静态工厂的最后一个优点是方法引用可以用<code>supplier</code>（java 1.8的新特性），例如 Elvis::instance 等同于 Supplier<elvis> 。除了要借助以上优点，公共属性方法更可取。</elvis></p><p>创建一个使用这两种方法的单例类（第 12 章），仅仅实现<code>Serializable</code>接口是不够的。为了维护单例的保证，声明所有的实例属性为<code>transient</code>，并提供一个<code>readResolve</code>方法（详见第 89条）。否则，每当序列化实例被反序列化时，就会创建一个新的实例（在上述例子中，会出现新的 Elvis 实例）。为了防止这种情况发生，将这个<code>readResolve</code>方法添加到 Elvis 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现单例的第三种方法是，声明单一元素的枚举类</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式跟公共成员变量方法很类似，但更简洁。枚举也无偿地提供了序列化机制，而且即使是在面对复杂的序列化或反射攻击的时候，也不用担心它会被多次实例化。单一元素的枚举让人感觉有点不自然，但不可否认，它是实现单例的最佳方式。注意，如果单例必须继承<code>Enum</code>以外的父类，那么就不能使用这种方法。（当然，<code>Enum</code>可以实现接口）</p><h2 id="第4条：使用私有构造方法实现非实例化"><a href="#第4条：使用私有构造方法实现非实例化" class="headerlink" title="第4条：使用私有构造方法实现非实例化"></a>第4条：使用私有构造方法实现非实例化</h2><p>有时候，你可能需要编写一个只包含静态方法和静态属性的类。 这种类的名声很不好，因为有些人会在面向对象语言中滥用这样的类来编写过程化的程序。</p><p>尽管如此，它们确实有着特有的用途。</p><ul><li><p>比如像<code>java.lang.Math</code>或<code>java.util.Arrays</code>，它们可以用来把基本类型的值或数组类型上的相关方法组织起来。</p></li><li><p>也可以像<code>java.util.Collections</code>的方式，把实现特定接口的对象使用静态方法（包括工厂方法，详见第 1 条）进行分组。（从 Java 8 开始，你也可以将这些方法放在接口中，如果是你编写了接口并可以进行修改。）</p></li><li><p>最后，还可以利用这种类把 final 类上的方法进行分组，因为final类不存在子类。</p></li></ul><p>通过将它声明为抽象类，来强制其实现非实例化显然是行不通的。因为该类可以被子类化，子类依然可以被实例化。而且，它会误导使用者以为该类是为继承而设计的（详见第 19 条）。不过，有一个简单的方法来确保非实例化：当类不包含显式构造方法时，会生成一个默认构造方法，因此可以通过包含一个私有构造方法来实现类的非实例化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilityClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 禁止默认构造函数以实现非实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UtilityClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于显式构造方法是私有的，所以在类之外不可访问到。<code>AssertionError</code>异常不是严格要求的，但它提供了一种保证，以防在类中意外地调用构造方法。它保证类在任何情况下都不会被实例化。这个用法有点违合，好像构造方法就是设计成不能调用的一样。因此，像上述代码一样，添加注释是种非常明智的做法。</p><p>这种习惯有一个副作用，阻止了类的子类化。因为<strong>所有的构造方法都必须显式或隐式地调用父类构造方法</strong>，而子类没有可访问的父类构造方法来调用。</p><h2 id="第5条：依赖注入优于硬连接资源（hardwiring-resources）"><a href="#第5条：依赖注入优于硬连接资源（hardwiring-resources）" class="headerlink" title="第5条：依赖注入优于硬连接资源（hardwiring resources）"></a>第5条：依赖注入优于硬连接资源（hardwiring resources）</h2><p>许多类依赖于一个或多个底层资源。例如，拼写检查器依赖于字典。常见的一种方式，是将此类声明为静态成员变量（详见第 4 条）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态成员变量使用不当，不灵活、不可测试！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lexicon dictionary = ...;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// Noninstantiable</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种常见方式，是将它们实现为单例（详见第 3 条）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单例使用不当，不灵活、不可测试！</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary = ...;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">(...)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> INSTANCE = <span class="keyword">new</span> SpellChecker(...);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种方法都不令人满意，因为它们只为对象提供了一本字典。在实际中，每种语言都有自己的字典，特殊的字典被用于特殊的词汇表。另外，使用专门的字典来进行测试也是可取的。想当然地认为一本字典就足够了，这是十分不可取的。</p><p>可以通过使<code>dictionary</code>属性设置为非<code>final</code>，并添加一个方法来更改现有拼写检查器中的字典，从而让拼写检查器支持多个字典，但是在并发环境中，这很笨拙且容易出错，不可行。静态成员变量和单例不适用于那些行为被底层资源参数化的类。</p><p>若类支持创建多个实例的 （如上述例子中的<code>SpellChecker</code>），每个实例都需要使用者指定资源（如上述例子中的<code>dictionary</code>）。满足这一需求的简单模式是在创建新实例时将资源传递到构造方法中。这是<em>依赖注入</em>（dependency injection）的一种形式：字典是拼写检查器的一个依赖项，当它创建时被注入到拼写检查器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖注入提供了灵活性和可测试性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Lexicon dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = Objects.requireNonNull(dictionary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖注入模式非常简单，许多编程者用了很多年，却不知道它有一个名字。 虽然拼写检查器的例子中只有一个资源（字典），但其实依赖项注入可以使用任意数量的资源和任意依赖图。 它保持了不变性（详见第17条），因此多个客户端可以共享依赖对象（假设客户需要相同的底层资源）。 依赖注入同样适用于构造方法，静态工厂（详见第1条）和 builder 模式（详见第2条）。</p><p>该模式的一个非常有用的变型是将资源工厂传递给构造方法。 工厂是可以重复调用以创建类型实例的对象。 这种工厂体现了<em>工厂方法模式</em>（Factory Method pattern）。 Java 8 中引入的<code>Supplier&lt;T&gt;</code>接口非常适合代表工厂。 在输入上采用<code>Supplier&lt;T&gt;</code>的方法通常应该使用<em>有界通配符类型</em>（bounded wildcard type）（详见第31条）来约束工厂的类型参数，以允许使用者传入工厂，创建指定类型的任何子类型。 例如，下面是一个使用者提供的工厂生成 tile 的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mosaic create(Supplier&lt;? extends Tile&gt; tileFactory) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>尽管依赖注入极大地提高了灵活性和可测试性，但它可能使大型项目变得混乱，这些项目通常包含数千个依赖项。使用依赖注入框架（如：Dagger、Guice或Spring）可以消除这些混乱（这些框架的使用超出了本书的内容）。但请注意，为手动依赖注入而设计的 API 非常适合使用这些框架。</p><p>总之，不要使用单例或静态成员变量来实现依赖于其行为影响类的一个或多个底层资源的类，并且不要让类直接创建这些资源。而是应该将资源或工厂传递给构造方法（或静态工厂或 builder 模式）。这种称为依赖注入的方法将极大地增强类的灵活性、可重用性和可测试性。</p><h2 id="第6条：避免创建不必要的对象"><a href="#第6条：避免创建不必要的对象" class="headerlink" title="第6条：避免创建不必要的对象"></a>第6条：避免创建不必要的对象</h2><p>一般来说，每次需要时一个对象时，最好考虑重用以前的对象而不是创建一个具有相同功能新对象。重用既快速，又流行。如果对象是不可变的（见第17条），它总是可以被重用。</p><p>作为一个极端的反面例子，请考虑以下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"bikini"</span>); <span class="comment">// DON'T DO THIS!</span></span><br></pre></td></tr></table></figure><p>语句每次被执行时都会创建一个新的String实例，但是这些对象的创建都不是必需的。String 构造方法的参数<code>(&quot;bikini&quot;)</code>本身就是一个String实例，它与构造方法创建的所有对象的功能相同。如果这种用法发生在循环中，或者在频繁调用的方法中，就可以创建很多个毫无必要的String实例。</p><p>改进后的版本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"bikini"</span>;</span><br></pre></td></tr></table></figure><p>这个版本使用单个String实例，而不是每次执行时创建一个新实例。此外，它可以保证，对于同一虚拟机上中的运行的代码，只要它们包含相同的字符串字面量，对象就能被重用。</p><p>通过使用静态工厂方法（见第1条），可以避免创建不需要的对象。例如，工厂方法<code>Boolean.valueOf(String)</code>比构造方法<code>Boolean(String)</code>更可取（后者在 Java 9 中已被弃用）。构造方法每次调用时都必须创建一个新对象，而工厂方法则没有这种要求，实际上也不会这样做。除了重用不可变对象，如果知道它们不会被修改，还可以重用可变对象。</p><p>一些对象的创建比其他对象的创建要昂贵得多。如果要重复使用这样一个「昂贵的对象」，建议将其缓存起来以便重复使用。不幸的是，当创建这样一个对象时并不总是很直观明显的。假设你想写一个方法来确定一个字符串是否是一个有效的罗马数字。以下是使用正则表达式完成此操作时最简单方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Performance can be greatly improved!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">"^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)"</span></span><br><span class="line">            + <span class="string">"(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现的问题在于它依赖于<code>String.matches</code>方法。虽然<code>String.matches</code>是检查字符串是否与正则表达式匹配的最简单方法，但它不适合在性能临界的情况下重复使用。其问题是它在内部为正则表达式创建一个Pattern 实例，并且只使用它一次，之后它就被自动GC。创建 Pattern 实例是昂贵的，因为它需要将正则表达式编译成<em>有限状态机</em>（finite state machine）。</p><p>为了提高性能，作为类初始化的一部分，将正则表达式显式编译为一个 Pattern 实例（不可变），缓存它，并在<code>isRomanNumeral</code>方法的每个调用中重复使用相同的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reusing expensive object for improved performance</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RomanNumerals</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern ROMAN = Pattern.compile(</span><br><span class="line">            <span class="string">"^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)"</span></span><br><span class="line">            + <span class="string">"(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$"</span>);</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果经常调用，<code>isRomanNumeral</code>的改进版本的性能会显著提升。为不可见的 Pattern 实例创建静态 final 修饰的属性，并给它一个名字，这个名字比正则表达式本身更具可读性。</p><p>如果包含<code>isRomanNumeral</code>方法的改进版本的类被初始化，但该方法从未被调用，则 ROMAN 属性则没必要初始化。在第一次调用<code>isRomanNumeral</code>方法时，可以通过<em>延迟初始化</em>（ lazily initializing）属性（见第83条）来延迟初始化，但一般不建议这样做。延迟初始化常常会导致实现复杂化，而对性能没有改进（见第67条）。</p><p>当一个对象是不可变的时，很明显它可以被安全地重用，但是在其他情况下，它远没有那么明显，甚至是违反直觉的。考虑<em>适配器</em>（adapters）的情况，也称为视图（views）。一个适配器是这样一个对象：它把功能委托一个<em>后备对象</em>（backing object），从而为后备对象提供一个可替代的接口。由于适配器除了后备对象外，没有其他状态信息，因此不需要为某个给定对象创建多个适配器的实例。</p><p>例如，Map 接口的<code>keySet</code>方法返回 Map 对象的 Set 视图，包含 Map 中的所有 key。粗看起来，似乎每次调用<code>keySet</code>都必须创建一个新的 Set 实例，但是对给定 Map 对象的<code>keySet</code>的每次调用都返回相同的 Set 实例。 尽管返回的 Set 实例通常是可变的，但是所有返回的对象在功能上都是相同的：当其中一个返回的对象发生变化时，所有其他对象也都变化，因为它们全部是由一个 Map 实例支持的。 虽然创建<code>keySet</code>视图对象的多个实例基本上是无害的，却也是没必要的。</p><p>另一种创建不必要的对象的方法是<em>自动装箱</em>（autoboxing），它允许程序员混用基本类型和基本类型的包装类，按需要自动装箱和拆箱。自动装箱虽然使基本类型和基本类型的包装类之间的差别模糊不清，但不会完全消除。它们有微妙的语义区别和不太细微的性能差异（见第61条）。考虑下面的方法，它计算所有正整数的总和。要做到这一点，程序必须使用<code>long</code>类型，因为<code>int</code>类型不足以保存所有正整数的总和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Hideously slow! Can you spot the object creation?</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的结果是正确的，但由于写错了一个字符，运行的结果要比实际慢很多。变量<code>sum</code>被声明成了<code>Long</code>而不是<code>long</code>，这意味着程序构造了大约 231 不必要的<code>Long</code>实例（大约每次往<code>Long</code>类型的<code>sum</code>变量中增加一个<code>long</code>类型构造的实例），把<code>sum</code>变量的类型由<code>Long</code>改为<code>long</code>，运行时间从 6.3秒降低到了0.59 秒。这个教训很明显：<strong>优先使用基本类型而不是装箱的基本类型，要当心无意识的自动装箱。</strong></p><p>这一条不应该被误解为暗示对象创建是昂贵的，应该避免创建对象。相反，使用构造方法创建和回收小的对象是非常廉价，构造方法只会做很少的显示工作，尤其是在现代 JVM 实现上。创建额外的对象以增强程序的清晰度、简单性和功能性，这通常是件好事。</p><p>相反地，通过维护自己的<em>对象池</em>（object pool）来避免对象创建并不是一个好主意，除非池中的对象非常重量级。对象池的典型例子就是数据库连接池。建立连接的成本非常高，因此重用这些对象是有意义的。但是，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代 JVM 实现具有高度优化的垃圾收集器，它们的性能远胜于创建轻量级对象池。</p><p>这个条目的对应面是第50条的<em>防御性复制</em>（defensive copying）。现在说：「当你应该重用一个现有的对象时，不要创建一个新的对象」，而第50条说：「当你应该创建一个新的对象时，不要重用现有的对象。」请注意，提倡防御性复制时，因重用对象所付出的代价，要远远大于创建重复的对象。未能在需要的情况下实施防御性复制会导致潜在的错误和安全漏洞；而不必要地创建对象只会影响程序的风格和性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;声明：本专题为Joshua Bloch所著《Effiective Java》的笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;James Gosling（Java之父）：“我很希望10年前就拥有这本书。
      
    
    </summary>
    
      <category term="Java" scheme="https://GxkOrd.github.io/categories/Java/"/>
    
    
      <category term="《Effiective Java》第3版" scheme="https://GxkOrd.github.io/tags/%E3%80%8AEffiective-Java%E3%80%8B%E7%AC%AC3%E7%89%88/"/>
    
      <category term="静态工厂方法" scheme="https://GxkOrd.github.io/tags/%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    
      <category term="Builder模式" scheme="https://GxkOrd.github.io/tags/Builder%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>17. Letter Combinations of a Phone Number(Medium)</title>
    <link href="https://GxkOrd.github.io/2019/08/20/%E7%AE%97%E6%B3%95/LeetCode/17.%20Letter%20Combinations%20of%20a%20Phone%20Number(Medium)/"/>
    <id>https://GxkOrd.github.io/2019/08/20/算法/LeetCode/17. Letter Combinations of a Phone Number(Medium)/</id>
    <published>2019-08-20T02:28:00.000Z</published>
    <updated>2019-10-16T07:35:03.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description:</strong><br>Given a string containing digits from  <code>2-9</code>  inclusive, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/08/20/算法/LeetCode/17. Letter Combinations of a Phone Number(Medium)/题目描述.png" alt="题目描述" title>                </div>                <div class="image-caption">题目描述</div>            </figure><blockquote><p><strong>Example:</strong></p><blockquote><p><strong>Input:</strong> “23”<br><strong>Output:</strong> [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></blockquote><p><strong>Note:</strong></p><blockquote><p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p></blockquote></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述：</strong><br>给定包含2-9（包含2和9）的数字的字符串，返回该数字可能表示的所有可能的字母组合。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/08/20/算法/LeetCode/17. Letter Combinations of a Phone Number(Medium)/题目描述.png" alt="题目描述" title>                </div>                <div class="image-caption">题目描述</div>            </figure><blockquote><p><strong>例如：</strong></p><blockquote><p><strong>输入：</strong> “23”</p><p><strong>输出：</strong> [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></blockquote><p><strong>另外：</strong></p><blockquote><p>虽然上述例子的输出是按字典顺序排列的，但您的答案可以是任何顺序。</p></blockquote></blockquote></blockquote><h1 id="解法一（mine）"><a href="#解法一（mine）" class="headerlink" title="解法一（mine）"></a>解法一（mine）</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><ol><li><p>使用String数组保存字符串和数字映射关系（只需数组下标+2，即可获取对应数字）。</p></li><li><p>获得输入字符串中所有数字对应的字符串，存入集合（letterList）。</p></li><li><p>取出letterList中第一个元素，分割成字符数组，分别放入集合1（res1）。</p></li><li><p>取出letterList中第二个元素，分割成字符数组，与集合1中的所有元素进行<code>乘积</code>运算，将结果分别放入集合2（res2）。</p></li><li><p>res1和res2交换，以保证需要进行<code>乘积</code>运算的集合为res1。</p></li><li><p>重复步骤3和4，直至遍历完letterList。</p></li><li><p>最后一步无需再交换res1和res2，直接返回res2即可。</p></li></ol><blockquote><p>运行速度：超过了65.32%的解答。</p><p>内存使用：超过了98.63%的解答。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用string数组保存a-z,</span></span><br><span class="line">        String[] letters = <span class="keyword">new</span> String[]&#123;<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = digits.toCharArray();</span><br><span class="line">        <span class="comment">// 保存digits每个字符对应的string集合</span></span><br><span class="line">        List&lt;String&gt; letterList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : charArray) &#123;</span><br><span class="line">            <span class="comment">// 注意：这里需要char转int，若直接(int)c，会返回ascII码</span></span><br><span class="line">            letterList.add(letters[Integer.parseInt(String.valueOf(c)) - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; res2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (String letter : letterList) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = letter.toCharArray();</span><br><span class="line">            <span class="keyword">if</span> (res2.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 若res2为空，直接将letter放入即可</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">                    res2.add(String.valueOf(c));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若res2不为空，交换res1和res2</span></span><br><span class="line">                temp = res1;</span><br><span class="line">                res1 = res2;</span><br><span class="line">                res2 = temp;</span><br><span class="line">                <span class="comment">// 将遍历letter中每个字符，分别拼接res1中的每一个字符串，并放入res2</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String s : res1) &#123;</span><br><span class="line">                        res2.add(s + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 清空res1</span></span><br><span class="line">                res1.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法二（官方）"><a href="#解法二（官方）" class="headerlink" title="解法二（官方）"></a>解法二（官方）</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><ol><li><p>使用map存储（比解法一中的直接数组下标进行存取，更方便维护）。</p></li><li><p>回溯。</p></li></ol><blockquote><p>运行速度：超过了65.32%的解答。</p><p>内存使用：超过了98.63%的解答。</p></blockquote><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; phone = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">"2"</span>, <span class="string">"abc"</span>);</span><br><span class="line">        put(<span class="string">"3"</span>, <span class="string">"def"</span>);</span><br><span class="line">        put(<span class="string">"4"</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        put(<span class="string">"5"</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        put(<span class="string">"6"</span>, <span class="string">"mno"</span>);</span><br><span class="line">        put(<span class="string">"7"</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        put(<span class="string">"8"</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        put(<span class="string">"9"</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    List&lt;String&gt; output = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String combination, String next_digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if there is no more digits to check</span></span><br><span class="line">        <span class="keyword">if</span> (next_digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// the combination is done</span></span><br><span class="line">            output.add(combination);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if there are still digits to check</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// iterate over all letters which map</span></span><br><span class="line">            <span class="comment">// the next available digit</span></span><br><span class="line">            String digit = next_digits.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            String letters = phone.get(digit);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length(); i++) &#123;</span><br><span class="line">                String letter = phone.get(digit).substring(i, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// append the current letter to the combination</span></span><br><span class="line">                <span class="comment">// and proceed to the next digits</span></span><br><span class="line">                backtrack(combination + letter, next_digits.substring(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.length() != <span class="number">0</span>)</span><br><span class="line">            backtrack(<span class="string">""</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><h2 id="主要思想-2"><a href="#主要思想-2" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote><p>讨论区的答案，与官方答案类似。</p></blockquote><p>注意几点优化的操作：</p><ol><li><p>使用StringBuilder优化String的拼接。</p></li><li><p><code>arr[c - &#39;0&#39;]</code>的写法，比解法一中的<code>arr[Integer.parseInt(String.valueOf(c))]</code>更间接有效，</p></li><li><p>LinkedList比ArrayList更快地增删元素。</p></li></ol><blockquote><p>运行速度：超过了100%的解答。</p><p>内存使用：超过了98.63%的解答。</p></blockquote><h2 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String arr[] = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            recurse(<span class="keyword">new</span> StringBuilder(), digits, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurse</span><span class="params">(StringBuilder sb, String digits, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = digits.charAt(pos);</span><br><span class="line">        String curr = arr[c - <span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.length(); i++) &#123;</span><br><span class="line">            c = curr.charAt(i);</span><br><span class="line">            sb.append(c);</span><br><span class="line">            <span class="keyword">if</span> (pos == digits.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                res.add(sb.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                recurse(sb, digits, pos + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb = sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://GxkOrd.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://GxkOrd.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Medium" scheme="https://GxkOrd.github.io/tags/LeetCode-Medium/"/>
    
  </entry>
  
  <entry>
    <title>1. SpringBoot入门</title>
    <link href="https://GxkOrd.github.io/2019/07/20/Java/SpringBoot/1.%20SpringBoot%E5%85%A5%E9%97%A8/"/>
    <id>https://GxkOrd.github.io/2019/07/20/Java/SpringBoot/1. SpringBoot入门/</id>
    <published>2019-07-20T00:05:00.000Z</published>
    <updated>2019-07-25T10:35:57.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot入门"><a href="#Springboot入门" class="headerlink" title="Springboot入门"></a>Springboot入门</h1><h2 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><ul><li><p>简化Spring应用开发的一个框架</p></li><li><p>整个Spring技术栈的一个大整合</p></li><li><p>J2EE开发的一站式解决方案</p></li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>2014，martin fowler</p><p>微服务：架构风格（服务微化）</p><p>一个应用应该是一组小型服务，可以通过HTTP的方式进行互通。</p><blockquote><ul><li><p>单体应用：ALL IN ONE</p></li><li><p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p></li></ul></blockquote><p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" target="_blank" rel="noopener">微服务文档</a></p><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>功能：浏览器发送hello请求，服务器接受请求并处理，响应“Hello World!”字符串。</p><h3 id="创建maven项目"><a href="#创建maven项目" class="headerlink" title="创建maven项目"></a>创建maven项目</h3><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.gxk&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-01-helloworld&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h3 id="编写主程序"><a href="#编写主程序" class="headerlink" title="编写主程序"></a>编写主程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个SpringBoot主程序类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动SpringBoot应用</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写Controller、Service"><a href="#编写Controller、Service" class="headerlink" title="编写Controller、Service"></a>编写Controller、Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>直接右键运行主程序类即可</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><ol><li><p>maven中导入插件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 可将应用打包成可执行jar包的插件 --&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p>点击idea右侧工具栏中的<strong>Maven</strong>，运行”<strong>项目名-Lifecycle-package</strong>“</p></li><li><p>将target目录下jar包拷出，使用cmd的”<strong>java -jar xxx.jar</strong>“运行即可</p></li></ol><h2 id="HelloWorld探究"><a href="#HelloWorld探究" class="headerlink" title="HelloWorld探究"></a>HelloWorld探究</h2><h3 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h3><ol><li><p>父项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">他的父项目是：</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring‐boot‐dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath&gt;../../spring‐boot‐dependencies&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">他来真正管理Spring Boot应用里面的所有依赖版本</span><br></pre></td></tr></table></figure></li></ol><p>   Spring Boot的版本仲裁中心。</p><p>   以后我们导入依赖默认是不需要写版本（没有在dependencies里面管理的依赖自然需要声明版本号）</p><ol start="2"><li><p>启动器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>   spring-boot-starter：springboot的场景启动器，帮我们导入了指定模块（如：web）正常运行所依赖的组件。</p><p>   <strong>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter，相关场景的所有依赖都会导入进来。需要什么功能就导入什么场景启动器</strong></p><h3 id="主程序类"><a href="#主程序类" class="headerlink" title="主程序类"></a>主程序类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个SpringBoot主程序类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动SpringBoot应用</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@SpringBootApplication</strong>：用来标注SpringBoot的主程序类，SpringBoot<br>应该运行这个类的main方法来启动SpringBoot应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">), @<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>&#125;</span></span><br><span class="line"><span class="class">)&#125;</span></span><br><span class="line"><span class="class">)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">SpringBootApplication</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>@SpringBootConfiguration</strong>：标注SpringBoot的配置类</p><ul><li><strong>@Configuration</strong>：标注配置类（Spring）</li></ul></li><li><p><strong>@EnableAutoConfiguration</strong>：开启自动配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>@AutoConfigurationPackage</strong>：自动配置包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;Registrar<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">AutoConfigurationPackage</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">    Registrar() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AutoConfigurationPackages.register(registry, (<span class="keyword">new</span> AutoConfigurationPackages.PackageImport(metadata)).getPackageName());</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> AutoConfigurationPackages.PackageImport(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>**将主配置类所在包及下面所有子包里面的所有组件扫描到Spring容器。**</code></pre><ul><li><p><strong>@Import</strong>({AutoConfigurationImportSelector.class})</p><p>AutoConfigurationImportSelector：导入哪些组件的选择器。</p><p>将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。</p><p>会给容器中导入非常多的自动配置类（xxxAutoConfiguration），就是给容器中导入这个场景需要的所有组件，并配置好这些组件。</p><p>Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。以前我们需要自己配置的东西，自动配置类都帮我们。</p></li></ul><h2 id="使用Spring-Initializer快速创建SpringBoot项目"><a href="#使用Spring-Initializer快速创建SpringBoot项目" class="headerlink" title="使用Spring Initializer快速创建SpringBoot项目"></a>使用Spring Initializer快速创建SpringBoot项目</h2><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目<br>选择我们需要的模块；向导会联网创建Spring Boot项目<br>默认生成的Spring Boot项目</p><ul><li><p>主程序已经生成好了，我们只需要我们自己的逻辑</p></li><li><p>resources文件夹中目录结构</p><ul><li><p>static：保存所有的静态资源(js/css/images)</p></li><li><p>templates：保存所有的模板页面(SpringBoot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面，可以使用模板引擎(如：freemarker、thymeleaf))</p></li><li><p>application.properties：SpringBoot应用的配置文件，可以修改一些默认设置</p></li></ul></li></ul><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><p>Spring Boot使用全局配置文件，配置文件名是固定的：</p><ul><li><strong>application.properties</strong></li><li><strong>application.yml</strong></li></ul><p>配置文件作用：修改Spring Boot在底层封装好的默认值。</p><blockquote><p>YAML（YAML AIN’T Markup Language）：</p><p>是一个标记语言，</p><p>又不是一个标记语言。</p></blockquote><p>以前的配置文件，大多数使用的是 <strong>xxx.xml</strong>文件。</p><p>yaml以<strong>数据</strong>为中心，比json、xml等更适合做配置文件。</p><ul><li><p>YMAL：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9000</span></span><br></pre></td></tr></table></figure></li><li><p>xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><strong>k:(空格)v</strong>:表示一堆键值对（<strong>空格必须有</strong>）；</p><p>以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一层级的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><p>属性和值也是大小写敏感。</p><h3 id="值的写法"><a href="#值的写法" class="headerlink" title="值的写法"></a>值的写法</h3><p><strong>字面量：普通的值（数字，字符串，布尔）</strong></p><p>k: v:字面量直接来写</p><ul><li><p>字符串默认不用加上单引号或者双引号</p></li><li><p>“”:<strong>双引号</strong>  不会转义字符串里的特殊字符；特殊字符会作为本身想要表示的意思如：<code>name:&quot;zhangsan\n lisi&quot;</code>  输出：<code>zhangsan换行 lisi</code></p></li><li><p>‘’:<strong>单引号</strong>  会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p>如：<code>name:&#39;zhangsan\n lisi&#39;</code>  输出：<code>zhangsan\n lisi</code></p></li><li><p><strong>对象、Map（属性和值）键值对</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">frends:</span></span><br><span class="line">    <span class="attr">lastName:</span> <span class="string">zhangsan</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></li></ul><p>  行内写法：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>数组（List、Set）:</strong> 用-表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line">    <span class="string">‐</span> <span class="string">cat</span></span><br><span class="line">    <span class="string">‐</span> <span class="string">dog</span></span><br><span class="line">    <span class="string">‐</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure></li></ul><p>  行内写法：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>组合变量</strong>：</p><p>多个组合到一起</p></li></ul><h2 id="配置文件值注入"><a href="#配置文件值注入" class="headerlink" title="配置文件值注入"></a>配置文件值注入</h2><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><ol><li><p>application.yml 配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">18</span></span><br><span class="line">  <span class="attr">boss:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line">  <span class="attr">maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="number">12</span><span class="string">&#125;</span></span><br><span class="line">  <span class="attr">lists:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">lisi</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">zhaoliu</span></span><br><span class="line">  <span class="attr">dog:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">wangwang</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">last-name:</span> <span class="string">wanghuahua</span></span><br></pre></td></tr></table></figure></li><li><p>application.properties 配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.age</span>=<span class="string">12</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">person.last-name</span>=<span class="string">张三</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">v2</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">wanghuahu</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure></li></ol><p>   idea配置文件编码为utf-8，properties文件编码默认GBK，所以中文输出乱码。</p><p>   解决方法：settings → file encoding → [property → utf-8，勾选转成ascii]</p><ol start="3"><li><p>javaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将配置文件的配置每个属性的值，映射到组件中</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ConfigurationProperties</span>:告诉SpringBoot将文本的所有属性和配置文件中的相关配置进行绑定</span></span><br><span class="line"><span class="comment">* prefix = "person" 与配置文件进行一一映射</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 只有这个组件是容器中的组件，才能提供到容器中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   导入配置文件处理器，以后编写配置就有提示了</p>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐configuration‐processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 相当于：</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *     &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量/#&#123;spEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/bean&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.last-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;11*2&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"true"</span>)</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件属性</td><td>单个指定</td></tr><tr><td>松散绑定(语法)</td><td>支持</td><td>不支持</td></tr><tr><td>spEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型</td><td>支持</td><td>不支持</td></tr></tbody></table><blockquote><p><strong>松散语法</strong>：javaBean中last-name(或者lastName)  → application.properties中的last-name</p><p><strong>spEL语法</strong>：#{11*2}</p><p><strong>JSR303</strong>：@Value会直接忽略，校验规则</p></blockquote><p><strong>JSR303校验</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂类型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *     &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量/#&#123;spEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/bean&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.maps&#125;"</span>) <span class="comment">// 会报错，@Value不支持复杂类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景分析</strong>：</p><ul><li><p>如果我们只是在某个业务逻辑中获取一下配置文件的某一项值，使用@Value</p></li><li><p>如果专门编写了一个javaBean和配置文件进行映射，我们直接使用@ConfigurationProperties</p></li></ul><p>例如：</p><ol><li><p>编写新的Controller文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.last-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>+ name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.age</span>=<span class="string">12</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">person.last-name</span>=<span class="string">李四</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">v2</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">wanghuahu</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><p><code>Hello 李四</code></p></li></ol><h3 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h3><ul><li><p><strong>@PropertySource</strong>：</p><p><strong>作用</strong>：加载指定的properties配置文件</p><p><strong>举例</strong>：</p><ol><li><p>新建一个person.properties文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.age</span>=<span class="string">12</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">person.last-name</span>=<span class="string">李四</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">v2</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">wanghuahu</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>在javaBean中加入@PropertySource注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><strong>@ImportResource</strong></p><p><strong>作用</strong>：导入Spring配置文件，并且让这个配置文件生效</p><p><strong>举例</strong>：</p><ol><li><p>新建一个Spring的配置文件，bean.xml  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"HelloService"</span> <span class="attr">class</span>=<span class="string">"com.wdjr.springboot.service.HelloService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>编写测试类，检查容器是否加载Spring配置文件写的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ApplicationContext ioc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> b = ioc.containsBean(<span class="string">"HelloService"</span>);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>运行结果</p><p>false</p></li><li><p>使用@ImportResource注解</p><p>将@ImportResource标注在主配置类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations=&#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBoot02ConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            SpringApplication.run(SpringBoot02ConfigApplication.class, args)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>运行结果</p><p>true</p></li></ol><p>  <strong>缺点</strong>：每次指定xml文件太麻烦</p><p>  SpringBoot推荐给容器添加组件的方式（@Configuration + @Bean）：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来代替之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;/bean&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将方法的返回值添加到容器中,这个组件的id默认为方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"配置类给容器添加了HelloService组件"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ApplicationContext ioc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> b = ioc.containsBean(<span class="string">"helloService01"</span>);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h2><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$&#123;random.value&#125;</span> <span class="string">、$&#123;random.int&#125;、$&#123;random.long&#125;、</span></span><br><span class="line"><span class="attr">$&#123;random.int(10)&#125;、$&#123;random.int[100,200]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="获取配置值"><a href="#获取配置值" class="headerlink" title="获取配置值"></a>获取配置值</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.age</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">person.last-name</span>=<span class="string">张三$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">v2</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">$&#123;person.last-name&#125;'s wanghuahu</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure><p>存在以下两种情况：</p><p>没有声明<code>person.last-name</code>会报错，新声明的需要加默认值。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">person.age</span>=<span class="string">$&#123;random.int&#125;</span></span><br><span class="line"><span class="meta">person.boss</span>=<span class="string">false</span></span><br><span class="line"><span class="meta">person.last-name</span>=<span class="string">张三$&#123;random.uuid&#125;</span></span><br><span class="line"><span class="meta">person.maps.k1</span>=<span class="string">v1</span></span><br><span class="line"><span class="meta">person.maps.k2</span>=<span class="string">v2</span></span><br><span class="line"><span class="meta">person.lists</span>=<span class="string">a,b,c</span></span><br><span class="line"><span class="meta">person.dog.name</span>=<span class="string">$&#123;person.hello:hello&#125;'s wanghuahu</span></span><br><span class="line"><span class="meta">person.dog.age</span>=<span class="string">15</span></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<code>hello&#39;s wanghuahua</code></p><h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><h3 id="多Profile文件"><a href="#多Profile文件" class="headerlink" title="多Profile文件"></a>多Profile文件</h3><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml</p><ul><li>application.properties</li><li>application-dev.properties</li><li>application-prod.properties</li></ul><p>默认使用application.properties</p><p>application.properties配置文件指定</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure><h3 id="YAML文档块"><a href="#YAML文档块" class="headerlink" title="YAML文档块"></a>YAML文档块</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure><h3 id="激活指定profile"><a href="#激活指定profile" class="headerlink" title="激活指定profile"></a>激活指定profile</h3><ol><li><p>在配置文件中激活</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.profiles.active</span>=<span class="string">dev</span></span><br></pre></td></tr></table></figure></li><li><p>命令行</p><p><code>java -jar xxx.jar --spring.profiles.active=dev</code></p></li><li><p>虚拟机参数</p><p><code>-Dspring.profiles.active=dev</code></p></li></ol><h2 id="加载配置文件位置"><a href="#加载配置文件位置" class="headerlink" title="加载配置文件位置"></a>加载配置文件位置</h2><p>SpringBoot启动扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><ul><li>file:./config/</li><li>file./</li><li>classpath:/config/</li><li>classpath:/</li></ul><p><strong>优先级从高到低顺序，高优先级会覆盖低优先级的相同配置，互补配置</strong>。</p><p>也可以通过spring.config.location来改变默认配置文件位置 。</p><p><strong>项目打包好了以后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认的配置文件会共同起作用，互补配置</strong>。</p><p><code>java -jar xxx.jar --spring.config.location=E:/work/application.properties</code></p><p><strong>运维比较有用，从外部加载，不用修改别的文件</strong></p><h2 id="外部配置的加载顺序"><a href="#外部配置的加载顺序" class="headerlink" title="外部配置的加载顺序"></a>外部配置的加载顺序</h2><p><strong>SpringBoot也可以从以下位置加载配置，优先级从高到低，高优先级覆盖低优先级，可以互补。</strong></p><ol><li><p>命令行参数</p><p>java -jar xxx.jar –server.port=9005 –server.context-path=/abc</p></li><li><p>来自java:comp/env的JNDI属性</p></li><li><p>java系统属性（System.getProperties()）</p></li><li><p>操作系统环境变量</p></li><li><p>RandomValuePropertySource配置的random.*属性值</p></li><li><p><strong>jar包外部的application-{profile}.properties 或 application.yml(带Spring.profile)配置文件</strong></p></li><li><p><strong>jar包内部的application-{profile}.properties 或 application.yml(带Spring.profile)配置文件</strong></p></li><li><p><strong>jar包外部的application.properties 或 application.yml(带Spring.profile)配置文件</strong></p></li><li><p><strong>jar包内部的application.properties 或 application.yml(不带spring.profile)配置文件</strong></p></li><li><p>@Configuration注解类的@PropertySource</p></li><li><p>通过SpringApplication.setDefaultProperties指定的默认属性</p></li></ol><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">Spring的所有配置参数</a></p><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><ol><li><p>SpringBoot启动的时候加载主配置类，开启自动配置功能，@EnableAutoConfiguration</p></li><li><p>@EnableAutoConfiguration 作用：</p><ul><li><p>利用AutoConfigurationImportSelector给容器中导入一些组件？</p></li><li><p>可以查看selectImports()方法的内容</p></li><li><p>List configurations = this.getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames(）</span><br><span class="line">扫描所有jar包类路径下的 MATA-INF/spring.factories</span><br><span class="line">把扫描到的这些文件的内容包装成properties对象</span><br><span class="line">从properties中获取到EnableAutoConfiguration<span class="class">.<span class="keyword">class</span>类（类名）对应的值，然后把他们添加到容器中</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><p>   <strong>将类路径下 MATE-INF/spring.factories里面配置的所有的EnableAutoConfiguration的值加入到了容器中。</strong></p><ol start="3"><li><p>每一个自动配置类进行自动配置功能</p></li><li><p>以<strong>HttpEncodingAutoConfiguration</strong> 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//表示是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;HttpEncodingProperties<span class="class">.<span class="keyword">class</span>&#125;)//启动指定类的<span class="title">Configurationproperties</span>功能；将配置文件中的值和<span class="title">HttpEncodingProperties</span>绑定起来了；并把<span class="title">HttpEncodingProperties</span>加入<span class="title">ioc</span>容器中</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span>//根据不同的条件，进行判断，如果满足条件，整个配置类里面的配置就会失效，判断是否为<span class="title">web</span>应用；</span></span><br><span class="line"><span class="class">(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= Type.SERVLET</span><br><span class="line">)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>&#125;)//判断当前项目有没有这个类，解决乱码的过滤器</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(</span></span><br><span class="line"><span class="class">    <span class="title">prefix</span> </span>= <span class="string">"spring.http.encoding"</span>,</span><br><span class="line">    value = &#123;<span class="string">"enabled"</span>&#125;,</span><br><span class="line">    matchIfMissing = <span class="keyword">true</span></span><br><span class="line">)<span class="comment">//判断配置文件是否存在某个配置 spring.http.encoding，matchIfMissing = true如果不存在也是成立，即使不配置也生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="comment">//给容器添加组件，这个组件的值需要从properties属性中获取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">    <span class="comment">//只有一个有参数构造器情况下，参数的值就会从容器中拿</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>所有在配置文件中能配置的属性都是在xxxProperties类中封装着，配置文件能配置什么就可以参照某个功能对应的这个属性类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http.encoding"</span>) <span class="comment">// 从配置文件中的值进行绑定和bean属性进行绑定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   根据当前不同条件判断，决定这个配置类是否生效？</p><p>   一旦这个配置类生效；这个配置类会给容器添加各种组件；这些组件的属性是从对应的properties中获取的，这些类里面的每个属性又是和配置文件绑定的。</p><h3 id="所有自动配置组件"><a href="#所有自动配置组件" class="headerlink" title="所有自动配置组件"></a>所有自动配置组件</h3><p>每一个xxxAutoConfiguration这样的类都是容器中的一个组件，都加入到容器中。</p><p>作用：用它们做自动配置。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityRequestMatcherProviderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration</span></span><br></pre></td></tr></table></figure><h3 id="精髓"><a href="#精髓" class="headerlink" title="精髓"></a>精髓</h3><ol><li><p><strong>SpringBoot启动会加载大量的自动配置类</strong></p></li><li><p><strong>我们看我们需要的功能有没有SpringBoot默认写好的自动配置类</strong></p></li><li><p><strong>如果有，再看这个自动配置类中配置了哪些组件（只要有需要用的组件，就不需要再手动配置）；如果有，则需要自己手动配置。</strong></p></li><li><p><strong>给容器中自动配置添加组件的时候，会从properties类中获取属性。我们就可以在配置文件中指定这些属性的值</strong></p></li></ol><p>xxxAutoConfiguration：自动配置类，给容器中添加组件。</p><p>xxxProperties：封装配置文件中的属性。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul><li><p>@Conditional派生注解</p><blockquote><p>利用Spring注解版原生的@Conditional注解</p></blockquote><p> 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效。</p></li></ul><table><thead><tr><th>@Conditional派生注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean</td></tr><tr><td>@ConditionalOnMissBean</td><td>容器中不存在指定Bean</td></tr><tr><td>@ConditionalOnExpression</td><td>满足spEL表达式</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean,或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定的资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><ul><li><p>自动配置报告</p><p> 自动配置类必须在一定条件下生效。</p><p> 我们可以通过启用<code>debug=true</code>属性，配置文件，打印自动配合报告，这样就可以知道自动配置类生效。</p><p> 自动配置报告：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">============================</span><br><span class="line">  </span><br><span class="line">CONDITIONS EVALUATION REPORT</span><br><span class="line">============================</span><br><span class="line">  </span><br><span class="line"> Positive matches:（启动的，匹配成功的）</span><br><span class="line"> -----------------</span><br><span class="line">  </span><br><span class="line">   CodecsAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">http</span>.<span class="title">codec</span>.<span class="title">CodecConfigurer</span>'</span>; <span class="meta">@ConditionalOnMissingClass</span> <span class="function">did not find unwanted <span class="title">class</span> <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">   ......</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Negative matches:（没有启动的，没有匹配成功的）</span></span><br><span class="line"><span class="function">-----------------</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">   ActiveMQAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">   ......</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><table><thead><tr><th>日志抽象层</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL(Jakarta Commons Logging)</del>  SLF4j(Simple Logging Facade for Java)  <del>jboss-logging</del></td><td>Log4j  <del>JUL(java.util.logging)</del>  Log4j2 Logback</td></tr></tbody></table><p>选用SLF4J + Logback</p><blockquote><p>SpringBoot的底层是Spring框架，使用的JCL，SpringBoot改用了SLF4J。</p></blockquote><h2 id="SLF4J的使用"><a href="#SLF4J的使用" class="headerlink" title="SLF4J的使用"></a>SLF4J的使用</h2><h3 id="如何在系统中使用SLF4J"><a href="#如何在系统中使用SLF4J" class="headerlink" title="如何在系统中使用SLF4J"></a>如何在系统中使用SLF4J</h3><p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法。</p><p>应该给系统里面导入slf4j的jar包和logback的实现jar包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/07/20/Java/SpringBoot/1. SpringBoot入门/SLF4J具体绑定.png" alt="SLF4J具体绑定" title>                </div>                <div class="image-caption">SLF4J具体绑定</div>            </figure><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架的配置文件</strong>。</p><h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>如开发a系统（slf4j+logback）：Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis……</p><p>c</p><p><strong>如何让系统中所有日志统一到slf4j？</strong></p><ol><li><p><strong>将系统中其他日志框架排除出去</strong></p></li><li><p><strong>用中间包来替换原有的日志框架</strong></p></li><li><p><strong>导入slf4j的其他实现</strong></p></li></ol><h2 id="SpringBoot日志关系"><a href="#SpringBoot日志关系" class="headerlink" title="SpringBoot日志关系"></a>SpringBoot日志关系</h2><p>SpringBoot的日志功能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/07/20/Java/SpringBoot/1. SpringBoot入门/SpringBoot日志关系.jpg" alt="SpringBoot日志关系" title>                </div>                <div class="image-caption">SpringBoot日志关系</div>            </figure><p>总结：</p><ol><li><p>SpringBoot底层也是使用slf4jJ+logback</p></li><li><p>SpringBoot也把其他日志替换成了slf4j</p></li><li><p>起着commons.loggings的名字其实new的SLF4J替换中间包</p></li><li><p>如果要引入其他框架？一定要把这个框架的默认日志依赖移除掉</p></li></ol><h2 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h2><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><p>trace-debug-info-warn-error</p><p>可以调整需要的日志级别进行输出，不用注释语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录器</span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 日志的级别</span></span><br><span class="line">    <span class="comment">// 从低到高</span></span><br><span class="line">    <span class="comment">// 可以调整输出的日志级别；日志就只会在这个级别以后的高级别生效</span></span><br><span class="line">    logger.trace(<span class="string">"这是trace日志"</span>);</span><br><span class="line">    logger.debug(<span class="string">"这是debug信息"</span>);</span><br><span class="line">    <span class="comment">// SpringBoot默认给的是info级别，如果没指定就是默认的root级别</span></span><br><span class="line">    logger.info(<span class="string">"这是info日志"</span>);</span><br><span class="line">    logger.warn(<span class="string">"这是warn信息"</span>);</span><br><span class="line">    logger.error(<span class="string">"这是Error信息"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调整指定包的日志级别在配置文件中进行配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.com.gxk</span>=trace</span><br></pre></td></tr></table></figure><p>日志输出格式：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#控制台输出的日志格式 </span></span><br><span class="line"><span class="comment">#%d：日期</span></span><br><span class="line"><span class="comment">#%thread：线程号 </span></span><br><span class="line"><span class="comment">#%-5level：靠左 级别 </span></span><br><span class="line"><span class="comment">#%logger&#123;50&#125;：全类名50字符限制,否则按照句号分割</span></span><br><span class="line"><span class="comment">#%msg：消息+换行</span></span><br><span class="line"><span class="comment">#%n：换行</span></span><br><span class="line"><span class="attr">logging.pattern.console</span>=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-<span class="number">5</span>level %logger&#123;<span class="number">50</span>&#125; - %msg%n</span><br></pre></td></tr></table></figure><p>SpringBoot修改日志的默认配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.com.gxk</span>=trace</span><br><span class="line"><span class="comment">#不指定path就是当前目录下生成springboot.log</span></span><br><span class="line"><span class="comment">#logging.file=springboot.log</span></span><br><span class="line"><span class="comment">#当前磁盘下根路径创建spring文件中log文件夹，使用spring.log作为默认</span></span><br><span class="line"><span class="attr">logging.path</span>=/spring/log</span><br><span class="line"><span class="comment">#控制台输出的日志格式 日期 + 线程号 + 靠左 级别 +全类名50字符限制+消息+换行</span></span><br><span class="line"><span class="attr">logging.pattern.console</span>=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-<span class="number">5</span>level %logger&#123;<span class="number">50</span>&#125; - %msg%n</span><br><span class="line"><span class="comment">#指定文件中日志输出的格式</span></span><br><span class="line"><span class="attr">logging.pattern.file</span>=xxx</span><br></pre></td></tr></table></figure><h3 id="指定配置"><a href="#指定配置" class="headerlink" title="指定配置"></a>指定配置</h3><p>给类路径下放上每个日志框架自己的配置文件，SpringBoot就不会使用默认的配置</p><table><thead><tr><th>logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>,<code>logback-spring.groovy</code>,<code>logback.xml</code> or <code>logback.groovy</code></td></tr><tr><td>Log4J2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK(Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p><code>logback.xml</code>直接被logback日志框架识别 ，<code>logback-spring.xml</code>先由SpringBoot识别。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用参数 <code>--spring.profiles.active=dev</code>运行，即使用这段配置。</p><h3 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h3><ol><li><p>logback → log4j</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>切换为log4j2的starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Springboot入门&quot;&gt;&lt;a href=&quot;#Springboot入门&quot; class=&quot;headerlink&quot; title=&quot;Springboot入门&quot;&gt;&lt;/a&gt;Springboot入门&lt;/h1&gt;&lt;h2 id=&quot;SpringBoot简介&quot;&gt;&lt;a href=&quot;#S
      
    
    </summary>
    
      <category term="Java" scheme="https://GxkOrd.github.io/categories/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://GxkOrd.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>第7章 指令系统</title>
    <link href="https://GxkOrd.github.io/2019/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC7%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>https://GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/</id>
    <published>2019-06-17T06:24:00.000Z</published>
    <updated>2019-06-18T10:16:32.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h1><ul><li><p><strong>机器指令</strong>：每一条机器语言的语句。</p></li><li><p><strong>指令系统</strong>：全部机器指令的集合。</p></li></ul><blockquote><ul><li><p>指令的格式是什么</p><ul><li>指令码 地址码 寻址方式</li></ul></li><li><p>指令的字长</p><ul><li>固定长度、可变字长</li></ul></li></ul></blockquote><h2 id="指令的一般格式"><a href="#指令的一般格式" class="headerlink" title="指令的一般格式"></a>指令的一般格式</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/指令的一般格式.jpg" alt="指令的一般格式" title>                </div>                <div class="image-caption">指令的一般格式</div>            </figure><ol><li><p>操作码（反映机器做说明操作）</p><p>(1) <strong>长度固定</strong></p><p>用于指令字长较长的情况，<em>RISC</em></p><p>如 <em>IBM 370</em>，操作码八位</p><p>(2) <strong>长度可变</strong></p><p>操作码分散在指令字的不同字段中。</p><p>(3) <strong>扩展操作码技术</strong></p><p><strong>操作码的位数随地址数的减少而增加</strong></p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E4%B8%80%E7%A7%8D%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E7%9A%84%E5%AE%89%E6%8E%92%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="一种扩展操作码的安排示意图"></p><p>三地址指令操作码每减少一种最多可多构成$2^4$种二地址指令；</p><p>二地址指令操作码每减少一种最多可多构成$2^4$种一地址指令。</p><blockquote><p><strong>思考</strong>：若给定一个指令集，要求对指令集中的指令的操作码进行编码，哪些指令的操作码用长操作码表示，哪些指令的操作码用短操作码表示？</p><p><strong>答</strong>：一般在程序执行过程中，经常出现的高频指令可以用短操作码来表示，低频指令用长操作码表示。</p></blockquote></li><li><p>地址码</p><p>(1) <strong>四地址</strong></p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E5%9B%9B%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.jpg" alt="四地址指令"></p><p>$A_1$第一操作数地址</p><p>$A_2$第二操作数地址</p><p>$A_3$结果的地址</p><p>$A_4$下一条指令的地址</p><p>$(A_1)OP(A_2)→A_3$</p><p>设指令字长为32位，操作码固定为8位，4个地址字段各占6位，寻址范围为$2^6=64$。如果地址字段均指示内存的地址，则完成一条四地址指令，共需<strong>4次访存</strong>（取指令一次，取两个操作码两次，存放结果一次）。</p><blockquote><p>程序计数器PC既能存放当前欲执行的指令的地址，又有计数功能，因此它能自动形成下一条指令的地址。这样，指令字中的第四地址字段$A_4$便可省去，即得<strong>三地址指令</strong>格式。</p></blockquote><p>(2) <strong>三地址</strong></p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.jpg" alt="三地址指令"></p><p>$(A_1)OP(A_2)→A_3$</p><p><strong>4次访存</strong>，寻址范围$2^8=256$</p><blockquote><p>机器在运行过程中，没必要将每次运行结果都存入主存，中间结果可以暂时存放在CPU的寄存器（如ACC）中，这样又省去一个地址字段$A_3$，从而得出<strong>二地址指令</strong>。</p></blockquote><p>(3) <strong>二地址</strong></p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.jpg" alt="二地址指令"></p><p>$(A_1)OP(A_2)→A_1$ 或 $(A_1)OP(A_2)→A_2$：<strong>4次访存</strong></p><p>$(A_1)OP(A_2)→ACC$：<strong>3次访存</strong></p><p>寻址范围$2^{12}=4K$</p><blockquote><p>如果将一个操作数的地址隐含在运算器的ACC中，则指令字中只需给出一个地址码，构成<strong>一地址指令</strong>。</p></blockquote><p>(4) <strong>一地址</strong></p><p>$(ACC)OP(A_1)→ACC$</p><p><strong>2次访存</strong></p><p>寻址范围$2^{24}=16M$</p><p>(5) <strong>零地址</strong></p><p>在指令字中无地址码，例如，空地址（NOP）、停机（HLT）这类指令只有操作码。而子程序返回（RET）、中断返回（IRET）这类指令没有地址码，其操作数的地址隐含在堆栈指针SP中。</p></li></ol><h2 id="指令字长"><a href="#指令字长" class="headerlink" title="指令字长"></a>指令字长</h2><p>$$<br>指令字长决定于\begin{cases}操作码的长度\操作数地址的长度\操作数地址的个数\end{cases}<br>$$</p><ol><li><p>指令字长<strong>固定</strong></p><p>指令字长 = 存储字长</p></li><li><p>指令字长<strong>可变</strong></p><p>按字节的倍数变化</p></li></ol><h1 id="操作数类型和操作种类"><a href="#操作数类型和操作种类" class="headerlink" title="操作数类型和操作种类"></a>操作数类型和操作种类</h1><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><p>地址：无符号整数</p><p>数字：定点数、浮点数、十进制数</p><p>字符：ASCII</p><p>逻辑数：逻辑运算</p><h2 id="数据在存储器中的存放方式"><a href="#数据在存储器中的存放方式" class="headerlink" title="数据在存储器中的存放方式"></a>数据在存储器中的存放方式</h2><p><strong>例</strong>：12345678H的存放方式</p><p>(1) <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/大端、大尾方式.jpg" alt="大端、大尾方式" title>                </div>                <div class="image-caption">大端、大尾方式</div>            </figure></p><p>(2) <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/小端、小尾方式.jpg" alt="小端、小尾方式" title>                </div>                <div class="image-caption">小端、小尾方式</div>            </figure></p><p>字节编址，数据在存储器中的存放方式</p><ol><li><p>从任意位置开始存储</p><p> <img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E4%BB%8E%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E5%BC%80%E5%A7%8B%E5%AD%98%E5%82%A8.jpg" alt="从任意位置开始存储"></p><ul><li><p>优点：不浪费存储资源。</p></li><li><p>缺点：除了访问一个字节之外，访问其它任何类型的数据都可能花费两个存储周期的时间。读写控制比较复杂。</p></li></ul></li><li><p>从一个存储字的起始位置开始访问</p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E5%AD%97%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%BD%AE%E5%BC%80%E5%A7%8B%E8%AE%BF%E9%97%AE.jpg" alt="从一个存储字的起始位置开始访问"></p><ul><li><p>优点：无论访问何种类型的数据，在一个周期内均可完成，读写控制简单。</p></li><li><p>缺点：严重浪费存储资源。</p></li></ul></li><li><p>边界对准方式——从地址的整数倍位置开始访问</p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E8%BE%B9%E7%95%8C%E5%AF%B9%E5%87%86%E6%96%B9%E5%BC%8F.jpg" alt="边界对准方式"></p><p>数据存放的起始地址是数据长度（按照编址单位进行计算）的整数倍。</p><p>本方案是前两个方案的折衷，在一个周期内可以完成存储访问，空间浪费也不太严重。</p></li></ol><h2 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h2><ol><li>数据传输</li></ol><table><thead><tr><th>源</th><th>目的</th><th>例如</th></tr></thead><tbody><tr><td>寄存器</td><td>寄存器</td><td>MOVE</td></tr><tr><td>寄存器</td><td>存储器</td><td>STORE/MOVE/PUSH</td></tr><tr><td>存储器</td><td>寄存器</td><td>LOAD/MOVE/POP</td></tr><tr><td>存储器</td><td>存储器</td><td>MOVE</td></tr></tbody></table><ol start="2"><li><p>算术逻辑操作</p><p>加、减、乘、除、增1、减1、求补、浮点运算、十进制运算、与或、非、异或、位操作、位测试、位清除、位求反等。</p></li><li><p>移位操作</p><p>算术移位 逻辑移位 循环移位（带进位和不带进位）</p></li><li><p>转移</p><p>(1) 无条件转移 <strong>JMP</strong></p><p>(2) 条件转移</p><ul><li><p>结果为零转 (Z=1) <strong>JZ</strong></p></li><li><p>结果溢出转 (O=1) <strong>JO</strong></p></li><li><p>结果有进位转 (C=1) <strong>JC</strong></p></li><li><p>跳过一条指令 <strong>SKP</strong></p></li></ul><p>(3) 调用和返回</p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="调用和返回指令示意图"></p><p>(4) 陷阱（Trap）与陷阱指令</p><blockquote><p><strong>意外事故的中断</strong></p></blockquote><ul><li><p>一般不提供给用户直接使用</p><p>在出现事故时，由CPU自动产生并执行（隐指令）</p></li><li><p>设置供用户使用的陷阱指令</p></li></ul></li><li><p>输入输出</p><p>入：端口中的内容 → CPU的寄存器</p><p>出：CPU的寄存器 → 端口的内容</p></li></ol><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p><strong>寻址方式</strong>：确定<strong>本条指令</strong>的<strong>操作数地址</strong>以及<strong>下一条</strong>将要执行的<strong>指令</strong>的<strong>指令地址</strong>的方式，它与硬件结构紧密相关，而且直接影响指令格式和指令功能。</p><p>$$<br>寻址方式\begin{cases}指令寻址\数据寻址\end{cases}<br>$$</p><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><ul><li><p>顺序寻址</p><p>$(PC)+1→PC$</p></li><li><p>跳跃寻址</p><p>由转移指令指出</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/指令的寻址方式示意图.jpg" alt="指令的寻址方式示意图" title>                </div>                <div class="image-caption">指令的寻址方式示意图</div>            </figure><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/一种一地址指令的格式.jpg" alt="一种一地址指令的格式" title>                </div>                <div class="image-caption">一种一地址指令的格式</div>            </figure><p><strong>形式地址</strong>：指令字中的地址</p><p><strong>有效地址</strong>：操作数的真实地址</p><p>约定：<strong>指令字长 = 存储字长 = 机器字长</strong></p><ol><li><p>立即寻址</p><p><strong>形式地址A就是操作数</strong></p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80.jpg" alt="立即寻址示意图"></p><p>数据采用补码的形式存放。</p><ul><li><p><strong>指令执行阶段不访存</strong></p></li><li><p><strong>A的位数限制了立即数的范围</strong></p></li></ul></li><li><p>直接寻址</p><p>$EA=A$</p><p><strong>有效地址由形式地址直接给出</strong></p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.jpg" alt="直接寻址示意图"></p><ul><li><p><strong>执行阶段访问一次存储器</strong></p></li><li><p><strong>A的位数决定了该指令操作数的寻址范围</strong></p></li><li><p><strong>操作数的地址不易修改（必须修改A）</strong></p></li></ul></li><li><p>隐含寻址</p><p><strong>操作数地址隐含在操作码中</strong></p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80.jpg" alt="隐含寻址示意图"></p><ul><li><strong>指令字中少了一个地址字段，可缩短指令字长</strong></li></ul></li><li><p>间接寻址</p><p>$EA=(A)$ </p><p><strong>有效地址由形式地址间接提供</strong></p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.jpg" alt="间接寻址示意图"></p><ul><li><p><strong>执行指令阶段 2次访寻</strong></p></li><li><p><strong>可扩大寻址范围</strong></p></li><li><p><strong>便于编制程序</strong></p></li></ul></li><li><p>寄存器寻址</p><p>$EA=R_i$</p><p><strong>有效地址即为寄存器编号</strong></p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80.jpg" alt="寄存器寻址示意图"></p><ul><li><p><strong>执行阶段不访存，只访问寄存器，执行速度快</strong></p></li><li><p><strong>寄存器个数有限，可缩短指令字长</strong></p></li></ul></li><li><p>寄存器间接寻址</p><p>$EA=(R_i)$</p><p><strong>有效地址在寄存器中</strong></p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.jpg" alt="寄存器间接寻址示意图"></p><ul><li><p><strong>有效地址在寄存器中，操作数在存储器中，执行阶段访存1次</strong></p></li><li><p><strong>便于编写循环程序</strong></p></li></ul></li><li><p>基址寻址</p><p>(1) 采用专用寄存器作基址寄存器</p><p>$EA=(BR)+A$</p><p><strong>BR为基址寄存器</strong></p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80-%E4%B8%93%E7%94%A8%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8BR.jpg" alt="专用基址寄存器BR"></p><ul><li><p><strong>可扩大寻址范围</strong></p></li><li><p><strong>有利于多道程序</strong></p></li><li><p><strong>BR内容由操作系统或管理程序确定</strong></p></li><li><p><strong>在程序的执行过程中BR内容不变，形式地址A可变</strong></p></li></ul><p>(2) 采用通用寄存器作基址寄存器</p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt="通用寄存器作基址寄存器"></p><ul><li><p><strong>由用户指定哪个通用寄存器作为基址寄存器</strong></p></li><li><p><strong>基址寄存器的内容由操作系统确定</strong></p></li><li><p><strong>在程序的执行过程中$R_0$内容不变，形式地址A可变</strong></p></li></ul></li><li><p>变址寻址</p><p>$EA=(IX)+A$ </p><p><strong>IX为变址寄存器（专用）</strong></p><p><strong>通用寄存器也可以作为变址寄存器</strong></p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.jpg" alt="变址寻址示意图"></p><ul><li><p><strong>可扩大寻址范围</strong></p></li><li><p><strong>IX的内容由用户给定</strong></p></li><li><p><strong>在程序的执行过程中IX内容可变，形式地址A不变</strong></p></li><li><p><strong>便于处理数组问题</strong></p></li></ul></li><li><p>相对寻址</p><p>$EA=(PC)+A$</p><p>A是相对于当前指令的位移量（可正可负，补码）</p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.jpg" alt="相对寻址示意图"></p><ul><li><p><strong>A的位数决定操作数的寻址范围</strong></p></li><li><p><strong>程序浮动</strong></p></li><li><p><strong>广泛用于转移指令</strong></p></li></ul></li><li><p>堆栈寻址</p><p>(1) 堆栈的特点</p><p>$$<br>堆栈\begin{cases}硬堆栈\ \ 多个寄存器\软堆栈\ \ 指定的存储空间\end{cases}<br>$$</p><p><strong>先进后出</strong>（一个入出口）</p><p><strong>栈顶地址</strong>由<strong>SP</strong>指出</p><p>$进栈(SP)-1→SP$</p><p>$出栈(SP)+1→SP$</p><p>(2) 堆栈寻址举例</p><p><img src="//GxkOrd.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80%E4%B8%BE%E4%BE%8B.jpg" alt="堆栈寻址举例"></p><p>(3) SP的修改与主存编址方法有关</p><p>① 按<strong>字</strong>编址</p><p>$进栈(SP)-1→SP$</p><p>$进栈(SP)+1→SP$</p><p>② 按<strong>字节</strong>编址</p><ul><li><p>存储字长<strong>16</strong>位：</p><p>$进栈(SP)-2→SP$</p><p>$进栈(SP)+2→SP$</p></li><li><p>存储字长<strong>32</strong>位：</p><p>$进栈(SP)-4→SP$</p><p>$进栈(SP)+4→SP$</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器指令&quot;&gt;&lt;a href=&quot;#机器指令&quot; class=&quot;headerlink&quot; title=&quot;机器指令&quot;&gt;&lt;/a&gt;机器指令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;机器指令&lt;/strong&gt;：每一条机器语言的语句。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;s
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://GxkOrd.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成原理" scheme="https://GxkOrd.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第6章 计算机的运算方法</title>
    <link href="https://GxkOrd.github.io/2019/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC6%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <id>https://GxkOrd.github.io/2019/05/03/计算机基础/计算机组成原理/第6章 计算机的运算方法/</id>
    <published>2019-05-03T06:00:00.000Z</published>
    <updated>2019-06-27T10:59:05.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h1><h2 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h2><p>寄存器的位数反映无符号数的表示范围。</p><h2 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h2><h3 id="机器数与真值"><a href="#机器数与真值" class="headerlink" title="机器数与真值"></a>机器数与真值</h3><table><thead><tr><th>真值</th><th>机器数</th></tr></thead><tbody><tr><td>带符号的数</td><td>符号数字化的数</td></tr><tr><td><strong>+</strong>0.1011</td><td><strong>0</strong>.1011</td></tr><tr><td><strong>-</strong>0.1011</td><td><strong>1</strong>.1011</td></tr><tr><td><strong>+</strong>1100</td><td><strong>0</strong>,1100</td></tr><tr><td><strong>-</strong>1100</td><td><strong>1</strong>,1100</td></tr></tbody></table><h3 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h3><ol><li><p>定义</p><ul><li><p><strong>整数</strong></p><p>$[x]_原=\begin{cases}0,\ x\quad\quad2^n&gt;x\geq0\2^n-x\quad\quad0\geq x&gt;-2^n\end{cases}$</p><p>x为真值，n为整数的位数。</p><p><strong>使用逗号（,）将符号位与数值部分隔开。</strong></p><p>如：</p><ul><li><p>$x=+1110\quad[x]_原=0,1110$</p></li><li><p>$x=-1110\quad[x]_原=2^4+1110=1,1110$</p></li></ul></li><li><p><strong>小数</strong></p><p>$[x]_原=\begin{cases}x\quad\quad1&gt;x\geq0\1-x\quad\quad0\geq x&gt;-1\end{cases}$</p><p>x为真值。</p><p><strong>使用小数点（.）将符号位与数值部分隔开。</strong></p><p>如：</p><ul><li><p>$x=+0.1101\quad[x]_原=0.1101$</p></li><li><p>$x=-0.1101\quad[x]_原=1-(-0.1101)=1.1101$</p></li><li><p>$x=+0.1000000\quad[x]_原=0.1000000$</p></li></ul></li></ul><blockquote><p>特别地：</p><ul><li><p>当$x=0$时，</p><p>$[+0.0000]_原=0.0000$</p><p>$[-0.0000]_原=1-(0.0000)=1.0000$</p><p>可见，$[+0]_原\neq[-0]_原$，即原码中的“零”有两种表示形式</p></li><li><p>当$x=-1$时，</p><p>x不存在原码。（因为按照定义来看，-1和0地补码都为1）</p></li></ul></blockquote></li><li><p>特点</p><p>简单、直观。</p><p>但是用原码作加法时，会出现如下问题：</p></li></ol><table><thead><tr><th>要求</th><th>数1</th><th>数2</th><th>实际操作</th><th>结果符号</th></tr></thead><tbody><tr><td>加法</td><td>正</td><td>正</td><td><strong>加</strong></td><td>正</td></tr><tr><td>加法</td><td>正</td><td>负</td><td><strong>减</strong></td><td>可正可负</td></tr><tr><td>加法</td><td>负</td><td>正</td><td><strong>减</strong></td><td>可正可负</td></tr><tr><td>加法</td><td>负</td><td>负</td><td><strong>加</strong></td><td>负</td></tr></tbody></table><blockquote><p>能否<strong>只作加法</strong>？</p><p><strong>找到一个与负数等价的正数来代替这个负数</strong>，就可使<strong>减→加</strong>。（补码）</p></blockquote><h3 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h3><ol><li><p>补的概念</p><ul><li><p>一个负数加上<strong>“模”</strong>即得该负数的补数。</p></li><li><p>一个正数和一个负数互为补数时，它们的绝对值之和即为<strong>模</strong>数。</p></li></ul><blockquote><p>如<strong>计数器</strong>（模16），求$1011→0000$？</p><ul><li><p>$1011-1011=0000$</p></li><li><p>$1011+0101=(1)0000$（1超过表示范围，舍去）</p></li></ul><p>可见，-1011可用+0101代替。</p><p>记作：<strong>$-1011\equiv+0101\quad(mod\ 2^4)$</strong></p><p>同理：<strong>$-011\equiv+101\quad(mod\ 2^3)$</strong></p><p><strong>$-0.1001\equiv+1.01111\quad(mod\ 2)$</strong></p></blockquote></li><li><p>正数的补码即为其本身</p><p>两个互为补数的数，分别加上模，结果仍互为补数：</p><blockquote><p>例如：$-1011\equiv+0101\quad(mod\ 2^4)$</p><ul><li><p>$-1011+10000=+0101$</p></li><li><p>$+0101+10000=+(1)0101$</p></li></ul><p>所以，<strong>$+0101\equiv+0101\quad(mod\ 2^4)$</strong></p></blockquote><p>可见，<strong>+0101既可作+0101的补码，又可做-1011的补码</strong>。</p><p>为了区分，需要为补码添加其原码的符号位：</p><ul><li><p><strong>0</strong>,0101→<strong>+</strong>0101</p></li><li><p><strong>1</strong>,0101→<strong>-</strong>1011</p></li><li><p><strong>如何得到？</strong></p><p>只需增加一位模，即</p><p>$2^{4+1}-1011=100000-1011=1,0101$</p><p>$2^{4+1}+0101=100000+0101=(1)0,0101$</p></li></ul></li><li><p>补码的定义</p><ul><li><p>整数</p><p>$[x]_补=\begin{cases}0,\ x\quad\quad2^n&gt;x\geq0\2^{n+1}+x\quad\quad0&gt;x\geq-2^n\ (mod\ 2^{n+1})\end{cases}$</p><p>x为真值，n为整数的位数。</p><p>如：</p><ul><li><p>$x=+1010\quad[x]_补=0,1010$</p></li><li><p>$x=-1011000\quad[x]_补=2^{7+1}+(-1011000)$</p></li></ul></li><li><p>小数</p><p>$[x]_补=\begin{cases}x\quad\quad1&gt;x\geq 0\2+x\quad\quad0&gt;x\geq-1\ (mod\ 2)\end{cases}$</p><p>如：</p><ul><li><p>$x=+0.1110\quad[x]_补=0.1110$</p></li><li><p>$x=-0.1100000\quad[x]_补=2+(-0.1100000)=10.0000000-0.1100000=1.0100000$</p></li></ul></li></ul></li><li><p>求补码的快捷方式</p><p>设$x=-1010$，</p><p>则$[x]_补=2^{4+1}-1010=100000-1010=1,0110$</p><p>$=11111+1-1010=10101+1=1,0110$</p><p>又$[x]_原=1,1010$</p><p>当真值为<strong>负</strong>时，<strong>补码</strong>可用<strong>原码除符号位外每位取反，末位加1求得</strong>。</p></li><li><p>举例</p><ul><li><p>已知$[x]_补=0.0001$，求x</p><p>解：由定义得 $x=+0.0001$</p></li><li><p>已知$[x]_补=1.0001$，求x</p><p>解：方法(1)：由定义得 $x=[x]_补-2=1.0001-10.0000=-0.1111$</p><p>方法(2)：$[x]_原=1.1111,则x=-0.1111$</p></li><li><p>已知$[x]_补=1,1110，求x$</p><p>解：方法(1)：由定义得 $x=[x]_补-2^{4+1}=1,1110-100000=-0010$</p><p>方法(2)：$[x]_原=1,0010，则x=-0010$</p></li></ul><p>当真值为<strong>负</strong>时，<strong>原码</strong>可用<strong>补码除符号位外每位取反，末位加1求得</strong>。</p><blockquote><p>特别地：</p><ul><li><p>当$x=0$时，</p><p>$[+0.0000]_补=[-0.0000]_补=0.0000$</p></li><li><p>当$x=-1$时，</p><p>$[-1]_补=2+x=10.000-1.0000=1.0000$</p><p>（但无原码）</p></li></ul></blockquote></li></ol><h3 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h3><ol><li><p>定义</p><ul><li><p>整数</p><p>$[x]_反=\begin{cases} 0,x\quad 2^n&gt;x\geq0\\ (2^{n+1}-1)+x\quad 0\geq x&gt;-2^n(mod2^{n+1}-1)\end{cases}$</p><p>x为真值，n为整数的位数</p><p>如：</p><ul><li><p>$x=+1101\quad [x]_反=0,1101$</p></li><li><p>$x=-1101\quad [x]_反=(2^{4+1}-1)-1101=11111-1101=1,0010$</p></li></ul></li><li><p>小数</p><p>$[x]_反=\begin{cases} x\quad 1&gt;x\geq 0 \\ (2-2^{-n})+x\quad 0\geq x&gt;-1(mod\ 2-2^{-n})\end{cases}$</p><p>如：</p><ul><li><p>$x=+0.1101\quad[x]_反=0.1101$</p></li><li><p>$x=-0.1010\quad[x]_反=(2-2^{-4})-0.1010=1.1111-0.1010=1.0101$</p></li></ul></li></ul></li><li><p>举例</p><ul><li><p>已知$[x]_反=0,1110，求x$</p><p>解：$x=+1110$</p></li><li><p>已知$[x]_反=1,1110$，求x</p><p>解：$x=-0001$</p></li></ul><blockquote><p>特别地：</p><p>当$x=0$时，</p><p>设$x=+0.0000$，则$[+0.0000]_反=0.0000$</p><p>设$x=-0.0000$，则$[-0.0000]_反=1.1111$</p><p>同理，对于整数：$[+0]_反=0,0000$，$[-0]_反=1,1111$</p><p>因此，$[+0]_反\neq[-0]_反$</p></blockquote></li></ol><h3 id="三种机器数的小结"><a href="#三种机器数的小结" class="headerlink" title="三种机器数的小结"></a>三种机器数的小结</h3><ul><li><p><strong>最高位</strong>为<strong>符号位</strong>，书写上用“,”（整数）或“.”（小数）将数值部分和符号位隔开。</p></li><li><p>对于<strong>正数</strong>，<strong>原码=补码=反码</strong>。</p></li><li><p>对于<strong>负数</strong>，<strong>符号位为1</strong>，其<strong>数值部分</strong></p><p><strong>原码除符号位外每位取反末位加1 → 补码</strong></p><p><strong>原码除符号位外每位取反 → 反码</strong></p></li></ul><p><strong>例题1</strong>：设机器字长为8位（其中1位为符号位），对于正数，当其分别代表无符号数、原码、补码和反码时，对应的真值范围各为多少？</p><p><strong>解</strong>：</p><table><thead><tr><th>二进制代码</th><th>无符号数的对应真值</th><th>原码</th><th>补码</th><th>反码</th></tr></thead><tbody><tr><td>00000000</td><td>0</td><td>+0</td><td><strong>$\pm0$</strong></td><td>+0</td></tr><tr><td>00000001</td><td>1</td><td>+1</td><td>+1</td><td>+1</td></tr><tr><td>00000010</td><td>2</td><td>+2</td><td>+2</td><td>+2</td></tr><tr><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td></tr><tr><td>01111111</td><td>127</td><td>+127</td><td>+127</td><td>+127</td></tr><tr><td>10000000</td><td>128</td><td>-0</td><td><strong>-128</strong></td><td>-127</td></tr><tr><td>10000001</td><td>129</td><td>-1</td><td>-127</td><td>-126</td></tr><tr><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td></tr><tr><td>11111101</td><td>253</td><td>-125</td><td>-3</td><td>-2</td></tr><tr><td>11111110</td><td>254</td><td>-126</td><td>-2</td><td>-1</td></tr><tr><td>11111111</td><td>255</td><td>-127</td><td>-1</td><td>-0</td></tr></tbody></table><p><strong>例题2</strong>：已知$[y]_补$，求$[-y]_补$。</p><p><strong>解</strong>：设$[y]_补=y_0.y_1y_2\ldots y_n$</p><ul><li><p>若y为正数，$[y]_补=0.y_1y_2\ldots y_n$</p><p>则$y=0.y_1y_2\ldots y_n$</p><p>$-y=-0.y_1y_2\ldots y_n$</p><p>得$[-y]_补=1.\overline{y_1}\overline{y_2}\ldots\overline{y_n}+2^{-n}$</p><blockquote><p><strong>$[y]_补$连同符号位在内，每位取反，末位加1，即得$[-y]_补$。</strong></p></blockquote></li><li><p>若y为负数，$[y]_补=1.y_1y_2\ldots y_n$</p><p>则$[y]_原=1.\overline{y_1}\overline{y_2}\ldots \overline{y_n}+2^{-n}$</p><p>$y=-(0.\overline{y_1}\overline{y_2}\ldots \overline{y_n}+2^{-n})$</p><p>$-y=0.\overline{y_1}\overline{y_2}\ldots \overline{y_n}+2^{-n}$</p><p>$[-y]_补=0.\overline{y_1}\overline{y_2}\ldots\overline{y_n}+2^{-n}$</p><blockquote><p><strong>$[y]_补$连同符号位在内，每位取反，末位加1，即得$[-y]_补$。</strong></p></blockquote></li></ul><h3 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h3><p><strong>补码表示很难直接判断其真值大小。</strong></p><p>如：</p><table><thead><tr><th>十进制</th><th>二进制</th><th>补码</th></tr></thead><tbody><tr><td>+21</td><td>+10101</td><td>0,10101</td></tr><tr><td>-21</td><td>-10101</td><td>1,01011</td></tr><tr><td>+31</td><td>+11111</td><td>0,11111</td></tr><tr><td>-31</td><td>-11111</td><td>1,00001</td></tr></tbody></table><p>上述补码表示中“,”在计算机内部是不存在的，因此，从代码形式看，符号位也是一位二进制数。按这6位二进制代码比较大小的话，会得出$101011&gt;010101$，$100001&gt;011111$，其实恰恰相反。</p><p>如果每个真值加上一个$2^n$（n为整数的位数），则有：</p><p>$+10101+100000=110101$</p><p>$-10101+100000=001011$</p><p>$+11111+100000=111111$</p><p>$-11111+100000=000001$</p><ol><li><p>定义</p><p>$[x]_移=2^n+x(2^n&gt;x\geq-2^n)$</p><p>x为真值，n为整数的位数</p><p><img src="//GxkOrd.github.io/2019/05/03/计算机基础/计算机组成原理/第6章 计算机的运算方法/%E7%A7%BB%E7%A0%81%E5%9C%A8%E6%95%B0%E8%BD%B4%E4%B8%8A%E7%9A%84%E8%A1%A8%E7%A4%BA.jpg" alt="移码在数轴上的表示"></p><p>如：</p><ul><li><p>$x=10100$</p><p>$[x]_移=2^5+10100=1,10100$</p></li><li><p>$x=-10100$</p><p>$[x]_移=2^5-10100=0,01100$</p></li></ul></li><li><p>移码和补码的比较</p><ul><li><p>设 $x=+1100100$</p><p>$[x]_移=2^7+1100100=1,1100100$</p><p>$[x]_补=0,1100100$</p></li><li><p>设 $x=-1100100$</p><p>$[x]_移=2^7-1100100=0,0011100$</p><p>$[x]_补=1,0011100$</p></li></ul><p><strong>补码和移码只差一个符号位。</strong></p></li><li><p>真值、补码和移码的对照表</p><table><thead><tr><th>真值x(n=5)</th><th>$[x]_补$</th><th>$[x]_移$</th><th>$[x]_移对应的十进制整数$</th></tr></thead><tbody><tr><td><strong>-100000</strong></td><td>100000</td><td><strong>000000</strong></td><td>0</td></tr><tr><td>-11111</td><td>100001</td><td>000001</td><td>1</td></tr><tr><td>-11110</td><td>100010</td><td>000010</td><td>2</td></tr><tr><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td></tr><tr><td>-00001</td><td>111111</td><td>011111</td><td>31</td></tr><tr><td><strong>±00000</strong></td><td><strong>000000</strong></td><td><strong>100000</strong></td><td>32</td></tr><tr><td>+00001</td><td>000001</td><td>100001</td><td>33</td></tr><tr><td>+00010</td><td>000010</td><td>100010</td><td>34</td></tr><tr><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td></tr><tr><td>+11110</td><td>011110</td><td>111110</td><td>62</td></tr><tr><td><strong>+11111</strong></td><td>011111</td><td><strong>111111</strong></td><td>63</td></tr></tbody></table></li><li><p>移码的特点</p><ul><li><p>当x=0时</p><ul><li><p>$[+0]_移=2^5+0=1,00000$</p></li><li><p>$[-0]_移=2^5-0=1,00000$</p></li></ul><p>$[+0]_移=[-0]_移$</p></li><li><p>当n=5时</p><p>最小真值为$-2^5=-100000$</p><p>$[-100000]_移=2^5-100000=000000$</p><p>可见，<strong>最小真值的移位为全0</strong>。</p></li></ul></li></ol><h1 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h1><h2 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/05/03/计算机基础/计算机组成原理/第6章 计算机的运算方法/小数定点机.jpg" alt="小数定点机" title>                </div>                <div class="image-caption">小数定点机</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/05/03/计算机基础/计算机组成原理/第6章 计算机的运算方法/整数定点机.jpg" alt="整数定点机" title>                </div>                <div class="image-caption">整数定点机</div>            </figure><table><thead><tr><th>定点机</th><th>原码</th><th>补码</th><th>反码</th></tr></thead><tbody><tr><td>小数定点机</td><td>$-(1-2^{-n})$~$+(1-2^{-n})$</td><td>$-1$~$+(1-2^{-n})$</td><td>$-(1-2^{-n})$~$+(1-2^{-n})$</td></tr><tr><td>整数定点机</td><td>$-(2^n-1)$~$+(2^n-1)$</td><td>$-2^n$~$+(2^n-1)$</td><td>$-(2^n-1)$~$+(2^n-1)$</td></tr></tbody></table><h2 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h2><ul><li><p>为什么在计算机中要引入浮点数表示？</p><ul><li><p>编程困难，程序员要调节小数点的位置。</p></li><li><p>数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长。</p></li><li><p>数据存储单元的利用率往往很低。</p></li></ul></li><li><p>浮点表示的格式是什么？</p><p>浮点数的一般形式：$N=S×r^j$</p><p><strong>S</strong>：尾数</p><p><strong>j</strong>：阶码</p><p><strong>r</strong>：尾数的基值（计算机中<strong>r</strong>取<strong>2、4、8、16</strong>等）</p><ul><li><p>当$r=2$，</p><p>$N=11.0101=0.110101×2^{10}=1.10101×2^1=1101.01×2^{-10}$</p></li></ul><p>计算机中，<strong>S为小数、可正可负</strong>，<strong>j为整数、可正可负</strong>。</p></li><li><p>尾数和阶码的基值必须是2吗？基值的影响？</p></li><li><p>表数范围与精度和哪些因素有关？</p></li><li><p>为什么要引入规格化表示？</p></li><li><p>目前浮点数表示格式的标准是什么？</p></li></ul><h3 id="浮点数的表示形式"><a href="#浮点数的表示形式" class="headerlink" title="浮点数的表示形式"></a>浮点数的表示形式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/05/03/计算机基础/计算机组成原理/第6章 计算机的运算方法/浮点数的表示形式.jpg" alt="浮点数的表示形式" title>                </div>                <div class="image-caption">浮点数的表示形式</div>            </figure><h3 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h3><ul><li><p>上溢：阶码&gt;最大阶码</p></li><li><p>下溢：阶码&lt;最小阶码 按<strong>机器零</strong>处理</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/05/03/计算机基础/计算机组成原理/第6章 计算机的运算方法/浮点数在数轴上的表示范围.jpg" alt="浮点数在数轴上的表示范围" title>                </div>                <div class="image-caption">浮点数在数轴上的表示范围</div>            </figure><h3 id="浮点数的规格化形式"><a href="#浮点数的规格化形式" class="headerlink" title="浮点数的规格化形式"></a>浮点数的规格化形式</h3><p><strong>基数不同，浮点数的规格化形式不同。</strong></p><ul><li><p>r=2 尾数最高位为1</p></li><li><p>r=4 尾数最高2位不全为0</p></li><li><p>r=8 尾数最高3位不全为0</p></li></ul><h3 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h3><ul><li><p>r=2</p><ul><li><p>左规 尾数左移1位，阶码减1</p></li><li><p>右规 尾数右移1位，阶码加1</p></li></ul></li><li><p>r=4</p><ul><li><p>左规 尾数左移2位，阶码减1</p></li><li><p>右规 尾数右移2位，阶码加1</p></li></ul></li><li><p>r=8</p><ul><li><p>左规 尾数左移3位，阶码减1</p></li><li><p>右规 尾数右移3位，阶码加1</p></li></ul></li></ul><p><strong>基数r越大，可表示的浮点数的范围越大。</strong></p><p><strong>基数r越大，浮点数的精度越低。</strong></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h2 id="IEEE-754-标准"><a href="#IEEE-754-标准" class="headerlink" title="IEEE 754 标准"></a>IEEE 754 标准</h2><h1 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h1><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><h3 id="移位运算的数学意义"><a href="#移位运算的数学意义" class="headerlink" title="移位运算的数学意义"></a>移位运算的数学意义</h3><h3 id="算术移位规则"><a href="#算术移位规则" class="headerlink" title="算术移位规则"></a>算术移位规则</h3><h3 id="算术移位的硬件实现"><a href="#算术移位的硬件实现" class="headerlink" title="算术移位的硬件实现"></a>算术移位的硬件实现</h3><h3 id="算术移位与逻辑移位的区别"><a href="#算术移位与逻辑移位的区别" class="headerlink" title="算术移位与逻辑移位的区别"></a>算术移位与逻辑移位的区别</h3><h1 id="浮点四则运算"><a href="#浮点四则运算" class="headerlink" title="浮点四则运算"></a>浮点四则运算</h1><h1 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;无符号数和有符号数&quot;&gt;&lt;a href=&quot;#无符号数和有符号数&quot; class=&quot;headerlink&quot; title=&quot;无符号数和有符号数&quot;&gt;&lt;/a&gt;无符号数和有符号数&lt;/h1&gt;&lt;h2 id=&quot;无符号数&quot;&gt;&lt;a href=&quot;#无符号数&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://GxkOrd.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成原理" scheme="https://GxkOrd.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="二进制运算" scheme="https://GxkOrd.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>第5章 输入输出系统</title>
    <link href="https://GxkOrd.github.io/2019/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC5%E7%AB%A0%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/</id>
    <published>2019-04-18T07:05:00.000Z</published>
    <updated>2019-04-27T13:34:38.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="输入输出系统的发展概况"><a href="#输入输出系统的发展概况" class="headerlink" title="输入输出系统的发展概况"></a>输入输出系统的发展概况</h2><ol><li><p>早期</p><p>分散连接</p><p>CPU和I/0设备<strong>串行</strong>工作 程序查询方式</p></li><li><p>接口模块和DMA阶段</p><p>总线连接</p><p>CPU和I/O设备<strong>并行</strong>工作（中断方式、DMA方式）</p></li><li><p>具有通道结构的阶段</p></li><li><p>具有I/0处理机的阶段</p></li></ol><h2 id="输入输出系统的组成"><a href="#输入输出系统的组成" class="headerlink" title="输入输出系统的组成"></a>输入输出系统的组成</h2><ol><li><p>I/0软件</p><p>(1) I/O指令</p><ul><li>CPU指令的一部分</li></ul><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/IO%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%80%E8%88%AC%E6%A0%BC%E5%BC%8F.jpg" alt="I/O指令的一般格式"></p><p>(2) 通道指令</p><ul><li><p>通道自身的指令</p></li><li><p>指出数组的首地址、传送字数、操作命令</p></li></ul></li><li><p>I/0硬件</p><p>设备  I/O接口</p><p>设备  设备控制器  通道</p></li></ol><h2 id="I-0设备与主机的联系方式"><a href="#I-0设备与主机的联系方式" class="headerlink" title="I/0设备与主机的联系方式"></a>I/0设备与主机的联系方式</h2><ol><li><p>I/0设备编址方式</p><p>(1) 统一编址</p><ul><li>可以直接用取数、存数指令对I/O设备进行访问</li></ul><p>(2)  不统一编址</p><ul><li>有专门的I/O指令</li></ul></li><li><p>设备选址</p><p>用<strong>设备选择电路</strong>识别是否被选中</p></li><li><p>传送方式</p><p>(1) 串行</p><p>(2) 并行</p></li><li><p>联络方式</p><p>(1) 立即响应</p><p>(2) 异步工作采用应答信号</p><ul><li><p>并行</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/%E5%BC%82%E6%AD%A5%E5%B9%B6%E8%A1%8C%E5%BA%94%E7%AD%94%E8%81%94%E7%BB%9C%E6%96%B9%E5%BC%8F.jpg" alt="异步并行“应答”联络方式"></p></li><li><p>串行</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E8%81%94%E7%BB%9C%E6%96%B9%E5%BC%8F.jpg" alt="异步串行联络方式"></p></li></ul><p>(3) 同步工作采用同步时标</p></li><li><p>I/0设备与主机的连接方式</p><p>(1) 辐射式连接</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/IO%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%B8%BB%E6%9C%BA%E8%BF%9E%E6%8E%A5-%E8%BE%90%E5%B0%84%E5%BC%8F%E8%BF%9E%E6%8E%A5.jpg" alt="辐射式连接"></p><ul><li><p>每台设备都配有一套控制线路和一组信号线</p></li><li><p><strong>不便于增删设备</strong></p></li></ul><p>(2) 总线连接</p><ul><li><strong>便于增删设备</strong></li></ul></li></ol><h2 id="I-O设备与主机信息传送的控制方式"><a href="#I-O设备与主机信息传送的控制方式" class="headerlink" title="I/O设备与主机信息传送的控制方式"></a>I/O设备与主机信息传送的控制方式</h2><ol><li><p>程序查询方式</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%E6%B5%81%E7%A8%8B.jpg" alt="程序查询方式流程"></p><ul><li><p><strong>CPU和I/O串行工作</strong></p></li><li><p><strong>踏步等待</strong></p></li></ul></li><li><p>程序中断方式</p><p>倘若CPU在启动I/O设备后，不查询设备是否已准备就绪，继续执行自身程序，只是当I/O设备准备就绪并向CPU发出中断请求后才予以响应。</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F.jpg" alt="程序中断方式"></p><ul><li><p><strong>没有踏步等待现象</strong></p></li><li><p><strong>中断现行程序</strong></p></li></ul><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E6%B5%81%E7%A8%8B.jpg" alt="程序中断方式流程"></p></li><li><p>直接存储器存取方式（DMA）</p><p>主存和I/O之间有一条直接数据通道</p><p>不中断现行程序</p><p>周期挪用（周期窃用）</p><p><strong>CPU和I/O并行工作</strong></p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/DMA%E6%96%B9%E5%BC%8F.jpg" alt="DMA方式"></p></li><li><p>I/0通道方式</p></li><li><p>I/O处理机方式</p></li></ol><blockquote><p>4、5两种方式详解可以参照《计算机系统结构》的教材。</p></blockquote><ol start="6"><li><p>前三种方式的CPU工作效率比较</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84CPU%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83.jpg" alt="三种方式的CPU工作效率比较"></p></li></ol><h1 id="I-0设备（了解）"><a href="#I-0设备（了解）" class="headerlink" title="I/0设备（了解）"></a>I/0设备（了解）</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/IO设备结构框图.jpg" alt="I/O设备结构框图" title>                </div>                <div class="image-caption">I/O设备结构框图</div>            </figure><p>I/0设备大致分为三类：</p><ol><li><p>人机交互设备</p><p>键盘、鼠标、的研究、显示器</p></li><li><p>计算机信息存储设备</p><p>磁盘、光盘、磁带</p></li><li><p>机-机通信设备</p><p>调制解调器等</p></li></ol><h2 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h2><ol><li><p>键盘</p><p>按键</p><p>判断哪个键按下</p><p>将此键翻译成ASCII码（编码键盘法）</p></li><li><p>鼠标</p><p>机械式：金属球、电位器</p><p>光电式：光电转换器</p></li><li><p>触摸屏</p></li></ol><h2 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h2><ol><li><p>显示器</p><p>(1) 字符显示：字符发生器</p><p>(2) 图形显示：主观图像</p><p>(3) 图像显示：客观图像</p></li><li><p>打印机</p><p>(1) 击打式：点阵式（逐字、逐行）</p><p>(2) 非打击式：激光（逐页）、喷墨（逐页）</p></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>A/D、D/A</p><p>模拟/数字（数字/模拟）转换器。</p></li><li><p>终端</p><p>由键盘和显示器组成。</p><p>完成显示控制与存储、键盘管理及通信控制。</p></li><li><p>汉字处理</p><p>汉字输入、汉字存储、汉字输出。</p></li></ol><h2 id="多媒体技术"><a href="#多媒体技术" class="headerlink" title="多媒体技术"></a>多媒体技术</h2><ol><li><p>什么是多媒体？</p></li><li><p>多媒体计算机的关键技术？</p></li></ol><h1 id="I-0接口"><a href="#I-0接口" class="headerlink" title="I/0接口"></a>I/0接口</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>为什么设置接口？</p><ol><li><p>实现设备的选择</p></li><li><p>实现数据缓冲达到速度匹配</p></li><li><p>实现数据串-并格式转换</p></li><li><p>实现电平转换</p></li><li><p>传送控制命令</p></li><li><p>反应设备的状态（“忙”、“就绪”、“错误”、“中断请求”）</p></li></ol><h2 id="接口的功能和组成"><a href="#接口的功能和组成" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h2><ol><li><p>总线连接方式的I/O接口电路</p><p>(1) 设备选择线</p><p>(2) 数据线</p><p>(3) 命令线</p><p>(4) 状态线</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/IO%E6%80%BB%E7%BA%BF%E5%92%8C%E6%8E%A5%E5%8F%A3%E9%83%A8%E4%BB%B6.jpg" alt="I/O总线和接口部件"></p></li><li><p>接口的功能和组成</p></li></ol><table><thead><tr><th>功能</th><th>组成</th></tr></thead><tbody><tr><td>选址功能</td><td>设备选择电路</td></tr><tr><td>传送命令的功能</td><td>命令寄存器、命令译码器</td></tr><tr><td>传送数据的功能</td><td>数据缓冲寄存器</td></tr><tr><td>反映设备状态的功能</td><td>设备状态标记</td></tr></tbody></table><p>$$<br>\begin{cases}完成触发器D\工作触发器B\中断请求触发器INTR\屏蔽触发器MASK\end{cases}.<br>$$</p><ol start="3"><li><p>I/O接口的基本组成</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/IO%E8%AE%BE%E5%A4%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.jpg" alt="I/O设备的基本组成"></p></li></ol><h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><ol><li><p>按数据<strong>传送方式</strong>分类</p><p>并行接口（Intel 8255）</p><p>串行接口（Intel 8251）</p></li><li><p>按功能<strong>选择的灵活性</strong>分类</p><p>可编程接口（Intel 8255、Intel 8251）</p><p>不可编程接口（Intel 8212）</p></li><li><p>按<strong>通用性</strong>分类</p><p>通用接口（Intel 8255、Intel 8251）</p><p>专用接口（Intel 8279、Intel 8275）</p></li><li><p>按数据传送的<strong>控制方式</strong>分类</p><p>程序型接口</p><p>DMA型接口</p></li></ol><h1 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h1><h2 id="程序查询方式的流程"><a href="#程序查询方式的流程" class="headerlink" title="程序查询方式的流程"></a>程序查询方式的流程</h2><ol><li><p>查询流程</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/IO%E8%AE%BE%E5%A4%87%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.jpg" alt="IO设备的查询流程"></p></li><li><p>程序流程</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B.jpg" alt="程序查询方式的程序流程"></p></li></ol><h2 id="程序查询方式的接口电路"><a href="#程序查询方式的接口电路" class="headerlink" title="程序查询方式的接口电路"></a>程序查询方式的接口电路</h2><ol><li><p>输入</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90-%E8%BE%93%E5%85%A5.jpg" alt="程序查询方式接口电路的基本组成-输入"></p><p>① 当CPU通过I/O指令启动输入设备时，指令的设备码字段通过地址线送至设备选择电路。</p><p>② 若该接口的设备码与地址线上的代码吻合，其输出SEL有效。</p><p>③ I/O指令的启动命令经过“与非”门将工作触发器B置为1，将完成触发器D置为0。</p><p>④ 由B触发器启动设备工作。</p><p>⑤ 输入设备将数据送至数据缓冲寄存器（DBR）中。</p><p>⑥ 由设备发设备工作结束信号，将D置“1”，B置“0”，表示外设准备就绪。</p><p>⑦ D触发器以“准备就绪”状态通知CPU，表示“数据缓冲满”。</p><p>⑧ CPU执行输入指令，将DBR中的数据送至CPU的通用寄存器，再存入主存相关单元。</p></li><li><p>输出</p><p>① 当CPU通过I/O指令启动输出设备时，指令的设备码字段通过地址线送至设备选择电路。</p><p>② 若该接口的设备码与地址线上的代码吻合，其输出SEL有效。</p><p>③ I/O指令的启动命令经过“与非”门将工作触发器B置为1，将完成触发器D置为0。</p><p>④ CPU通过输出指令将数据送至数据缓冲 寄存器（DBR）中。</p><p>⑤ 由B触发器启动设备工作，将数据从DBR中取走。</p><p>⑥ 由设备发设备工作结束信号，将D置“1”，B置“0”，表示外设输出完成。</p><p>⑦ D触发器以“准备就绪”状态通知CPU，表示“数据缓冲空”。</p><p>⑧ CPU可再次向DBR输出数据，进行第二次传送。</p></li></ol><h1 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h1><h2 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a>中断的概念</h2><p>计算机在执行程序的过程中，当出现异常情况或特殊情况时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回现行程序的间断处，继续执行原程序，这就是“中断”。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/程序中断方式.jpg" alt="程序中断方式" title>                </div>                <div class="image-caption">程序中断方式</div>            </figure><p>计算机系统引入中断技术的原因：</p><ol><li><p>为了提高计算机的整机效率。</p></li><li><p>为了应对突发事件。</p><blockquote><p>例如，当计算机运行过程中，若出现突然掉电这种异常情况，将会导致CPU中的全部信息丢失。倘若在突然掉电的瞬间立即启动另一个备份电源，并迅速进行一些必要的处理，例如，将有用的信息送至不受电源影响的存储系统内，待电源恢复后接着使用，这种处理技术也要用中断技术来实现。</p></blockquote></li><li><p>为了实时控制的需要。</p><blockquote><p>在实时控制领域中，要求CPU能即时响应外来信号的请求，并能完成相应的操作，也都要求采用中断技术。</p></blockquote></li></ol><h2 id="中断的产生"><a href="#中断的产生" class="headerlink" title="中断的产生"></a>中断的产生</h2><p>以打印机为例</p><p><strong>CPU与打印机部分并行工作</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/CPU与打印机并行工作的时间示意图.jpg" alt="CPU与打印机并行工作的时间示意图" title>                </div>                <div class="image-caption">CPU与打印机并行工作的时间示意图</div>            </figure><h2 id="程序中断方式的接口电路"><a href="#程序中断方式的接口电路" class="headerlink" title="程序中断方式的接口电路"></a>程序中断方式的接口电路</h2><ol><li><p>配置中断请求触发器和中断屏蔽触发器</p><p>INTR：中断请求触发器（INTR=1表示有请求）</p><p>MASK：中断屏蔽触发器（MASK=1表示被屏蔽）</p><p>D：完成触发器</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF%E4%B8%ADD%E3%80%81INTR%E3%80%81MASK%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9F%A5%E8%AF%A2%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="接口电路中D、INTR、MASK和中断查询信号的关系"></p><blockquote><p>&amp;：与非门，其运算为$\overline{A\cdot B}$。</p><p>1：非门，其运算为$\overline{A}$，相当于$\overline{A\cdot 1}$。</p><p>&amp;和1：效果相当于与门，但由于电路的原因，只能使用与非门。</p></blockquote></li><li><p>排队器</p></li></ol><p>$$<br>排队\begin{cases} 硬件\ \ 在CPU内或在接口电路中（链式排队器） \ 软件\ \ 详见第八章\end{cases}<br>$$</p><p>   <img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/%E9%93%BE%E5%BC%8F%E6%8E%92%E9%98%9F%E5%99%A8.jpg" alt="链式排队器"></p><p>   设备1、2、3、4的优先级按<strong>降序排列</strong></p><p>   $INTR_i=1$有请求，即$\overline{INTR_i}=0$</p><blockquote><p>第一个反相器左侧接地（恒为0），经过反向器，信号变为1，</p><p>若${INTR_1}$有请求，即$INTR_1=1$，经过上方的<strong>与非门</strong>和<strong>非门</strong>，选中1号设备；</p><p>若${INTR_1}$无请求，即$\overline{INTR_1}=1$，经过<strong>与非门</strong>，将1信号传到下一个排队器。</p><p>依此类推…</p></blockquote><ol start="3"><li>中断向量地址形成部件</li></ol><p>$$<br>入口地址\begin{cases} 由软件产生\ \ 详见第八章 \ 硬件向量法\ \ 由硬件产生向量地址，再由向量地址找到入口地址\end{cases}<br>$$</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/中断向量地址形成部件框图.jpg" alt="中断向量地址形成部件框图" title>                </div>                <div class="image-caption">中断向量地址形成部件框图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/通过向量地址寻找入口地址.jpg" alt="通过向量地址寻找入口地址" title>                </div>                <div class="image-caption">通过向量地址寻找入口地址</div>            </figure><ol start="4"><li><p>程序中断方式接口电路的基本组成</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.jpg" alt="程序中断方式接口电路的基本组成"></p></li></ol><h2 id="I-O中断处理过程"><a href="#I-O中断处理过程" class="headerlink" title="I/O中断处理过程"></a>I/O中断处理过程</h2><ol><li><p>CPU响应中断的条件和时间</p><ul><li><p>条件</p><p>允许中断触发器<strong>EINT=1</strong></p><p>用<strong>开中断</strong>指令将EINT置“<strong>1</strong>”</p><p>用<strong>关中断</strong>指令将EINT置“<strong>0</strong>”或硬件<strong>自动复位</strong></p></li><li><p>时间</p><p>当D = <strong>1</strong>（随机）且MASK = <strong>0</strong>时</p><p><strong>在每条指令执行阶段的结束前</strong></p><p><strong>CPU</strong>发<strong>中断查询信号</strong>（将INTR置“<strong>1</strong>”）</p></li></ul></li><li><p>I/O中断处理过程</p><p><img src="//GxkOrd.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/IO%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.jpg" alt="I/O中断处理过程"></p><p>① 由CPU发启动I/O设备的命令，将I/O接口中的B置“1”，D触发器置”0“。</p><p>② 接口启动输入设备开始工作。</p><p>③ 输入设备将数据送入数据缓冲寄存器。</p><p>④ 输入设备向接口发出”设备工作结束“信号，将D置”1“，B置”0“，标志设备准备就绪。</p><p>⑤ 当设备准备就绪（D=1），且本设备未被屏蔽（MASK=0）时，在指令执行阶段的结束时刻，由CPU发出中断查询信号。</p><p>⑥ 设备中断请求触发器INTR被置”1“，标志设备向CPU提出<strong>中断请求</strong>。与此同时，INTR送至排队器，进行<strong>中断判优</strong>。</p><p>⑦ 若CPU允许中断（EINT=1），设备又被排队选中，即进入<strong>中断响应</strong>阶段，由中断响应信号INTA将排队器输出送至编码器形成向量地址。</p><p>⑧ 向量地址送至PC，作为下一条指令的地址。</p><p>⑨ 由于向量地址中存放的是一条无条件转移指令，故这条指令执行结束后，即无条件转至该设备的服务程序入口地址，开始执行中断服务程序，进入<strong>中断服务</strong>阶段，通过输入指令将数据缓冲寄存器的输入数据送至CPU的通用寄存器，再存入主存相关单元。</p><p>⑩ 中断服务程序的最后一条指令是中断返回指令，当其执行结束时，<strong>中断返回</strong>至原程序的断点处。至此，一个完整的程序中断处理过程即告结束。</p><p><strong>综上所述，可将异常中断处理过程简单归纳为中断请求、中断判优、中断响应、中断服务和中断返回5个阶段。</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;输入输出系统的发展概况&quot;&gt;&lt;a href=&quot;#输入输出系统的发展概况&quot; class=&quot;headerlink&quot; title=&quot;输入输
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://GxkOrd.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成原理" scheme="https://GxkOrd.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>1. Spring入门</title>
    <link href="https://GxkOrd.github.io/2019/03/27/Java/Spring/1.%20Spring%E5%85%A5%E9%97%A8/"/>
    <id>https://GxkOrd.github.io/2019/03/27/Java/Spring/1. Spring入门/</id>
    <published>2019-03-27T05:05:00.000Z</published>
    <updated>2019-04-29T06:12:05.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h2><p>Spring是分层的java SE/EE 应用一站式的<strong>轻量级</strong>开源框架，以 IoC（Inverse of Control，控制反转）和 AOP（Aspect Oriented Programming，切面编程）为内核，提供了展示层Spring MVC、持久层Spring JDBC及业务层事务管理等一站式的企业级应用技术。</p><h2 id="Spring之父"><a href="#Spring之父" class="headerlink" title="Spring之父"></a>Spring之父</h2><p><strong>Rod Johnson</strong></p><ul><li><p>一个技术和商业上的天才。Spring的缔造者。</p></li><li><p>2004年3月24日发布了Spring1.0正式版并成立了SpringSource公司。</p></li></ul><h2 id="Spring优点"><a href="#Spring优点" class="headerlink" title="Spring优点"></a>Spring优点</h2><ol><li><p>方便解耦，简化开发。</p><p>通过Spring的IoC容器，用户可以将对象之间的依赖关系交由Spring进行控制，避免硬解码所造成的过度程序耦合。</p></li><li><p>AOP编程的支持。</p><p>通过Spring提供的AOP功能，方便进行面向切面的编程。</p></li><li><p>声明式事务的支持。</p><p>通过声明的方式灵活地管理事务。</p></li><li><p>方便进行程序测试。</p><p>可以用非容器依赖的编程方式进行几乎所有的测试工作。</p></li><li><p>方便集成各种优秀的框架。</p><p>Spring对其他框架不排斥。更可以降低各种框架的使用难度。它提供了对各种优秀框架的直接支持。（如：Struts、Hibernate、Hessian、Quartz等）</p></li><li><p>降低了Java EE API的使用难度。</p><p>Spring对很多难用的Java EE API（如JDBC、JavaMail、远程调用等）提供了薄层封装，大大降低了这些API的使用难度。</p></li><li><p>Spring源码是经典的学习范例。</p><p>对Spring源码的学习无疑是Java技术的最佳实践范例。</p></li></ol><h2 id="Spring体系结构"><a href="#Spring体系结构" class="headerlink" title="Spring体系结构"></a>Spring体系结构</h2><p>Spring核心框架由4000多个类组成，整个框架按其所属功能可以划分为5个模块，如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/03/27/Java/Spring/1. Spring入门/Spring框架结构.png" alt="Spring框架结构" title>                </div>                <div class="image-caption">Spring框架结构</div>            </figure><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><ol><li><p>创建一个JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用了无参构造器..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello:"</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Spring配置文件中注册bean</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans</span><br><span class="line">    xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:p=<span class="string">"http://www.springframework.org/schema/p"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans-4.1.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置Bean --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"helloWorld"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.gxk.spring.beans.HelloWorld"</span>&gt;</span><br><span class="line">        &lt;property name="name" value="Spring"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>获取对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 传统方法创建对象 */</span></span><br><span class="line">HelloWorld helloWorld1 = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">helloWorld1.setName(<span class="string">"simple"</span>);</span><br><span class="line">helloWorld1.hello();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Spring方法 */</span></span><br><span class="line"><span class="comment">// 1.创建Spring的IoC容器</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">// 2.获得xml里的对象（xml解析，反射创建对象）</span></span><br><span class="line">HelloWorld helloWorld2 = (HelloWorld) ctx.getBean(<span class="string">"helloWorld"</span>);</span><br><span class="line"><span class="comment">// 3.调用对象的方法</span></span><br><span class="line">helloWorld2.hello();</span><br></pre></td></tr></table></figure></li></ol><h1 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h1><h2 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans ...&gt;</span><br><span class="line">    &lt;!-- </span><br><span class="line">        配置Bean：</span><br><span class="line">            class：bean的全类名，通过反射的方法在IoC容器中创建对象，所以javabean中必须有无参构造器。</span><br><span class="line">            id：bean的唯一标识。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;bean id=&quot;helloWorld&quot; class=&quot;cn.gxk.spring.beans.HelloWorld&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="IoC容器的实现"><a href="#IoC容器的实现" class="headerlink" title="IoC容器的实现"></a>IoC容器的实现</h2><ul><li><p>BeanFactory：IoC容器的基本实现。（一般不用）</p></li><li><p>ApplicationContext：提供了更多高级的特性，是BeanFactory的子类。</p><ul><li><p>ConfigurableApplicationContext：扩展refresh()和close()，让ApplicationContext具有启动、刷新和关闭上下文的能力。</p><ul><li><p>ClassPathXmlApplicationContext：从类路径下加载配置文件。</p></li><li><p>FileSystemXmlApplicationContext：从文件系统中加载配置文件。</p></li></ul></li></ul></li><li><p>常用方法：</p><ul><li><p>getBean(String)</p><p>通过xml中配置的id来创建唯一对象。</p></li><li><p>getBean(类名.class)</p><p>利用类型返回bean，但要求IoC中只有一个该类型的bean。</p></li></ul></li></ul><h2 id="bean注入方法"><a href="#bean注入方法" class="headerlink" title="bean注入方法"></a>bean注入方法</h2><ul><li><p>属性注入（setter方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt;</span><br></pre></td></tr></table></figure></li><li><p>构造器注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor-arg value=&quot;v1&quot; index=&quot;0&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg index=&quot;1&quot; type=&quot;int&quot;&gt;</span><br><span class="line">    &lt;value&gt;100&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    index、type可以不写。</span><br><span class="line">    type用来区分重载的构造器。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li><li><p>工厂方法注入（很少使用，不推荐）</p></li></ul><h2 id="特殊的赋值"><a href="#特殊的赋值" class="headerlink" title="特殊的赋值"></a>特殊的赋值</h2><ul><li><p>特殊字符（使用&lt;!CDATA[]]&gt;包裹）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;address&quot;&gt;</span><br><span class="line">    &lt;value&gt;&lt;!CDATA[&lt;hello&gt;]&gt;&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></li><li><p>null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor-arg type=&quot;java.lang.String&quot;&gt;</span><br><span class="line">    &lt;null/&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br></pre></td></tr></table></figure></li><li><p>内部bean或外部bean</p><ul><li><p>内部bean，不能被外部引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;person&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;person1&quot; class=&quot;包名.Person&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></li><li><p>外部bean，用ref引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;person2&quot; class=&quot;包名.Person&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;property name=&quot;person&quot; ref=&quot;person2&quot;&gt;&lt;/property&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>集合</p><blockquote><p>java.util.List - &lt;list&gt;</p><p>java.util.Set - &lt;set&gt;</p></blockquote><ul><li><p>内部集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor-arg&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;ref bean=&quot;person1&quot;/&gt;</span><br><span class="line">        &lt;ref bean=&quot;person2&quot;/&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br></pre></td></tr></table></figure></li><li><p>外部集合</p><blockquote><p>需要在spring配置文件中引入util命名空间。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;util:list id=&quot;persons&quot;&gt;</span><br><span class="line">    &lt;ref bean=&quot;person1&quot;/&gt;</span><br><span class="line">    &lt;ref bean=&quot;person2&quot;/&gt;</span><br><span class="line">&lt;/util:list&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Map</p><blockquote><p>java.util.Map - &lt;map&gt;</p><p>java.util.Properties - &lt;prop&gt;</p></blockquote><ul><li><p>内部Map</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor-arg  type=&quot;java.util.Map&quot;&gt;</span><br><span class="line">    &lt;map&gt;</span><br><span class="line">        &lt;entry key=&quot;aa&quot; value-ref=&quot;person1&quot;&gt;&lt;/entry&gt;</span><br><span class="line">        &lt;entry key=&quot;bb&quot; value-ref=&quot;person2&quot;&gt;&lt;/entry&gt;</span><br><span class="line">    &lt;/map&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br></pre></td></tr></table></figure></li><li><p>外部Map</p><blockquote><p>需要在spring配置文件中引入util命名空间。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;util:map id=&quot;persons&quot;&gt;</span><br><span class="line">    &lt;entry key=&quot;aa&quot; value-ref=&quot;person1&quot;&gt;&lt;/entry&gt;</span><br><span class="line">    &lt;entry key=&quot;bb&quot; value-ref=&quot;person2&quot;&gt;&lt;/entry&gt;</span><br><span class="line">&lt;/util:map&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="使用p命名空间赋值"><a href="#使用p命名空间赋值" class="headerlink" title="使用p命名空间赋值"></a>使用p命名空间赋值</h2><blockquote><p>在spring配置文件中引入p命名空间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;person3&quot; class=&quot;包名.person&quot; p:name=&quot;zhangsan&quot; p:age=&quot;30&quot; p:cars-ref=&quot;cars&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="自动装配（了解，一般不用）"><a href="#自动装配（了解，一般不用）" class="headerlink" title="自动装配（了解，一般不用）"></a>自动装配（了解，一般不用）</h2><ol><li><p>byName</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;car&quot; class=&quot;包名.Car&quot; ...&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;person4&quot; class=&quot;包名.Person&quot; p:name=&quot;zhangsan&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    若person有car属性，设置autowire=&quot;byName&quot;，IoC容器会自动寻找叫&quot;car&quot;的bean，自动装配。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li><li><p>byType</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;car1&quot; class=&quot;包名.car&quot; ...&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;person4&quot; class=&quot;包名.person&quot; p:name=&quot;zhangsan&quot;  autowire=&quot;byType&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    若person有car属性，设置autowire=&quot;byType&quot;，会寻找类car的bean，自动装配（若car有多个bean，会抛异常）</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="bean之间的关系"><a href="#bean之间的关系" class="headerlink" title="bean之间的关系"></a>bean之间的关系</h2><ol><li><p>继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;address&quot; p:city=&quot;BeiJing&quot; abstract=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;address2&quot; class=&quot;包名.Address&quot; p:street=&quot;DaZhongShi&quot; parent=&quot;address1&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li><p>先给给出的属性赋值，未给出的属性继承父bean。</p></li><li><p>设置了abstract=”true”的bean为抽象bean，不能将它实例化，只用于继承。（该抽象bean可以不指定class）</p></li></ul></li><li><p>依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;person1&quot; p:age=&quot;23&quot; depends-on=&quot;name&quot;/&gt;</span><br></pre></td></tr></table></figure><p>depends-on=”name”指定了依赖属性，而name未赋值，会抛异常。</p></li></ol><h2 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;car&quot; class=&quot;包名.car&quot; scope=&quot;?&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    singleton：默认值，单例的，容器初始化时创建bean对象，在整个容器的生命周期中只有这一个对象。</span><br><span class="line"></span><br><span class="line">    prototype：原型的，每次getBean都会创建一个对象。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><h2 id="外部属性文件（可用于配置数据库连接等）"><a href="#外部属性文件（可用于配置数据库连接等）" class="headerlink" title="外部属性文件（可用于配置数据库连接等）"></a>外部属性文件（可用于配置数据库连接等）</h2><ol><li><p>新建属性文件person.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pname</span>=<span class="string">zhangsan</span></span><br><span class="line"><span class="attr">page</span>=<span class="string">20</span></span><br></pre></td></tr></table></figure></li><li><p>引入属性文件</p><ul><li><p>Spring2.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;包名.person&quot;&gt;</span><br><span class="line">&lt;property name=&quot;location&quot; value=&quot;classpath:person.properties&quot;&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>Spring2.5以后</p><blockquote><p>需要在spring配置文件中引入context工作空间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-paceholder location=&quot;classpath:person.properties&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;person&quot; class=&quot;包名.person&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;$&#123;pname&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;$&#123;page&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Spring表达式语言-Spring-EL"><a href="#Spring表达式语言-Spring-EL" class="headerlink" title="Spring表达式语言(Spring EL)"></a>Spring表达式语言(Spring EL)</h2><ul><li><p>一个支持运行时查询和操作对象图的表达式语言。</p></li><li><p>使用#{…}作为定界符。</p></li><li><p>为动态赋值提供了便利。</p></li><li><p>用法：</p><ul><li><p>字面值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;ZhangSan&apos;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用bean、属性和方法</p><ul><li><p>引用其他bean对象（等同ref属性）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;car&quot; value=&quot;#&#123;car1&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用其他对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;car_price&quot; value=&quot;#&#123;car1.price&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>调用其他方法，还可以链式操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;person&quot; value=&quot;#&#123;person1.toString().toUpperCase()&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>静态方法或属性，通过T()调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;initValue&quot; value=&quot;#&#123;T(java.lang.Math).PI&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>运算符</p><ul><li><p>算数运算符：+, -, *, /, &amp;, ^</p></li><li><p>加号进行字符串连接</p></li><li><p>比较运算符：&lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge</p></li><li><p>逻辑运算符：and, or, not, |</p></li><li><p>if-else运算：</p><ul><li><p>a&gt;b ?: (result1), a&lt;=b ?: (result2)</p></li><li><p>a&gt;b ? ‘reslut1’ : ‘result2‘</p></li></ul></li><li><p>正则表达式</p></li></ul></li></ul></li></ul><h2 id="管理bean的生命周期"><a href="#管理bean的生命周期" class="headerlink" title="管理bean的生命周期"></a>管理bean的生命周期</h2><ul><li><p>Spring IoC容器可以管理Bean的生命周期，并允许在Bean生命周期的特殊点执行相关方法。</p></li><li><p>Spring IoC容器对Bean的生命周期进行管理的过程：</p><ol><li><p>通过构造器或工厂方法创建Bean实例</p></li><li><p>为Bean的属性设值和对其他Bean的引用</p></li><li><p><strong>调用Bean的初始化方法</strong></p></li><li><p>使用Bean</p></li><li><p><strong>容器关闭时，调用bean的销毁方法</strong></p></li></ol></li><li><p>在Bean的声明里设置 init-method 和 destory-method 属性，为bean指定初始化和销毁方法。</p></li><li><p>Bean的后置处理器</p><ul><li><p>创建MyBeanPostProcessor类实现BeanPostProcessor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两方法的返回值是用户拿到的bean（可以在这两个方法里对创建的bean进行处理）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean初始化（init-method）前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">PostProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean初始化（init-method）后调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">PostProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在xml里配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;包名.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用工厂方法创建bean"><a href="#使用工厂方法创建bean" class="headerlink" title="使用工厂方法创建bean"></a>使用工厂方法创建bean</h2><ul><li><p>使用静态工厂方法</p><ul><li><p>创建工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCarFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> map&lt;String,Car&gt; cars = nw HashMap&lt;String,Car&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cars.put(<span class="string">"audi"</span>, <span class="keyword">new</span> Car(<span class="string">"audi"</span>));</span><br><span class="line">        cars.put(<span class="string">"ford"</span>, <span class="keyword">new</span> Car(<span class="string">"ford"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cars.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在applictionContext.xml里配置bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;car1&quot; class=&quot;包名.StaticCarFactory&quot; factory-method=&quot;getCar&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;audi&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用实例工厂方法</p><ul><li><p>创建工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceCarFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Car&gt; cars = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceCarFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cars = <span class="keyword">new</span> HashMap&lt;String,Car&gt;();</span><br><span class="line">        cars.put(<span class="string">"audi"</span>, <span class="keyword">new</span> Car(<span class="string">"audi"</span>));</span><br><span class="line">        cars.put(<span class="string">"ford"</span>, <span class="keyword">new</span> Car(<span class="string">"ford"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cars.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在applictionContext.xml里配置bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;carFactory&quot; class=&quot;包名.InstanceCarFactory&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;car2&quot; factory-bean=&quot;carFactory&quot; factory-method=&quot;getCar&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;ford&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用FactoryBean配置bean"><a href="#使用FactoryBean配置bean" class="headerlink" title="使用FactoryBean配置bean"></a>使用FactoryBean配置bean</h2><ul><li><p>创建CarFactoryBean实现FactoryBean接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Car<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在applictionContext.xml里配置bean</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;car1&quot; class=&quot;包名.CarFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;BMW&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="基于注解方式配置Bean"><a href="#基于注解方式配置Bean" class="headerlink" title="基于注解方式配置Bean"></a>基于注解方式配置Bean</h2><ul><li><p>组件扫描(component scanning)</p><p>Spring能从classpath下自动扫描，侦测和实例化具有特定注解的组件。</p><ul><li><p>特定组件包括：（这些注解只是用来给编程人员看的，Spring只识别有没有这些注解而不区别）</p><ul><li><p>@Component：基本注解，标识了一个受Spring管理的组件</p></li><li><p>@Respository：标识持久层组件</p></li><li><p>@Service：标识服务层（业务层）组件</p></li><li><p>@Controller：标识表现层组件</p></li></ul></li></ul></li><li><p>在applictionContext.xml里配置bean</p><blockquote><p>在spring配置文件中引入context命名空间。</p></blockquote><ul><li><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan </span><br><span class="line">    base-package=&quot;包名&quot;</span><br><span class="line">    resource-pattern=&quot;a/*.class&quot;&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>属性：</p><p>base-package：指定包名，IoC容器扫描该包和子包下的所有类。</p><p>resource-pattern：限制扫描范围。</p></li><li><p>子标签：</p><ul><li><p>&lt;context:include-filter&gt;：包括指定的类</p><blockquote><p>若实现”只包含指定类”，需要在&lt;context:component-scan&gt;中添加属性use-default-filters=”false”</p></blockquote><ul><li><p>属性：</p><p>type：用来指定过滤类型。</p><ul><li><p>annotation(过滤指定类)</p></li><li><p>assinable(过滤继承或实现了指定类的子类)</p></li></ul></li></ul></li><li><p>&lt;context:exclude-filter&gt;：不包括指定的类。</p></li></ul></li><li><p>bean创建过程：</p><p>IoC容器会扫描指定的包和其子类(经过过滤)，对添加了注解的类进行实例化，id为非限定类名（第一个字母小写）。</p></li><li><p>特殊：</p><ul><li><p>若某被扫描的bean1里有其他bean2，可以在bean2前加 @Autowired 标记，该bean2也会被自动注入。（setter方法也可）</p><ul><li><p>若bean2没有被注解，会抛异常。</p><p>解决方法：可以设置 @Autowired(required=false)，容器会对它赋值null。</p></li><li><p>若有两个bean2，也会抛异常。</p><blockquote><p>如：UserService是抽象的接口，而项目中有两个实现类userService1和userService2，且都有注解。</p></blockquote><p>解决方法：</p><p>(1) 在组件中添加名字。（如： @Service(userService1) ）</p><p>(2) 在bean2前添加 @Qualifier 注解。（如： @Qualifier(“userService2”) ）</p></li></ul></li></ul></li></ul><h2 id="Spring4新特性——泛型限定式依赖注入"><a href="#Spring4新特性——泛型限定式依赖注入" class="headerlink" title="Spring4新特性——泛型限定式依赖注入"></a>Spring4新特性——泛型限定式依赖注入</h2><ol><li><p>Spring4.0以前，对于父类里setter方法，必须在子类再写一个setter方法，然后指定注入的具体类型，然后进行注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseService</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaseRepository&lt;M&gt; repository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRepository</span><span class="params">(BaseRepository&lt;M&gt; repository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(M m)</span> </span>&#123;</span><br><span class="line">        repository.save(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserRepository</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">        setRepository(userRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">Organization</span>&gt; </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrganizationRepository</span><span class="params">(OrganizationRepository organizationRepository)</span> </span>&#123;  </span><br><span class="line">        setRepository(organizationRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Spring4.0实现了泛型依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseService</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> BaseRepository&lt;M&gt; repository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(M m)</span> </span>&#123;</span><br><span class="line">        repository.save(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">User</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">Organization</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="引入AOP"><a href="#引入AOP" class="headerlink" title="引入AOP"></a>引入AOP</h2><ol><li><p>如何实现一个计算器？（OOP）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArithmeticCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArithmeticCalculatorImpl</span> <span class="title">implents</span> <span class="title">ArithmeticCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = i + j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = i - j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何在使用计算器过程中打印日志？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"The method add begins with["</span> + i + <span class="string">","</span> + j + <span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">int</span> result = i + j;</span><br><span class="line">    System.out.println(<span class="string">"The method add ends with "</span> + result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述代码存在的问题</strong>：</p></li></ol><ul><li><p>代码混乱：越来越多的非业务需求加入后，原来的业务方法急剧膨胀，每个方法在处理核心逻辑的同时还必须兼顾其他多个关注点。</p></li><li><p>代码分散：每个模块都必须做相似的动作，而如果需求改变，每个模块都必须修改。</p></li></ul><ol start="3"><li><p>如何解决？</p><p>使用动态代理（InvocationHandler）—— 使用反射(reflect)对目标对象的每个方法进行模块化操作。</p><ul><li><p>代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArithmeticCalculatorLoggingProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> ArithmeticCalculator target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArithmeticCalculatorLoggingProxy</span><span class="params">(ArithmeticCalculator target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArithmeticCalculator <span class="title">getLoggingProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArithmeticCalculator proxy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 代理对象由哪个类加载器负责加载</span></span><br><span class="line">        ClassLoader loader = target.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 代理对象的类型，即其中有那些方法</span></span><br><span class="line">        Class[] interfaces = <span class="keyword">new</span> Class[]&#123;ArithmeticCalculator<span class="class">.<span class="keyword">class</span>&#125;</span>;</span><br><span class="line">        <span class="comment">// 当调用代理对象其中方法时，执行的代码</span></span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * proxy：正在返回的代理对象，一般情况下，在invoke方法中都不使用该对象</span></span><br><span class="line"><span class="comment">             * —— 如果你想使用这个对象，并调用它的方法，又会调用invoke()方法，直至发生死循环。</span></span><br><span class="line"><span class="comment">             * method：正在调用的方法</span></span><br><span class="line"><span class="comment">             * args：调用方法时传入的参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                <span class="comment">//日志</span></span><br><span class="line">                System.out.println(<span class="string">"The method "</span> + methodName + <span class="string">" begins with ["</span> + args[<span class="number">0</span>] + <span class="string">","</span> + args[<span class="number">1</span>] + <span class="string">"]"</span>);</span><br><span class="line">                <span class="comment">//执行方法</span></span><br><span class="line">                Object result = method.invoke(target, args);</span><br><span class="line">                <span class="comment">//日志</span></span><br><span class="line">                System.out.println(<span class="string">"The method "</span> + methodName + <span class="string">" ends with "</span> + result);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        proxy = Proxy.newProxyInstance(loader, interfaces, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用代理类创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArithmeticCalculator target = <span class="keyword">new</span> ArithmeticCalculatorImp();</span><br><span class="line">        ArithmeticCalculator proxy = <span class="keyword">new</span> ArithmeticCalculatorLoggingProxy(target).getLoggingProxy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = proxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"--&gt;"</span> + result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>问题</p><p>这种方法太麻烦，Spring把它封装起来，称为AOP。</p></li></ol><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><ul><li><p><strong>AOP (Aspect-Oriented Programming，面向切面编程)</strong>：是对传统OOP(Object-Oriented Programming，面向对象编程)的补充。</p></li><li><p>AOP的主要编程对象是切面(aspect)，而切面模块化横切关注点。</p></li><li><p>在AOP仍需定义公共功能，但不必修改受影响的类，这样横切的关注点就被模块化到特殊的对象(切面)里。</p></li><li><p>使用AOP的好处：</p><ul><li><p>每个事物逻辑位于一个位置，代码不分散，便于维护和升级。</p></li><li><p>业务模块更简洁，只包含核心业务代码。</p></li></ul></li></ul><blockquote><p>在上述的例子（计算器）中：</p><p>对于每个业务逻辑(add/sub/mul/div)，在实现这些逻辑之后用一个另外的类，对特定的多个逻辑进行额外操作（验证参数、前置/后置日志），这个过程，称为面向切面编程（AOP）。</p></blockquote><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li><p>切面(aspect)：横切关注点（跨越应用程序多个模块的功能）被模块化的特殊对象。</p></li><li><p>通知(advice)：切面必须完成的工作。</p></li><li><p>目标(target)：被通知的对象。</p></li><li><p>代理(proxy)：向目标对象应用通知之后创建的对象。</p></li><li><p>连接点(joinpoint)：程序执行的某个特定位置（如：类某个方法调用前、调用后、方法抛出异常后等）。</p></li><li><p>切点(pointcut)：连接点是客观存在的事物。通过切点可以定位到特定的一个或多个连接点。</p></li></ul><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>在Spring2.0以上版本中，可以使用 基于AspectJ(一种AOP框架)注解 或 基于XML 来配置AOP。</p><h3 id="基于AspectJ注解"><a href="#基于AspectJ注解" class="headerlink" title="基于AspectJ注解"></a>基于AspectJ注解</h3><ul><li><p>需要的jar包：aopalliance.jar、aspectj.weaver.jar 和 spring-aspects.jar</p></li><li><p>配置文件中导入aop命名空间。</p></li><li><p>使用AspectJ让aop自动动态代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置自动扫描的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;cn.gxk.spring.aop.impl&quot;&gt;&lt;/context:component-scan&gt;切面类</span><br></pre></td></tr></table></figure></li><li><p>切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把该类声明为一个切面：需要把该类放入IoC容器，再声明为切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知：目标方法之前执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs());</span><br><span class="line">        System.out.println(<span class="string">"The method "</span> + methodName + <span class="string">" begins with"</span>+args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知：目标方法之前执行(无论是否发生异常都执行)</span></span><br><span class="line"><span class="comment">     * 拿不到返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"The method "</span> + methodName + <span class="string">" ends"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回通知：方法正常执行后返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value=<span class="string">"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))"</span>,</span><br><span class="line">            returning=<span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span></span>&#123;</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"The method "</span> + methodName + <span class="string">" return "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知：在目标方法发生异常时执行</span></span><br><span class="line"><span class="comment">     *     可以访问到异常对象，甚至过滤指定异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value=<span class="string">"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))"</span>,</span><br><span class="line">            throwing=<span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint, NullPointerException ex)</span></span>&#123;</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"The method "</span> + methodName + <span class="string">" occurs exception:"</span> + ex.getStackTrace());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知：需要携带ProceedingJoinPoint类型的参数</span></span><br><span class="line"><span class="comment">     * ProceedingJoinPoint参数可以决定是否执行目标方法</span></span><br><span class="line"><span class="comment">     * 且环绕通知必须有返回值，返回值为目标方法的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundMethod</span><span class="params">(ProceedingJoinPoint pjd)</span></span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        String methodName = pjd.getSignature().getName();</span><br><span class="line">        <span class="comment">//执行目标方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//前置通知</span></span><br><span class="line">            System.out.println(<span class="string">"[环绕]The method "</span> + methodName + <span class="string">" begins with "</span> + Arrays.asList(pjd.getArgs()));</span><br><span class="line">            result = pjd.proceed();</span><br><span class="line">            <span class="comment">//返回通知</span></span><br><span class="line">            System.out.println(<span class="string">"[环绕]The method "</span> + methodName + <span class="string">"ends with "</span> + result);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">//异常通知</span></span><br><span class="line">            System.out.println(<span class="string">"[环绕]The method "</span> + methodName + <span class="string">" occurs exception:"</span> + e.getStackTrace());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后置通知</span></span><br><span class="line">        System.out.println(<span class="string">"[环绕]The method "</span> + methodName + <span class="string">"ends"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通知的种类：</p><ul><li><p>@Before：前置通知</p></li><li><p>@After：后置通知(无论是否发生异常)，拿不到返回结果</p></li><li><p>@AfterRunning：返回通知，在方法返回结果后执行</p></li><li><p>@AfterThrowing：异常通知，在方法抛出异常后执行</p></li><li><p>@Around：环绕通知，围绕着方法执行，上述通知能做到的它都能做到。</p></li></ul><blockquote><p>注：可以使用通配符（*）来替代方法标志的任意部分（前缀、返回指、方法名等），方法参数则可以用(..)代替。</p></blockquote></li></ul><blockquote><p>注意：动态代理需要使用接口，所以自动动态代理后的bean会自动转化为接口的类型使用 ctx.getBean(接口.class); 得到bean。</p><p>另：若有多个切面 ，可以 @Order(1) 用来指定切面的优先级，值越小优先级越高！</p></blockquote></li></ul><h4 id="重用切面表达式"><a href="#重用切面表达式" class="headerlink" title="重用切面表达式"></a>重用切面表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个方法，用于声明切入点表达式，一般地，该方法不需要添加其他代码</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(...)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareJointPointExpression</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在通知注解中调用（不同包的不同类下需要声明包名和类名）</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"包名.类名.declareJointPointExpression()"</span>);</span><br></pre></td></tr></table></figure><h3 id="基于XML文件"><a href="#基于XML文件" class="headerlink" title="基于XML文件"></a>基于XML文件</h3><ul><li><p>切面(Aspect)类写法与上述一致，不需要使用注释</p></li><li><p>xml里配置（返回或异常通知的returning和throwing属性需要与切面类的参数名相同）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--bean--&gt;</span><br><span class="line">&lt;bean id=&quot;arithmeticCalculator&quot;</span><br><span class="line">      class=&quot;cn.gxk.spring.aop.xml.ArithmeticCalculatorImpl&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--切面的bean--&gt;</span><br><span class="line">&lt;bean id=&quot;loggingAspect&quot;</span><br><span class="line">      class=&quot;cn.gxk.spring.aop.xml.LoggingAspect&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;!--配置切点表达式--&gt;</span><br><span class="line">    &lt;aop:pointcut expression=&quot;execution(* cn.gxk.spring.aop.xml.ArithmeticCalculator.*(int, int))&quot;</span><br><span class="line">                  id=&quot;pointcut&quot;/&gt;</span><br><span class="line">    &lt;!--配置切面及通知--&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;loggingAspect&quot; order=&quot;1&quot;&gt;</span><br><span class="line">        &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt;</span><br><span class="line">        &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt;</span><br><span class="line">        &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pointcut&quot; returning=&quot;result&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt;</span><br><span class="line">        &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pointcut&quot; throwing=&quot;ex&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt;</span><br><span class="line">        &lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="JDBC相关"><a href="#JDBC相关" class="headerlink" title="JDBC相关"></a>JDBC相关</h1><h2 id="JDBC相关工具"><a href="#JDBC相关工具" class="headerlink" title="JDBC相关工具"></a>JDBC相关工具</h2><h3 id="c3p0配置数据源"><a href="#c3p0配置数据源" class="headerlink" title="c3p0配置数据源"></a>c3p0配置数据源</h3><ol><li><p>数据源配置文件 db.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.password</span> = <span class="string">123456</span></span><br><span class="line"><span class="meta">jdbc.driverClass</span> = <span class="string">com.mysql:///spring4</span></span><br><span class="line"><span class="meta">jdbc.initPoolSize</span> = <span class="string">5</span></span><br><span class="line"><span class="meta">jdbc.maxPoolSize</span> = <span class="string">10</span></span><br></pre></td></tr></table></figure></li><li><p>在applicationContext.xml里配置c3p0数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导入资源文件 --&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line">&lt;!-- 配置C3P0数据源 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot;</span><br><span class="line">      class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;initialPoolSize&quot; value=&quot;$&#123;jdbc.initialPoolSize&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;jdbc.maxPoolSize&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>测试连接数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ctx = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        DataSource dataSource = ctx.getBean(DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(dataSource.getConnection());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Spring的JDBCTemplate"><a href="#Spring的JDBCTemplate" class="headerlink" title="Spring的JDBCTemplate"></a>Spring的JDBCTemplate</h3><ol><li><p>在applicationContext.xml里配置JDBCTemplate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;jdbcTemplate&quot;</span><br><span class="line">      class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>JDBCTest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ctx = nulll;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    &#123;</span><br><span class="line">        ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        jdbcTemplate = (JdbcTemplate) ctx.getBean(<span class="string">"jdbcTemplate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单条更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"UPDATE employee SET last_name = ? WHERE id=?"</span>;</span><br><span class="line">        jdbcTemplate.update(sql, <span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatchUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"INSERT INTO employee(last_name, email, dept_id) VALUES(?, ?, ?)"</span>;</span><br><span class="line">        List&lt;Object[]&gt; betchArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"Zhang"</span>, <span class="string">"zhang@1.com"</span>, <span class="number">1</span>&#125;);</span><br><span class="line">        batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"Li"</span>, <span class="string">"li@2.com"</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"Wang"</span>, <span class="string">"wang@3.com"</span>, <span class="number">3</span>&#125;);</span><br><span class="line"></span><br><span class="line">        jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到数据库里一条记录，并生成对象</span></span><br><span class="line"><span class="comment">     * 注意：并不是使用queryForObject(String sql, Class&lt;Employee&gt; requiredType, Object...args)</span></span><br><span class="line"><span class="comment">     *        而是 queryForObject(String sql, RowMapper&lt;Employee&gt; requiredType, Object...args)</span></span><br><span class="line"><span class="comment">     *    1. 其中RowMapper指定如何去映射结果集的行，常用的实现类为BeanPropertyRowMapper</span></span><br><span class="line"><span class="comment">     *    2. 使用SQL中列的别名完成列名和类的属性名的映射。例如:last_name lastName</span></span><br><span class="line"><span class="comment">     *    3. 并不支持级联属性，JdbcTemplate只是JDBC的小工具，并非ORM框架</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"SELECT id,last_name lastName, email FROM employees WHERE id = ？"</span>;</span><br><span class="line">        RowMapper&lt;Employee&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Employee<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, <span class="number">1</span>);</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得单列的值，或做统计查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"SELECT count(id) FROM employees"</span>;</span><br><span class="line">        <span class="keyword">long</span> count = jdbcTemplate.queryForObject(sql, Long<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询实体类的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"SELECT id, last_name lastName, email FROM employees WHERE id&gt; ?"</span>;</span><br><span class="line">        RowMapper&lt;Employee&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Employee<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper, <span class="number">5</span>);</span><br><span class="line">        System.out.println(employees);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>说明：</p><ul><li><p>每次使用都创建一个JdbcTemplate的新实例，这种做法效率低下。</p></li><li><p>JdbcTemplate类被设计成线程安全的，所有可以在IOC中声明它的单个实例，并把这个实例注入到所有的Dao里。</p></li></ul></li><li><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Respository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentDao</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">get</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"SELECT id, last_name lastName, email FROM employees WHERE id= ?"</span>;</span><br><span class="line">        RowMapper&lt;Employee&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Employee<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, id);</span><br><span class="line">        <span class="keyword">return</span> employee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="扩展JdbcDaoSupport"><a href="#扩展JdbcDaoSupport" class="headerlink" title="扩展JdbcDaoSupport"></a>扩展JdbcDaoSupport</h3><blockquote><p>使用起来更麻烦，不推荐！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Respository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentDao</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要提供数据源(或使用JdbcTemplate)才能连接数据库</span></span><br><span class="line"><span class="comment">     *    但由于JdbcDaoSupport父类中已经有JdbcTemplate变量，</span></span><br><span class="line"><span class="comment">     *    且setDataSource()已经被设计成final类型，</span></span><br><span class="line"><span class="comment">     *    所以并不能直接注入数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource2</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        setDataSource(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要通过getJdbcTemplate()得到 JdbcTemplate对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DepartMent <span class="title">get</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"SELECT id, dept_name name FROM departments WHERE id= ?"</span>;</span><br><span class="line">        RowMapper&lt;DepartMent&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(DepartMent<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        DepartMent departMent = getJdbcTemplate().queryForObject(sql, rowMapper, id);</span><br><span class="line">        <span class="keyword">return</span> departMent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用具名参数"><a href="#使用具名参数" class="headerlink" title="使用具名参数"></a>使用具名参数</h3><blockquote><p>不需要再在java代码里绑定dataSource。</p></blockquote><ul><li><p>配置NamedParameterJdbcTemplate</p><p>该对象可以使用具名参数，其没有无参构造器，必须对其构造器指定参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;namedParameterJdbcTemplate&quot;</span><br><span class="line"> class=&quot;org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>测试使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ctx = nulll;</span><br><span class="line">    <span class="keyword">private</span> NamedParameterJdbcTemplate namedParameterJdbcTemplate;</span><br><span class="line">    &#123;</span><br><span class="line">        ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        namedParameterJdbcTemplate = ctx.getBean(NamedParameterJdbcTemplate<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以给参数起名字</span></span><br><span class="line"><span class="comment">     *    1.好处：若有多个参数，不需要再去对应位置，直接对应参数名，不方便维护。</span></span><br><span class="line"><span class="comment">     *    2.缺点：书写复杂。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedParameterJdbcTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"INSERT INTO employees(last_name, email, dept_id) VALUES(:ln, :email, :deptid)"</span>;</span><br><span class="line">        Map&lt;String,Object&gt; paramMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        paramMap.put(<span class="string">"ln"</span>,<span class="string">"Alice"</span>);</span><br><span class="line">        paramMap.put(<span class="string">"email"</span>,<span class="string">"Alice@123.com"</span>);</span><br><span class="line">        paramMap.put(<span class="string">"deptid"</span>,<span class="string">"2"</span>);</span><br><span class="line">        namedParameterJdbcTemplate.update(sql, paramMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * update(String sql, SqlParameterSource paramSource);</span></span><br><span class="line"><span class="comment">     *    1.sql语句中的参数名与类的属性名保持一致！</span></span><br><span class="line"><span class="comment">     *    2.使用SqlParameterSource的实现类BeanPropertySqlParameterSource作为参数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedParameterJdbcTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"INSERT INTO employees(last_name, email, dept_id) VALUES(:lastName, :email, :deptId)"</span>;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setLastName(<span class="string">"zhang"</span>);</span><br><span class="line">        employee.setEmail(<span class="string">"zhang@1.com"</span>);</span><br><span class="line">        employee.setDeptId(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        SqlParameterSource paramSource = <span class="keyword">new</span> BeanPropertySqlParameterSource(Employee);</span><br><span class="line">        namedParameterJdbcTemplate.update(sql, paramSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><ul><li><p>事务管理是企业级应用程序开发中必不可少的技术，用来确保数据的完整性和一致性。</p></li><li><p>事务管理就是一系列动作，它们作为一个单独的工作单元。这些动作需要全部完成后才能都起作用。</p></li><li><p>事务的四个属性：</p><ul><li><p>原子性(atomicity)</p></li><li><p>一致性(consistency)</p></li><li><p>隔离性(isolation)</p></li><li><p>持久性(durability)</p></li></ul></li></ul><h3 id="JDBC事务操作"><a href="#JDBC事务操作" class="headerlink" title="JDBC事务操作"></a>JDBC事务操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = dataSource.getConnection();</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring中的事务管理"><a href="#Spring中的事务管理" class="headerlink" title="Spring中的事务管理"></a>Spring中的事务管理</h3><ul><li><p>编程式事务管理</p></li><li><p>声明式事务管理</p><p>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</p><ul><li><p>事务管理作为一种横切关注点，可以通过AOP方法模块化。Spring通过Spring AOP框架支持声明式事务管理。</p></li><li><p>Spring从不同的事务管理API中抽象了一整套的事务机制。从而让事务管理代码独立于特定的事务之外。</p></li><li><p>使用方法：</p><ul><li><p>applicationContext.xml配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot;</span><br><span class="line">      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 启动事务 --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用方法</p><p>在相应方法前增加注释 @Transactional，这个方法就会变成事务方法，IoC会让这个方法拥有事务的特性。</p></li></ul></li></ul></li></ul><h3 id="事务传播属性"><a href="#事务传播属性" class="headerlink" title="事务传播属性"></a>事务传播属性</h3><ul><li><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p></li><li><p>传播行为(propagation)</p><ul><li><p>REQUIRED(默认)：共用一个事务操作，回滚时都不执行。（例如：买了两本书，第二本购买失败，第一本也会失败）</p></li><li><p>REQUIRES_NEW：开启一个新的事务。（买了两本书，第二本购买失败，不影响第一本）</p></li></ul></li><li><p>隔离级别(isolation)</p><ul><li><p>DEFAULT</p><p>默认隔离级别，每种数据库支持的事务隔离级别不一样。</p></li><li><p>READ_UNCOMMITTED</p><p>读未提交，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用。</p></li><li><p>READ_COMMITED</p><p>读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读</p></li><li><p>REPEATABLE_READ</p><p>重复读取，即在数据读出来之后加锁，类似”select * from XXX for update”，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决。</p></li><li><p>SERLALIZABLE</p><p>串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了</p></li></ul><p><img src="//GxkOrd.github.io/2019/03/27/Java/Spring/1. Spring入门/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7.png" alt="事务隔离等级的并发问题"></p></li><li><p>回滚类型</p><ul><li><p>默认情况下对所有运行时异常进行回滚。</p></li><li><p>对某些异常不会滚：noRollbackFor={UserAccountException.class}</p></li><li><p>对哪些异常回滚：rollbackFor={UserAccountException.class}</p></li></ul></li><li><p>只读(readOnly=true)</p><ul><li>标明这个事务只读取数据而不更新，这样可以帮助数据库引擎优化事务</li></ul></li><li><p>强制回滚时间(timeout=1)</p><ul><li>如果事务执行时间超过1s，会强制回滚。以保证不占用太多数据库连接时间。</li></ul></li><li><p>使用实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation=Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchase</span><span class="params">(String username, String isbn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询书的单价</span></span><br><span class="line">    <span class="keyword">int</span> price = bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line">    <span class="comment">//更新库存</span></span><br><span class="line">    bookShopDao.updateBookStock(isbn);</span><br><span class="line">    <span class="comment">//更新账户余额</span></span><br><span class="line">    bookShopDao.updateUserAccount(username, price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用xml配置声明式事务"><a href="#使用xml配置声明式事务" class="headerlink" title="使用xml配置声明式事务"></a>使用xml配置声明式事务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot;</span><br><span class="line">      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 配置事务属性 --&gt;</span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">        &lt;!-- 根据方法名置顶事务的属性 --&gt;</span><br><span class="line">        &lt;tx:method name=&quot;purchase&quot; propagation=&quot;REQUIRES_NEW&quot;&gt;</span><br><span class="line">        &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置切入点 --&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut expression=&quot;execution(* cn.gxk.spring4.xml.service.*.*(...))&quot; id=&quot;txPointCut&quot;/&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;Spring是什么&quot;&gt;&lt;a href=&quot;#Spring是什么&quot; class=&quot;headerlink&quot; title=&quot;Spring是
      
    
    </summary>
    
      <category term="Java" scheme="https://GxkOrd.github.io/categories/Java/"/>
    
    
      <category term="Spring" scheme="https://GxkOrd.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>第4章 存储器</title>
    <link href="https://GxkOrd.github.io/2019/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC4%E7%AB%A0%20%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>https://GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/</id>
    <published>2019-03-16T07:05:00.000Z</published>
    <updated>2019-04-08T13:41:11.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h2><ol><li><p>按存储介质分类</p><ul><li>半导体存储器（TTL、MOS）</li></ul><blockquote><p>按材料不同，可分为TTL（双极型）半导体存储器和MOS半导体存储器。</p></blockquote><ul><li><p>磁表面存储器（磁头、磁载体）</p></li><li><p>磁芯存储器（硬磁材料、环状元件）</p></li><li><p>光盘存储器（激光、磁光材料）</p></li></ul></li><li><p>按存取方式分类</p><ul><li><p>存取时间与物理地址无关（随机访问）</p><ul><li><p>随机存储器：在<strong>程序的执行过程中</strong>可<strong>读</strong>可<strong>写</strong>。</p></li><li><p>只读存储器：在<strong>程序的执行过程中</strong>只<strong>读</strong>。</p></li></ul></li><li><p>存取时间与物理地址有关（串行访问）</p><ul><li><p>顺序存取存储器（磁带）</p></li><li><p>直接存取存储器（磁盘）</p></li></ul></li></ul></li><li><p>按在计算机中的作用分类</p><ul><li><p>主存储器 </p><ul><li><p>RAM（静态RAM、动态RAM）</p></li><li><p>ROM（MROM、PROM、EPROM、EEPROM）</p></li></ul></li><li><p>Flash Memory</p></li><li><p>高速缓冲存储器（Cache）</p></li><li><p>辅助存储器（如：磁盘、磁带、光盘）</p></li></ul></li></ol><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><ol><li>存储器三个主要特性的关系</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/存储器三个主要特性的关系.jpg" alt="存储器三个主要特性的关系" title>                </div>                <div class="image-caption">存储器三个主要特性的关系</div>            </figure><ol start="2"><li><p>缓存-主存层次和主存-辅存层次</p><ul><li><p>(1) 主存-辅存层次是为了解决主存容量小的问题。</p><p>辅存容量较大，可以将暂时不需要的数据（或指令）保存起来，主存需要时再读取。</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E4%B8%BB%E5%AD%98-%E8%BE%85%E5%AD%98%E5%B1%82%E6%AC%A1.jpg" alt="主存-辅存层次"></p><blockquote><p>主存和辅存的整体，称为<strong>虚拟存储器</strong>。主存和辅存的地址空间相互独立，所以虚拟存储器中的数据需要<strong>虚地址（逻辑地址）</strong>来存取。</p><p>相对的，主存中的地址称为<strong>实地址（物理地址）</strong>。</p></blockquote></li><li><p>(2) 缓存-主存层次是为了解决主存速度慢的问题。</p><p>缓存中保存了主存中部分常用数据（或指令）的副本，以提高CPU对这些常用信息（或指令）的读取速度。</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E7%BC%93%E5%AD%98-%E4%B8%BB%E5%AD%98%E5%B1%82%E6%AC%A1.jpg" alt="缓存-主存层次"></p></li></ul></li></ol><h1 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ol><li><p>主存的基本组成</p><p>实际上，通过MAR中的地址访问某个存储单元时，还需要经过<em>地址译码</em>、<em>驱动</em>等电路，才能找到所需访问的单元。读出时，需经过<em>读出放大器</em>，才能将选中单元的存储字送到MDR。写入时，MDR中的数据也必须经过<em>写入电路</em>才能真正写入到被选中单元中。</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.jpg" alt="主存的基本组成"></p></li><li><p>主存和CPU的联系 </p></li></ol><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E7%9A%84%E8%81%94%E7%B3%BB.jpg" alt="主存和CPU的联系"></p><ol start="3"><li><p>主存中存储单元地址的分配</p><p>12345678H这个数据如何在主存储器中进行存储？</p><ul><li><p>(1) <strong>高位字节</strong>地址为字地址（大端、大尾方式）</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%A4%A7%E7%AB%AF%E3%80%81%E5%A4%A7%E5%B0%BE%E6%96%B9%E5%BC%8F.jpg" alt="大端、大尾方式"></p></li><li><p>(2) <strong>低位字节</strong>地址为字地址（小端、小尾方式）</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%B0%8F%E7%AB%AF%E3%80%81%E5%B0%8F%E5%B0%BE%E6%96%B9%E5%BC%8F.jpg" alt="小端、小尾方式"></p><p>设地址线<strong>24</strong>根——按<strong>字节</strong>寻址——<strong>2^24 = 16MB</strong></p><p>若字长为<strong>16</strong>位——按 <strong>字</strong> 寻址——<strong>8MW</strong></p><p>若字节为<strong>32</strong>位——按 <strong>字</strong> 寻址——<strong>4MW</strong></p></li></ul></li><li><p>主存的技术指标</p><p>(1) 存储容量：主存存放二进制代码的总位数。</p><p>(2) 存储速度 </p><ul><li><p>存取时间：存储器的<strong>访问时间</strong>（读出时间或写入时间）。</p></li><li><p>存取周期：<strong>连续两次独立的存储器操作</strong>（读或写）所需的<strong>最小间隔时间</strong>。（读周期或写周期）</p></li></ul><p>(3) 存储器带宽</p><p>表示单位时间内存储器存取的信息量，单位可用字/秒或字节/秒或位/秒来表示。</p><blockquote><p>计算：若存周期为500ns，每个存储周期可访问16位（数据总线宽度），求它的带宽？</p><p>解：</p><p>$\frac{16位}{50ns} = \frac{16位×10^9}{50秒} = 32M位/秒$</p></blockquote></li></ol><h2 id="半导体存储芯片简介"><a href="#半导体存储芯片简介" class="headerlink" title="半导体存储芯片简介"></a>半导体存储芯片简介</h2><ol><li><p>半导体存储芯片的基本结构</p><p><em>译码驱动</em>能把地址总线送过来的地址信号翻译成对应存储单元的选择信号，该信号在<em>读/写电路</em>的配合下完成对选中单元的读/写操作。</p><p>读/写电路包括读出<em>放大器</em>和<em>写入电路</em>，用来完成读/写操作。</p><p>存储芯片通过地址总线、数据总线和控制总线与外部连接。</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg" alt="半导体存储芯片的基本结构"></p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E8%8A%AF%E7%89%87%E5%AE%B9%E9%87%8F%E8%AE%A1%E7%AE%97.jpg" alt="芯片容量计算.jpg"></p><p>片选线：$\overline{CS}$、$\overline{CE}$</p><p>读/写控制线：$\overline{WE}$（低电平写 高电平读）</p><p>  $\overline{OE}$（允许读）、$\overline{WE}$（允许写）</p><p><strong>存储芯片片选线的作用</strong>：</p><p>用16K × 1位的存储芯片组成64K × 8位的存储器：</p><p>![32片存储芯片组成64K × 8位的存储器](用16K × 1位的存储芯片组成64K × 8位的存储器.jpg)</p><p>当地址为65535时，</p><p>由于$64K = 64 × 2^{10} = 65536$，显然，65535保存在最后一组（右）。</p><p>可以在最后一组的芯片的同一位置各存放一位数据组成一个字符（共8位）。</p></li><li><p>半导体存储芯片的译码驱动方式</p><p>(1) 线选法</p><blockquote><p><strong>译码器</strong>：</p><p>以<strong>二次译码器</strong>为例，2个输入，4个输出。若输入00，则<em>输出线0</em>有效，其他输出线无效；若输入01，则<em>输出线1</em>有效，其他输出线无效。</p></blockquote><p>下图的<strong>地址译码器</strong>与之类似。输入有四个(A1,A2,A3,A4)，输出有16个（2^4，与输入相对应）。</p><p><strong>读/写控制电路</strong>用来表示位，位线的数量与位数相等。</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F-%E7%BA%BF%E9%80%89%E6%B3%95.jpg" alt="线选法"></p><p>而对于容量大(m × n)的半导体存储芯片，若使用线选法，则需要大量的数据线(logm + n条)。这<strong>严重增加了集成芯片的难度</strong>。</p><p>(2) 重合法</p><p>下图有两根MOS管，用来控制电流的流向，从而切换译码器。</p><p>对于m × n的半导体存储芯片，若使用重合法，则需要log(m+n)条数据线。</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F-%E9%87%8D%E5%90%88%E6%B3%95.jpg" alt="重合法"></p></li></ol><h2 id="随机存取存储器"><a href="#随机存取存储器" class="headerlink" title="随机存取存储器"></a>随机存取存储器</h2><ol><li><p><strong>静态RAM（SRAM）</strong></p><blockquote><p>Q：</p><ul><li><p>保存0和1的原理是什么？</p></li><li><p>基本单元电路的构成是什么？</p></li><li><p>对单元电路如何读出和写入？</p></li><li><p>典型芯片的结构是什么样子的？</p></li><li><p>静态RAM芯片如何进行读出和写入操作？</p></li></ul></blockquote><p>(1) 静态RAM基本电路</p><blockquote><p>有哪些保存0和1的方式？</p><ul><li><p>开关（开：1；关：0）</p></li><li><p>熔丝（连通：1；断开：0）- 难以更改</p></li><li><p><strong>触发器</strong></p></li></ul></blockquote><p>T1~T4：由MOS管组成的触发器（用来存放0和1）</p><p>T5、T6：行开关</p><p>T7、T8：列开关</p><p>A：触发器原端</p><p>A’：触发器非端</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E9%9D%99%E6%80%81RAM.jpg" alt="静态RAM"></p><p>① 静态RAM基本电路的<strong>读</strong>操作</p><p>行选 → T5、T6开</p><p>列选 → T7、T8开</p><p>读操作有效</p><p>VA → T6 → T8 → 读放 → Dout</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AF%BB%E6%93%8D%E4%BD%9C.jpg" alt="静态RAM基本电路的读操作"></p><p>② 静态RAM基本电路的<strong>写</strong>操作</p><p>行选 → T5、T6开</p><p>列选 → T7、T8开</p><p>写操作有效</p><p>DIN → 两个写放</p><p> DIN(左) → 反相 → T7 → T5 → A‘</p><p> DIN(右) → T8 → T6 → A</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C.jpg" alt="静态RAM基本电路的写操作"></p><p>(2) 静态RAM芯片举例（简单了解）</p><p>①  Intel2114外特性 </p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/Intel2114%E5%A4%96%E7%89%B9%E6%80%A7.jpg" alt="Intel2114外特性"></p><p>② Intel2114 RAM矩阵(64 × 64) - 读</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/Intel2114-RAM%E7%9F%A9%E9%98%B564%C3%9764-%E8%AF%BB.jpg" alt="Intel2114 RAM矩阵(64 × 64) - 读"></p><p>③ Intel2114 RAM矩阵(64 × 64) -写</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/Intel2114-RAM%E7%9F%A9%E9%98%B564%C3%9764-%E5%86%99.jpg" alt="Intel2114 RAM矩阵(64 × 64)-写"></p></li><li><p>动态RAM（DRAM）</p><blockquote><p>Q：</p><ul><li><p>保存0和1的原理是什么？</p></li><li><p>基本单元电路的构成是什么？</p></li><li><p>对单元电路如何读出和写入？</p></li><li><p>典型芯片的结构是什么样子的？</p></li><li><p>动态RAM芯片如何进行读出和写入操作？</p></li><li><p>动态RAM为什么要刷新，刷新方法？</p></li></ul></blockquote><p>(1) 动态RAM基本单元电路</p><p>靠电容存储电荷的原理来寄存信息。若电容上存在足够多的电荷表示存“1”，电容上无电荷表示存“0”。</p><ul><li><p>三管式</p><blockquote><ul><li><p><strong>读出</strong>时，先对<em>预充电管T4</em>置一<em>预充电信号</em>，使读数据线达到高电平VDD。然后由读选择线打开T2，若<em>T1的极间电容Cg</em>存有足够电荷（被认为原存“1”），使T1导通，则因T2、T1接地，使读数据线降为零电平，读出“0”信息；若Cg没有足够电荷（原存“0”），则T1截止，读数据线为高电平不变，读出“1”信息。可见，读出线的高低电平可以区分“1”和“0”，且<strong>读出与原存信息相反</strong>。</p></li><li><p>写入时，将写信号加到写数据线上，然后由写数据线打开T3，这样，Cg便能随输入信息充电（写“1”）或放电（写“2”），且<strong>写入与输入信息相同</strong>。</p></li></ul></blockquote><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%8A%A8%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF-%E4%B8%89%E7%AE%A1%E5%BC%8F.jpg" alt="三管MOS动态RAM基本单元电路"></p></li><li><p>单管式</p><blockquote><p>为了提高集成度，将三管电路简化为单管。</p><ul><li><p>去掉T1，将信息保存到电容 Cs中。</p></li><li><p>将T2、T3合并为一个管子T。</p></li><li><p><strong>读出</strong>时，字线上的高电平使T接通，若Cs有电荷，视为“1”；若Cs无电荷，视为“0”。（读出结束时，Cs中电荷释放完毕，所以为破坏性读出，必须再生。）</p></li><li><p><strong>写入</strong>时，字线上的高电平使T接通，若数据线为高电平，经过T对Cs充电，使其存“1”；若数据线为低电平，Cs经T放电，使其存“0”。</p></li></ul></blockquote><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%8A%A8%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF-%E5%8D%95%E7%AE%A1%E5%BC%8F.jpg" alt="单管MOS动态RAM基本单元电路"></p></li></ul><p>(2) 动态RAM芯片举例</p><p>① 三管动态RAM芯片(Intel 1103) - 读</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E4%B8%89%E7%AE%A1%E5%8A%A8%E6%80%81RAM%E8%8A%AF%E7%89%87-Intel1103-%E8%AF%BB.jpg" alt="三管动态RAM芯片(Intel 1103) - 读"></p><p>② 三管动态RAM芯片(Intel 1103) - 写</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E4%B8%89%E7%AE%A1%E5%8A%A8%E6%80%81RAM%E8%8A%AF%E7%89%87-Intel1103-%E5%86%99.jpg" alt="三管动态RAM芯片(Intel 1103) - 写"></p><p>③ 单管动态RAM 4116 (16K × 1位)外特性</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%8D%95%E7%AE%A1%E5%8A%A8%E6%80%81RAM4116-16K%C3%971%E4%BD%8D-%E5%A4%96%E7%89%B9%E6%80%A7.jpg" alt="单管动态RAM 4116 (16K × 1位)外特性"></p><p>④ 4116(16K × 1位)芯片<strong>读</strong>原理</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%8A%A8%E6%80%81RAM4116-16K%C3%971%E4%BD%8D%E8%8A%AF%E7%89%87-%E8%AF%BB.jpg" alt="4116(16K × 1位)芯片**读**原理"></p><p>⑤ 4116(16K × 1位)芯片<strong>写</strong>原理</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%8A%A8%E6%80%81RAM4116-16K%C3%971%E4%BD%8D%E8%8A%AF%E7%89%87-%E5%86%99.jpg" alt="4116(16K × 1位)芯片**写**原理"></p><p>(4) 动态RAM刷新（刷新与行地址有关）</p><p>① 集中刷新（存取周期为0.5μs）</p><p>以128 × 128为例：</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%8A%A8%E6%80%81RAM%E7%9A%84%E5%88%B7%E6%96%B0-%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0.jpg" alt="集中刷新时间分配示意图"></p><p><strong>“死区”</strong>为 $0.5μs × 128 = 64μs$</p><p><strong>“死时间率”</strong>为 $128/4000 × 100% = 3.2%$</p><p>② 分散刷新（存取周期1μs）</p><p>以128 × 128为例：</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%8A%A8%E6%80%81RAM%E7%9A%84%E5%88%B7%E6%96%B0-%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0.jpg" alt="分散刷新时间分配示意图"></p><p><strong>无“死区”</strong></p><p>存取周期为$0.5μs + 0.5μs = 1μs$（<strong>周期变长，性能降低</strong>）</p><p>③ 异步刷新（分散刷新与集中刷新相结合）（存储周期为0.5μs）</p><p>对于128×128的存储芯片：</p><p>若每隔<strong>15.6μs</strong>刷新一行</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%8A%A8%E6%80%81RAM%E7%9A%84%E5%88%B7%E6%96%B0-%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0.jpg" alt="异步刷新时间分配示意图"></p><p>每行每隔<strong>2ms</strong>刷新一次</p><p>死区为<strong>0.5μs</strong></p><p><strong>将刷新安排在指令译码阶段，不会出现“死区”问题。</strong></p></li><li><p>动态RAM和静态RAM的比较</p></li></ol><table><thead><tr><th></th><th>DRAM</th><th>SRAM</th></tr></thead><tbody><tr><td>存储原理</td><td>电容</td><td>触发器</td></tr><tr><td>集成度</td><td>高</td><td>低</td></tr><tr><td>芯片引脚</td><td>少</td><td>多</td></tr><tr><td>功耗</td><td>小</td><td>大</td></tr><tr><td>价格</td><td>低</td><td>高</td></tr><tr><td>速度</td><td>慢</td><td>快</td></tr><tr><td>刷新</td><td>有</td><td>无</td></tr></tbody></table><p>   DRAM（动态RAM）常用于做主存；SRAM（静态RAM）常用于做缓存。</p><h2 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h2><ul><li><p>早期的只读存储器——由厂家写内容</p></li><li><p>改进1——用户可以自己写（一次性）</p></li><li><p>改进2——可以多次写（要能对信息进行擦除）</p></li><li><p>改进3——电可擦写（特定设备）</p></li><li><p>改进4——电可擦写（直接连接到计算机）</p></li></ul><ol><li><p>掩模ROM（MROM）</p><p>行列选择交叉处有MOS管为“1”</p><p>行列选择交叉处无MOS管为“0”</p></li><li><p>PROM（一次性编程）</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/ROM-PROM.jpg" alt="PROM"></p><p>熔丝断：为“0”</p><p>熔丝未断：为“1”</p></li><li><p>EPROM（多次性编程）</p><p>N型沟道浮动栅MOS电路</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/ROM-EPROM.jpg" alt="EPROM"></p><p>D端加正电压——形成浮动栅——S与D不导通为“0”</p><p>D端不加正电压——不形成浮动栅——S与D导通为“1”</p><p><strong>使用紫外线驱散浮动栅（擦除过程麻烦）</strong></p></li><li><p>EEPROM（多次编程）</p><p>电可擦写</p><p>局部擦写</p><p>全部擦写</p></li><li><p>Flash Memory（闪速型存储器）</p></li></ol><blockquote><p>EPROM —— 价格便宜 集成度高</p><p>EEPROM —— 电可擦洗重写</p><p>Flash Memory —— 比EEPROM快 具备RAM功能</p></blockquote><h2 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h2><ol><li><p>存储器容量的扩展</p><ul><li><p>(1) 位扩展（增加存储字长）</p><p>用<strong>2片</strong>1K × 4位存储芯片组成1K × 8位的存储器</p><blockquote><p>1K → 10根地址线</p><p>8位 → 8根数据线</p></blockquote><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95-%E4%BD%8D%E6%89%A9%E5%B1%95.jpg" alt="由2片1K×4位的芯片组成1K×8位的存储器"></p></li><li><p>(2) 字扩展</p><p>用<strong>2片</strong>1K × 8位存储芯片组成2K × 8位的存储器</p><blockquote><p>2K → 11根地址线</p><p>8位 → 8根数据线</p></blockquote><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95-%E5%AD%97%E6%89%A9%E5%B1%95.jpg" alt="由2片1K×8位的芯片组成2K×8位的存储器"></p></li><li><p>(3) 字、位同时扩展</p><p>用<strong>8片</strong>1K × 4位存储芯片组成4K × 8位的存储器</p><blockquote><p>4K → 12根地址线</p><p>8位 → 8根数据线</p></blockquote><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95-%E5%AD%97%E4%BD%8D%E5%90%8C%E6%97%B6%E6%89%A9%E5%B1%95.jpg" alt="由8片1K×4位存储芯片组成4K×8位的存储器"></p></li></ul></li><li><p>存储器与CPU的连接</p><p>(1) 地址线的连接 </p><p>(2) 数据线的连接</p><p>(3) 读/写命令线的连接</p><p>(4) 片选线的连接</p><p>(5) 合理选择存储芯片</p><p>(6) 其他（时序、负载）</p><blockquote><p> 例4.1、例4.2。</p></blockquote></li></ol><h2 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h2><ol><li><p>为什么要对存储器的信息进行校验？</p></li><li><p>为了能够校验出信息是否正确，如何进行编码？</p></li><li><p>检测和纠错能力与什么因素有关？</p></li><li><p>校验出信息出错后是如何进行纠错的？</p></li><li><p>除了教材上讲的校验码，你还知道哪些容错编码？原理是什么？</p></li></ol><blockquote><ul><li><p>合法代码集合</p><ol><li><p>{000, 001, 010, 011, 100, 101, 110, 111}</p><p>若出现错误代码，不会被发现。</p><p><strong>检0位错，纠0位错。</strong></p></li><li><p>{000, 011, 101, 110}（代码中1的个数为偶数。）</p><p>若出现错误代码100，能检测到1位错，但并不能纠错（来源可能是000或101或110）。</p><p><strong>检1位错，纠0位错。</strong></p></li><li><p>{000, 111}（3位表示1位）</p><p>若出现错误代码100，几乎可以认定是第1位出错了（正确代码为000）。</p><p>若出现错误代码110，几乎可以认定是第3位出错了（正确代码为111）。</p><p><strong>检1位错，纠1位错。</strong></p></li><li><p>{0000, 1111}（4位表示1位）</p><p>若出现错误代码1000，几乎可以认定是第1位出错了（正确代码为0000）。</p><p>若出现错误代码1100，几乎可以认定是第1位出错了（正确代码无法确定）。</p><p><strong>检2位错，纠1位错。</strong></p></li><li><p>{00000, 11111}（5位表示1位）</p><p>若出现错误代码11000，几乎可以认定第2、3位出错了（正确代码为00000）。</p><p>若出现错误代码11100，几乎可以认定第4、5位出错了（正确代码为11111）。</p><p><strong>检2位错，纠2位错。</strong></p></li></ol></li></ul></blockquote><ol><li><p>编码的最小距离</p><p>指任意两组合法代码之间<strong>二进制位</strong>的<strong>最少差异数</strong>。</p><p><strong>编码的纠错、检错能力与编码的最小距离有关。</strong></p><p>$L - 1 = D + C (D &gt;= C)$</p><blockquote><p>L —— 编码的最小距离</p><p>D —— 检测错误的位数</p><p>C —— 纠正错误的位数</p></blockquote><p>例如，当L=3时，这种编码可视为最多能检错二位，或能检错一位、纠错一位。</p><p><strong>汉明码是具有一位纠错能力的编码。</strong></p></li><li><p>汉明码的组成</p><ul><li><p>汉明码采用奇偶检验</p></li><li><p>汉明码采用分组检验</p></li></ul><p>若要储存的信息为00100011，增加1位校验位<strong>1</strong>00100011，使‘1’的个数为偶数。若读出的信息中‘1’的个数为奇数，即可检1位错。</p><blockquote><p>一种分组方式（基于划分的分组方式）：可以采用4位一组，得到<strong>1</strong>0010 <strong>0</strong>0011，若前五位中‘1’为奇数，则前五位有1位错，这样就能大大缩短需要检错的范围。</p></blockquote><ul><li><p>汉明码的分组是一种非划分方式。</p><ul><li><p>若有7位数据（1 - 2 - 3 - 4 - 5 - 6 - 7），将其分成3组，每组有1位校验位，共包含4位数据位。如下图所示：</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E6%B1%89%E6%98%8E%E7%A0%81%E5%88%86%E7%BB%84%E6%96%B9%E5%BC%8F.jpg" alt="汉明码分组方式"></p><p>按上图方式对三组数据进行奇偶校验（异或），得到校验结果$P_3$，$P_2$，$P_1$。（校验结果为1则该组出错）</p><p>结论如下：</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E6%B1%89%E6%98%8E%E7%A0%81%E5%88%86%E7%BB%84-%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%BB%93%E6%9E%9C.jpg" alt="汉明码分组-奇偶校验结果"></p></li><li><p>如何分组？</p><p>第1组：XXXX1（1）</p><p>第2组：XXX1X（2）</p><p>第3组：XX1XX（4）</p><p>第4组：X1XXX（8）</p><p>以此类推……</p></li></ul></li><li><p>汉明码的组成需要添加多少位检测位？</p><p>$2^k&gt;=n+k+1$</p></li><li><p>检测位的位置？</p><p>$2^i(i=0,1,2,3,…)$</p></li><li><p>检测位的取值？</p><p>与该位所在的检测“小组”所承担的奇偶校验任务有关。</p><blockquote><p>各检测位$C_i$所承担的检测小组为：</p><p><strong>$C_1$</strong>检测的g1小组包含第1, 2, 3, 7, 9, 11, …位（二进制编码为X…XXX1）</p><p><strong>$C_2$</strong>检测的g2小组包含第2, 3, 6, 7, 10, 11, …位（二进制编码为X…XX1X）</p><p><strong>$C_4$</strong>检测的g3小组包含第4, 5, 6, 7, 12, 13, …位（二进制编码为X…X1XX）</p><p><strong>$C_8$</strong>检测的g4小组包含第8, 9, 10, 11, 12, 13, …位（二进制编码为X…1XXX）</p><p>……</p><p>$g_i$小组独占$2^{i-1}$位，二进制编码为0…10…0</p><p>$g_i$和$g_j$小组共同占第$2^{i-1}+2^{j-1}$位，二进制编码为0…010…010…0</p><p>$g_i$、$g_j$和$g_l$小组共同占第$2^{i-1}+2^{j-1}+2^{l-1}$位</p></blockquote></li></ul><blockquote><p><strong>例题</strong>：求0101按“偶校验”配置的汉明码？</p><p><strong>解</strong>：</p><p>$∵n=4$</p><p>根据$2^k&gt;=n+k+1$，得$k=3$</p><p>汉明码排序如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/汉明码-例题.jpg" alt="汉明码排序" title>                </div>                <div class="image-caption">汉明码排序</div>            </figure><p>$C_1=3⊕5⊕7=0$</p><p>$C_2=3⊕6⊕7=1$</p><p>$C_4=5⊕6⊕7=0$</p><p>$∴$ 0101的汉明码为 <strong>0100101</strong></p></blockquote></li><li><p>汉明码的纠错过程</p><p>形成新的检验位$P_i$，其位数与增添的检测位有关，</p><p>如增添3位（k=3），新的检测位$P_4$、$P_2$、$P_1$</p><p>以k=3位例，$P_i$的取值为：</p><p>  $P_1=1⊕3⊕5⊕7$</p><p>  $P_2=2⊕3⊕6⊕7$</p><p>  $P_4=4⊕5⊕6⊕7$</p><p>对于按“偶校验”配置的汉明码：</p><p>不出错时， $P_1=0$，$P_2=0$，$P_4=0$</p><blockquote><p><strong>例题</strong>：已知接收的汉明码为0100111，</p><p>（按配偶原则配置）试问要求传送的信息是什么？</p><p><strong>解</strong>：</p><p>纠错过程如下：</p><p>$P_1=1⊕3⊕5⊕7=0$ 无错</p><p>$P_2=2⊕3⊕6⊕7=1$ 有错</p><p>$P_4=4⊕5⊕6⊕7=1$ 有错</p><p>即第6位出错，可纠正为01001<strong>0</strong>1，</p><p>故要求传送的信息为<strong>0101</strong>。</p></blockquote></li></ol><h2 id="提高访问速度的措施"><a href="#提高访问速度的措施" class="headerlink" title="提高访问速度的措施"></a>提高访问速度的措施</h2><ul><li><p>采用高速器件</p></li><li><p>采用层次结构欧Cache-主存</p></li><li><p><strong>调整主存结构</strong></p></li></ul><ol><li><p>单体多字系统</p><p>由于程序和数据在存储体内是连续存放的，因此CPU访存取出的信息也是连续的，如果可在一个存储周期内，从<strong>同一地址</strong>取出4条指令，然后再逐条送至CPU执行，即每隔1/4存取周期，主存向CPU送一条指令，这样显然<strong>增大了存储器的带宽</strong>，提高了单体存储器的工作速度，如下图所示。</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E7%B3%BB%E7%BB%9F.jpg" alt="单体多字系统"></p><p>存在的问题：</p><ul><li><p>若只需向存储体写入16位数据（单字长），而数据寄存器却多读出了48位，若想让这48位不存入存储体，会增加寄存器的复杂性。</p></li><li><p>若需要取出的数据（或指令）不是连续的，必然会使数据寄存器取出无用的数据。</p></li></ul><blockquote><p>虽然单体多字系统把数据分开存取，但它们依然是以整体的方式存在的。</p></blockquote></li><li><p>多体并行系统</p><ul><li><p>高位交叉（顺序编址）</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F-%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89.jpg" alt="多体并行系统-高位交叉"></p><p>存在的问题：</p><ul><li><p>某个存储体可能会非常繁忙，其余存储体空闲。</p></li><li><p>这种方式主要适用于存储器容量的扩展，并不适合提高存储器的带宽。</p></li></ul></li><li><p>低位交叉（各个体轮流编址）</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F-%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89.jpg" alt="多体并行系统-低位交叉"></p><p><strong>低位交叉的特点</strong>：</p><p>在不改变存储周期的前提下，增加存储器的带宽。</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89-4%E4%B8%AA%E5%AD%98%E5%82%A8%E4%BD%93%E4%BA%A4%E5%8F%89%E8%AE%BF%E9%97%AE%E7%9A%84%E6%97%B6%E9%97%B4%E5%85%B3%E7%B3%BB.jpg" alt="4个存储体交叉访问的时间关系"></p><p>以四体低位交叉存储器为例，存储周期位$T$，总线传输周期为$τ$，为实现流水线方式存取，应满足$T=4τ$。</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E5%9B%9B%E4%BD%93%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%E5%AD%98%E5%82%A8%E5%99%A8%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="四体低位交叉编址存储器流水线工作方式示意图"></p><p>连续读取4个字所需时间位$T+(4-1)τ$</p></li></ul></li><li><p>高性能存储芯片</p><ul><li><p>SDRAM(同步RAM)</p><p>在系统时钟的控制下进行读出和写入。</p><p><strong>CPU无须等待</strong>。</p></li><li><p>RDRAM</p><p>由<strong>Rambus</strong>开发，主要解决<strong>存储器带宽</strong>问题。</p></li><li><p>带Cache的DRAM</p><p>在DRAM的芯片内<strong>集成</strong>了一个由<strong>SRAM</strong>组成的<strong>Cache</strong>，有利于<strong>猝发式读取</strong>。</p></li></ul></li></ol><h1 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ol><li><p>问题的提出</p><p>避免CPU“空等”现象</p><p>CPU和主存（DRAM）的速度差异</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/Cache%E7%9A%84%E6%8F%90%E5%87%BA.jpg" alt="Cache的提出"></p><p><strong>程序访问的局部性原理</strong>：指令和数据在主存的地址分布不是随机的，而是相对的簇聚，使得CPU在执行程序时，访存具有相对的局部性。</p></li><li><p>Cache工作原理</p><ul><li><p>(1) 主存和缓存的编址</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/Cache-%E4%B8%BB%E5%AD%98%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg" alt="Cache-主存存储空间的基本结构"> </p><p><strong>主存和缓存按块存储，块的大小相同。</strong></p><blockquote><p>实际上，缓存中块内地址的意义不大。这是因为主存的块内地址和缓存中的块内地址位数是相同的，而且“块”在主存和Cache之间是整体传输的，块内字节顺序不会发生变化。</p><p>缓存中的标记，是用来保存对应主存块号的。若CPU给出一个内存地址，并希望在缓存中访问到这个地址，首先要对比缓存中的标记，确定该块是否已经被读取到了Cache中。</p></blockquote></li><li><p>(2) 命中与未命中</p><p>缓存共有C块，主存共有M块（M&gt;&gt;C）</p><ul><li><p><strong>命中</strong></p><p>主存块<strong>调入</strong>缓存</p><p>主存块与缓冲块<strong>建立</strong>了对应关系</p><p>用<strong>标记</strong>记录与某缓存块建立了对应的<strong>主存块号</strong></p></li><li><p>未命中</p><p>主存块<strong>未调入</strong>缓存</p><p>主存块与缓冲块<strong>未建立</strong>对应关系</p></li></ul></li><li><p>(3) Cache的命中率</p><p>CPU欲访问的信息在Cache中的<strong>比率</strong></p><p><strong>命中率</strong>与Cache的<strong>容量</strong>与<strong>块长</strong>有关</p><p>一般每块可取4~8个字</p><p><strong>块长取一个存取周期内从主存调出的信息长度</strong></p></li><li><p>(4) Cache - 主存系统的效率</p><p>效率<strong>e</strong>与<strong>命中率</strong>有关</p><p>$e=\frac{访问Cache的时间}{平均访问时间}×100%$</p><p>设Cache<strong>命中率</strong>为h，访问<strong>Cache</strong>的时间为$t_c$，访问<strong>主存</strong>的时间为$t_m$，</p><p>则$e=\frac{t_c}{h×t_c+(1-h)×t_m}×100%$</p></li></ul></li><li><p>Cache的基本结构</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86%E6%A1%86%E5%9B%BE.jpg" alt="Cache的基本结构原理框图"></p><blockquote><p>CPU（通过<strong>地址总线</strong>）给出地址，这个地址包括<strong>（主存）块号</strong>和<strong>块内地址</strong>。块内地址直接传给Cache，使用块号在<strong>主存Cache地址映像机构</strong>中确认<strong>是否命中</strong>。如果发生命中，得到Cache的块号；如果未命中，查看Cache中<strong>是否有空间可装入主存块</strong>。若有，访问主存装入Cache；若没有，启用<strong>Cache替换机构</strong>，根据替换算法，决定Cache中哪块可以被替换，然后<strong>访问主存替换Cache</strong>即可。</p></blockquote></li><li><p>Cache的<strong>读写</strong>操作</p><ul><li><p><strong>读</strong></p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/Cache%E7%9A%84%E8%AF%BB%E6%95%B0%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="Cache的读数操作流程"></p></li><li><p><strong>写</strong></p><ul><li><p>写直达法（Write-through）</p><p>写操作时数据既写入Cache又写入主存</p><p><strong>写操作时间就是访问主存时间</strong>，Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现</p></li><li><p>写回法（Write-back）</p><p>写操作只把数据写入Cache而不写入主存</p><p>当Cache数据被替换出去时才写回主存</p></li></ul></li></ul></li><li><p>Cache的改进</p><ul><li><p>(1) 增加Cache的级数</p><p>片载（片内）Cache</p><p>片外Cache</p></li><li><p>(2) 统一缓存和分立缓存</p><ul><li><p>统一缓存：指令和数据放在同一缓存内的Cache</p></li><li><p>分立缓存：分成指令Cache、数据Cache</p></li></ul><blockquote><p>两种缓存的选取主要考虑两个因素：</p><ul><li><p>与主存结构有关。如果计算机的主存是统一的（指令和数据存储在统一主存中），则相应的Cache采用统一缓存；如果主存采用指令、数据分开存储的方案，则相应的Cache采用分立缓存。</p></li><li><p>与指令执行的控制方式有关。当采用超前控制或流水线控制方式时，一般采用分立缓存。</p></li></ul></blockquote></li></ul></li></ol><h2 id="Cache-主存地址映射"><a href="#Cache-主存地址映射" class="headerlink" title="Cache-主存地址映射"></a>Cache-主存地址映射</h2><ol><li><p>直接映射</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/Cache-%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.jpg" alt="直接映射"></p><blockquote><p>根据Cache存储体的大小将主存储体划分成多个区，每个区与Cache存体大小相同。</p></blockquote><p><strong>每个缓存块i</strong>可以和<strong>若干</strong>个<strong>主存块</strong>对应。</p><p><strong>每个主存块j</strong>只能和<strong>一</strong>个<strong>缓存块</strong>对应。</p><p><strong>优点</strong>：实现简单，只需利用主存地址的某些位直接判断，就可确定所需字块是否在缓存中。</p><p><strong>缺点</strong>：不够灵活，因每个内存块只能固定地对应某个缓存块，即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分的利用。此外，如果程序恰好要重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率。</p><blockquote><p><em>例题：设主存容量为1MB，采用直接映射方式的Cache容量为16KB，块长为4，每字32位。试问主存地址位ABCDEH的存储单元在Cache中的什么位置？</em></p><p>解：</p><p>每块容量：$4×\frac{32}{8}=16B=2^4B$，即<strong>字块内地址4位</strong>。</p><p>块数：$\frac{16KB}{16B}=1K=1024$，即<strong>Cache字块地址10位</strong>。</p><p>主存容量$1MB=2^{20}B$，即地址总格式20位，分为$\frac{1MB}{4×\frac{32}{8}B}=2^{16}$块，每块$2^4B$，采用直接映射方式，主存字块标记为$20-14=6$位。</p><p>综上，主存地址格式为：</p><p><strong>主存字块标记（6位）Cache字块地址（10位）字块内地址（4位）</strong></p><p>主存地址$ABCDEH=(1010 1011 1100 1101 1110)_2$，主存字块标记为<strong>101010</strong>，Cache字块地址为<strong>1111001101</strong>，字块内地址为<strong>1110</strong>，<strong>故该主存单元应映射到Cache的101010块的第1110字节，即第42块第14字节位置</strong>。</p></blockquote></li><li><p>全相联映射</p><p>允许主存中每一字块映射到Cache中的任何一块位置上。</p><p><strong>优点</strong>：灵活，命中率高，缩短了块冲突率。</p><p><strong>缺点</strong>：</p><p>(1) 主存字块标记需要与Cache的所有标记进行<strong>同时</strong>比较，电路会非常复杂。</p><p>(2) 主存字块标记从t位增加到t+c位，这就使Cache”标记“的位数增多，比较器的长度就会增长。</p></li><li><p>组相联映射</p><blockquote><p>组相联映射是对直接映射和全相联映射的一种折中。</p></blockquote><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/Cache-%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84-%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.jpg" alt="组相联映射"></p><p>$i = jmodQ$</p><p><strong>某一主存块j</strong>按模<strong>Q</strong>映射到<strong>缓存</strong>的<strong>第i组</strong>中的<strong>任一块</strong>。</p></li></ol><h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><ol><li><p>先进先出（FIFO）算法</p></li><li><p>近期最少使用（LRU）算法 </p></li><li><p>随机法</p></li></ol><h1 id="辅助存储器（非重要）"><a href="#辅助存储器（非重要）" class="headerlink" title="辅助存储器（非重要）"></a>辅助存储器（非重要）</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ol><li><p>特点</p><p>不直接与CPU交换信息。</p></li><li><p>磁表面存储器的技术指标</p><p>(1) 记录密度（道密度$D_t$、位密度$D_b$）</p><p>(2) 存储容量</p><blockquote><p>$C=n×k×s$，n为存放信息的盘面数，k为每个盘面的磁道数，s为每条磁道上记录的二进制代码数。</p></blockquote><p>(3) 平均寻址地址</p><blockquote><p>寻道时间 + 等待时间</p></blockquote><blockquote><p>辅存的速度：寻址时间、磁头读写时间</p></blockquote><p>(4) 数据传输率</p><blockquote><p>$D_r=D_b×V$</p></blockquote><p>(5) 误码率</p><blockquote><p>出错信息位数与读取信息的总位数。 </p></blockquote></li></ol><h2 id="磁记录原理和记录方式"><a href="#磁记录原理和记录方式" class="headerlink" title="磁记录原理和记录方式"></a>磁记录原理和记录方式</h2><ol><li><p>磁记录原理</p><p><strong>写</strong>：</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E7%A3%81%E8%AE%B0%E5%BD%95%E5%8E%9F%E7%90%86-%E5%86%99.jpg" alt="磁记录原理-写"></p><p><strong>读</strong>：</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E7%A3%81%E8%AE%B0%E5%BD%95%E5%8E%9F%E7%90%86-%E8%AF%BB.jpg" alt="磁记录原理-读"></p></li></ol><h2 id="硬磁盘存储器"><a href="#硬磁盘存储器" class="headerlink" title="硬磁盘存储器"></a>硬磁盘存储器</h2><ol><li><p>硬磁盘存储器的类型</p><p>(1) 固定磁头和移动磁头</p><p>(2) 可换盘和固定盘</p></li><li><p>硬磁盘存储器结构</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E7%A1%AC%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84.jpg" alt="硬磁盘存储器结构"></p><p>(1) 磁盘驱动器</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8.jpg" alt="磁盘驱动器"></p><p>(2) 磁盘控制器</p><ul><li><p>接收主机发来的命令，转换成磁盘驱动器的控制命令。</p></li><li><p>实现主机和驱动器之间的数据格式转换。</p></li><li><p>控制磁盘驱动器读写。</p><p><strong>磁盘控制器</strong>是主机与磁盘驱动器之间的<strong>接口</strong>。</p></li></ul><p>(3) 盘片</p><p>由硬质铝合金材料制成。</p></li></ol><h2 id="软磁盘存储器"><a href="#软磁盘存储器" class="headerlink" title="软磁盘存储器"></a>软磁盘存储器</h2><ol><li>概述</li></ol><table><thead><tr><th></th><th>硬盘</th><th>软盘</th></tr></thead><tbody><tr><td>速度</td><td>高</td><td>低</td></tr><tr><td>磁头</td><td>固定、活动（浮动）</td><td>活动（接触盘片）</td></tr><tr><td>盘片</td><td>固定盘、盘组大部分不可换</td><td>可换盘片</td></tr><tr><td>价格</td><td>高</td><td>低</td></tr><tr><td>环境</td><td>苛刻</td><td></td></tr></tbody></table><ol start="2"><li><p>软盘片</p><p><img src="//GxkOrd.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/%E8%BD%AF%E7%9B%98%E7%89%87.jpg" alt="软盘片"></p></li></ol><h2 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="光盘存储器"></a>光盘存储器</h2><ol><li><p>概述</p><p>采用光存储技术 —- <strong>利用激光写入和读出</strong></p><p>第一代光存储技术 —- 采用非磁性介质 —- 不可擦写</p><p>第二代光存储技术 —- 采用磁性介质 —- 可擦写</p></li><li><p>光盘的存储原理</p><p>只读型和只写一次型 —- 热作用（物理或化学）</p><p>可擦写光盘 —- 热磁效应</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;存储器分类&quot;&gt;&lt;a href=&quot;#存储器分类&quot; class=&quot;headerlink&quot; title=&quot;存储器分类&quot;&gt;&lt;/a&gt;存储器分
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://GxkOrd.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成原理" scheme="https://GxkOrd.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第3章 系统总线</title>
    <link href="https://GxkOrd.github.io/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC3%E7%AB%A0%20%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/"/>
    <id>https://GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/</id>
    <published>2019-03-15T07:10:12.000Z</published>
    <updated>2019-03-15T16:49:56.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h1><h2 id="为什么要用总线"><a href="#为什么要用总线" class="headerlink" title="为什么要用总线"></a>为什么要用总线</h2><p>计算机系统的五大部件之间有两种互联方式：分散连接、总线连接。</p><blockquote><p>分散连接：各部件之间使用单独的连线。（分散连接会使系统难以扩展，所以引入总线结构。)</p><p>总线连接：将各部件连接到一组公共信息传输线上。</p></blockquote><h2 id="什么是总线"><a href="#什么是总线" class="headerlink" title="什么是总线"></a>什么是总线</h2><p>总线是连接各个部件的信息传输线，是<strong>各个部件共享的传输介质</strong>。</p><h2 id="总线上信息的传输"><a href="#总线上信息的传输" class="headerlink" title="总线上信息的传输"></a>总线上信息的传输</h2><p>串行：信息在总线上按位传输。常用与计算机与计算机之间。</p><p>并行：信息在总线上多位传输。需要多条数据线平行传输，所以，若传输距离过长，数据线之间容易发生干扰。常用于单个计算机内部。</p><h2 id="总线结构的计算机举例"><a href="#总线结构的计算机举例" class="headerlink" title="总线结构的计算机举例"></a>总线结构的计算机举例</h2><ol><li><p>单总线结构框图</p><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.jpg" alt="单总线结构框图"></p><p>缺点：设备的利用率低。在同一时刻，只有一对设备能使用总线。</p></li><li><p>面向CPU的双总线结构框图</p><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/%E9%9D%A2%E5%90%91CPU%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.jpg" alt="面向CPU的双总线结构框图"></p><p>缺点：主存和外部设备之间无直接通路。若两者之间需要通信，会打断CPU的运行。</p></li><li><p>以存储器为中心的总线结构框图</p><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/%E4%BB%A5%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.jpg" alt="以存储器为中心的总线结构框图"></p></li></ol><h1 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h1><ol><li><p>按连接部件不同：</p><p>(1) 片内总线：<strong>芯片内部</strong>的总线。</p><p>(2) 系统总线：<strong>计算机各部件之间</strong>的信息传输线。</p><pre><code>① 数据总线：双向，与机器字长、存储字长有关。② 地址总线：单向，与存储地址、I/O地址有关。③ 控制总线：有出（存储器读、写，总线许可，中断确认）有入（中断请求、总线请求）。</code></pre><p>(3) 通信总线：用于<strong>计算机系统之间</strong>或<strong>计算机系统与其他系统</strong>（如控制仪表、移动通信等）之间的通信。</p></li><li><p>按传输方式：并行传输总线、串行传输总线。</p></li></ol><h1 id="总线特性及性能指标"><a href="#总线特性及性能指标" class="headerlink" title="总线特性及性能指标"></a>总线特性及性能指标</h1><h2 id="总线物理实现"><a href="#总线物理实现" class="headerlink" title="总线物理实现"></a>总线物理实现</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/总线物理实现.jpg" alt="总线物理实现" title>                </div>                <div class="image-caption">总线物理实现</div>            </figure><h2 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h2><ol><li><p>机械特性：<strong>尺寸</strong>、形状、<strong>管脚数</strong>及<strong>排列顺序</strong>。</p></li><li><p>电气特性：<strong>传输方向</strong>和有效的<strong>电平</strong>范围。</p></li><li><p>功能特性：每根传输线的<strong>功能</strong>（地址、数据或控制）。</p></li><li><p>时间特性：信号的<strong>时序</strong>关系。</p></li></ol><h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2><ol><li><p>总线宽度：<strong>数据线</strong>的根数。</p></li><li><p>标准传输率：每秒传输的最大字节数（<strong>MBps</strong>）。</p></li><li><p>时钟同步/异步：<strong>同步</strong>、<strong>不同步</strong>（不等同于异步）。</p></li><li><p>总线复用：<strong>地址线</strong>与<strong>数据线</strong>复用。</p></li><li><p>信号线数：地址线、数据线和控制线的<strong>总和</strong>。</p></li><li><p>总线控制方式：突发、自动、仲裁、逻辑、计数。</p></li><li><p>其他指标：<strong>负载能力</strong>。</p></li></ol><h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/总线标准.jpg" alt="总线标准" title>                </div>                <div class="image-caption">总线标准</div>            </figure><h1 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h1><h2 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/单总线结构框图.jpg" alt="单总线结构" title>                </div>                <div class="image-caption">单总线结构</div>            </figure><h2 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h2><ol><li>双总线结构</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/双总线结构框图.jpg" alt="双总线结构" title>                </div>                <div class="image-caption">双总线结构</div>            </figure><ol start="2"><li>三总线结构</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/三总线结构框图1.jpg" alt="三总线结构1" title>                </div>                <div class="image-caption">三总线结构1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/三总线结构框图2.jpg" alt="三总线结构2" title>                </div>                <div class="image-caption">三总线结构2</div>            </figure><ol start="3"><li>四总线结构</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/四总线结构框图.jpg" alt="四总线结构" title>                </div>                <div class="image-caption">四总线结构</div>            </figure><h2 id="总线结构举例"><a href="#总线结构举例" class="headerlink" title="总线结构举例"></a>总线结构举例</h2><ol><li><p>传统微型机总线结构</p><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/%E4%BC%A0%E7%BB%9F%E5%BE%AE%E5%9E%8B%E6%9C%BA%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt="传统微型机总线结构"></p></li><li><p>VL-BUS局部总线结构</p><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/VL-BUS%E5%B1%80%E9%83%A8%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt="VL-BUS局部总线结构"></p></li><li><p>PCI总线结构</p><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/PCI%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt="PCI总线结构"></p></li><li><p>多层PCI总线结构</p><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/%E5%A4%9A%E5%B1%82PCI%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt="多层PCI总线结构"></p></li></ol><h1 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h1><h2 id="总线判优"><a href="#总线判优" class="headerlink" title="总线判优"></a>总线判优</h2><ol><li><p>基本概念</p><ul><li><p>主设备（模块）：对总线有<strong>控制权</strong>。</p></li><li><p>从设备（模块）：<strong>响应</strong>从主设备发来的总线命令。</p></li><li><p>总线判优控制：决定由哪个主设备占用总线。分为集中式、分布式两种。</p></li></ul></li><li><p>总线判优控制（集中式）</p><p>(1) 链式查询方式</p><p><strong>I/0接口n获得总线使用权的过程</strong>：<em>I/0接口n</em>发出<em>BR（总线请求）</em>，然后<em>总线控制部件</em>发出<em>BG（总线统一）</em>，<em>I/0接口n</em>再发送<em>BS（总线忙）</em>。</p><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98%E6%8E%A7%E5%88%B6-%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.jpg" alt="链式查询方式"></p><p>(2) 计数器定时查询方式</p><p><strong>I/0接口n获得总线使用权的过程</strong>：I/0接口n发出<em>BR</em>给<em>总线控制部件</em>，若可以给出总线使用权，则启用<strong>计数器</strong>，并初始化为0。总线控制部件通过<em>设备地址（线）</em>访问设备0，检查其是否发出了<em>BR</em>；若否，计数器+1，再访问设备1……若检查至设备n，且设备n发出了<em>BR</em>，则设备n发送<em>BS</em>。</p><p><strong>优点</strong>：设备（接口）的优先级设置非常灵活。</p><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98%E6%8E%A7%E5%88%B6-%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.jpg" alt="计数器定时查询方式"></p><p>(3) 独立请求方式</p><p><strong>I/O接口n获得总线使用权的过程</strong>：直接向<em>总线控制部件</em>发送<em>BR</em>，比对排队器里的序列，向对应I/O接口发送<em>BG</em>信号即可。</p><p><strong>优点</strong>：每个I/O接口都有独立的BR和BG。优先级的设置更加灵活，只需要管理总线控制部件的排队器即可。</p><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98%E6%8E%A7%E5%88%B6-%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.jpg" alt="独立请求方式"></p></li></ol><h2 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h2><ol><li><p>目的</p><p>解决通信双方<strong>协调配合</strong>问题。</p></li><li><p>总线传输周期</p><p>(1) 申请分配阶段：<strong>主模块申请</strong>，总线仲裁决定。</p><p>(2) 寻址阶段：主模块向从模块<strong>给出地址</strong>和<strong>命令</strong>。</p><p>(3) 传数阶段：主模块和从模块<strong>交换数据</strong>。</p><p>(4) 结束阶段：主模块<strong>撤销有关信息</strong>。</p></li><li><p>总线通信的四种方式</p><p>(1) 同步通信：由<strong>统一时标</strong>控制数据传送。</p><p>① 同步式数据输入</p><pre><code>T1 - 主模块发地址T2 - 主模块发读命令。T3 - 从模块提供数据。T4 - 主模块撤销读命令，从模块撤销数据。</code></pre><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1-%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.jpg" alt="同步式数据输入"></p><p>② 同步数据输出</p><pre><code>T1 - 主模块发地址。T1.5 - 主模块提供数据。T2 - 从模块发出写命令，从模块接收到命令后，必须在规定时间内将数据总线上的数据写到    地址总线所知名的单元中。T4 - 主模块撤销写命令和数据等信号。</code></pre><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1-%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA.jpg" alt="同步式数据输出"></p><p>(2) 异步通信：采用<strong>应答方式</strong>，没有公共时钟标准。</p><p>① 不互锁方式：请求和回答互不相关。<strong>无法保证通信的可靠性。</strong></p><p>② 半互锁方式：主模块接到从模块发送的回答信号，才撤销请求信号。<strong>可能会造成请求信号一直保持高电平状态</strong>。</p><p>③ 全互锁方式：主模块的请求信号撤销以后，从模块才撤销其回答信号。</p><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1-%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1.jpg" alt="异步通信"></p><p>(3) 半同步通信：<strong>同步、异步结合</strong>。</p><blockquote><p>同步：<strong>发送方</strong>用系统<strong>时钟前沿</strong>发信号；<strong>接收方</strong>用系统<strong>时钟后沿</strong>判断、识别。</p><p>异步：允许不同速度的模块和谐工作。增加一条<strong>“等待”响应信号</strong>。($\overline{WAIT}$)</p></blockquote><p>以输入数据为例：</p><p>T1 - 主模块发出地址信号。</p><p>T2 - 主模块发出命令。</p><p>Tw - 当$\overline{WAIT}$为低电平时，进入等待，Tw的宽度与T的宽度一致。</p><p>. . .</p><p>T3 - 从模块提供数据。</p><p>T4 - 主模块撤销读命令，从模块撤销数据。</p><p><img src="//GxkOrd.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1-%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.jpg" alt="半同步式数据输入"></p><blockquote><p>上述三种通信（同步、异步、半同步）的共同点：</p><ul><li><p>一个总线传输周期（以输入数据为例）</p><ul><li><p>主模块发地址、命令（<strong>占用总线</strong>）</p></li><li><p>从模块准备数据（<strong>不占用总线</strong>，<em>总线空闲</em>）</p></li><li><p>从模块向主模块发数据（<strong>占用总线</strong>）</p></li></ul></li></ul></blockquote><p>(4) 分离式通信：充分<strong>挖掘</strong>系统<strong>总线每个瞬间</strong>的潜力。</p><blockquote><p>原因：上述三种通信从模块准备数据时，总线处于空闲状态！</p></blockquote><p><strong>一个总线传输周期：</strong></p><ul><li><p>子周期1：<strong>主模块</strong>申请<strong>占用总线</strong>，使用完后即<strong>放弃总线</strong>的使用权。</p></li><li><p>子周期2：<strong>从模块</strong>申请<strong>占用总线</strong>，将各种信号送至总线上。</p></li></ul><p><strong>特点：</strong></p><pre><code>① 各模块有权申请占用总线。② 采用同步方式通信，不等对方回答。③  各个模块准备数据时，不占用总线。④ 总线被占用时，无空闲。</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总线的基本概念&quot;&gt;&lt;a href=&quot;#总线的基本概念&quot; class=&quot;headerlink&quot; title=&quot;总线的基本概念&quot;&gt;&lt;/a&gt;总线的基本概念&lt;/h1&gt;&lt;h2 id=&quot;为什么要用总线&quot;&gt;&lt;a href=&quot;#为什么要用总线&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://GxkOrd.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成原理" scheme="https://GxkOrd.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>16. 3Sum Closest(Medium)</title>
    <link href="https://GxkOrd.github.io/2019/03/02/%E7%AE%97%E6%B3%95/LeetCode/16.%203Sum%20Closest(Medium)/"/>
    <id>https://GxkOrd.github.io/2019/03/02/算法/LeetCode/16. 3Sum Closest(Medium)/</id>
    <published>2019-03-02T12:40:12.000Z</published>
    <updated>2019-10-16T07:35:23.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description:</strong><br>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><blockquote><p><strong>Example:</strong></p><blockquote><p>Given array nums = [-1, 2, 1, -4], and target = 1.<br>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p></blockquote></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述：</strong><br>给定一个由n个整数构成的数组nums和一个整数target，在nums中找到三个整数，使它们的总和最接近target。返回这三个整数的总和。您可以假设每个输入都只有一个答案。</p><blockquote><p><strong>例如:</strong></p><blockquote><p>给定数组 nums = [-1, 2, 1, -4], 和 target = 1.<br>最接近target的整数为2。(-1 + 2 + 1 = 2)</p></blockquote></blockquote></blockquote><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>这道题是第15题的加强版，解法与15题相似。</p><blockquote><p>运行速度：超过了98.65%的解答。</p><p>内存使用：超过了100%的解答。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cha = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result &gt; <span class="number">0</span> &amp;&amp; nums[i] * <span class="number">3</span> - target &gt;= result) &#123; </span><br><span class="line">                <span class="comment">// 若result &gt; 0，nums[i]与target的差大于result，后面的结果一定大于result。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> low = i + <span class="number">1</span>, high = nums.length - <span class="number">1</span>, sum = target - nums[i];</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[low] + nums[high] == sum) &#123;</span><br><span class="line">                        <span class="keyword">return</span> target;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[low] + nums[high] &lt; sum) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sum - nums[low] - nums[high] &lt; cha) &#123;</span><br><span class="line">                            cha = sum - nums[low] - nums[high];</span><br><span class="line">                            result = target - cha;</span><br><span class="line">                        &#125;</span><br><span class="line">                        low++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nums[low] + nums[high] - sum &lt; cha) &#123;</span><br><span class="line">                            cha = nums[low] + nums[high] - sum;</span><br><span class="line">                            result = target + cha;</span><br><span class="line">                        &#125;</span><br><span class="line">                        high--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://GxkOrd.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://GxkOrd.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Medium" scheme="https://GxkOrd.github.io/tags/LeetCode-Medium/"/>
    
  </entry>
  
  <entry>
    <title>15. 3Sum(Medium)</title>
    <link href="https://GxkOrd.github.io/2019/02/15/%E7%AE%97%E6%B3%95/LeetCode/15.%203Sum(Medium)/"/>
    <id>https://GxkOrd.github.io/2019/02/15/算法/LeetCode/15. 3Sum(Medium)/</id>
    <published>2019-02-15T11:33:12.000Z</published>
    <updated>2019-10-13T10:11:11.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description</strong>:<br>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0?<br>Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note</strong>:</p><blockquote><p>The solution set must not contain duplicate triplets.</p></blockquote><p><strong>Example</strong>: </p><blockquote><p>Given array nums = [-1, 0, 1, 2, -1, -4],<br>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述</strong>:<br>给定一个包含n个实数的数组nums，其中是否存在元素a，b，c，使得a + b + c = 0？<br>找到数组中所有唯一的三元组，它们的总和为零。</p><p><strong>另外</strong>:</p><blockquote><p>结果集中不得包含重复的三元组</p></blockquote><p><strong>例如</strong>: </p><blockquote><p>给定数组 nums = [-1, 0, 1, 2, -1, -4],<br>一个解决方案集合为:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p></blockquote></blockquote><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>首先，对数组进行排序。</p><p>然后，从0位置开始到倒数第三个位置（num.length-3)，进行遍历，假定num[i]就是3sum中得第一个加数，然后从i+1的位置开始，进行2sum的运算。</p><p>当找到一个3sum==0的情况时，判断是否在结果hashset中出现过，没有则添加。(利用hashset的value唯一性）</p><p>因为结果不唯一，此时不能停止，继续搜索，左右指针同时挪动。</p><p><strong>需要注意：</strong></p><ol><li><p>排除一切结果为空的情况。</p></li><li><p>若第一次遍历到的值大于0，则后续一定也大于0。</p></li><li><p>若第一次遍历到的值等于0，则只需判断后面有没有两个相同值。</p></li></ol><blockquote><p>运行速度：超过了91.74%的解答。</p><p>内存使用：超过了91.87%的解答。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span> || nums == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 对数组排序</span></span><br><span class="line">    <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; <span class="number">0</span> || nums[nums.length - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123; <span class="comment">// 若数组中，最小值大于0 或 最大值小于0，则直接返回res。</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; <span class="number">0</span>) &#123; <span class="comment">// 若nums[i]的3倍比目标值大，后面的结果一定小</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123; <span class="comment">// 若nums[i]的3倍与目标值相等</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; nums[i + <span class="number">2</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                        List&lt;Integer&gt; unit = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                        unit.add(<span class="number">0</span>);</span><br><span class="line">                        unit.add(<span class="number">0</span>);</span><br><span class="line">                        unit.add(<span class="number">0</span>);</span><br><span class="line">                        res.add(unit);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i-<span class="number">1</span>]) &#123; <span class="comment">// 避免重复</span></span><br><span class="line">                <span class="keyword">int</span> low = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[low] + nums[high];</span><br><span class="line">                    <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                        List&lt;Integer&gt; unit = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                        unit.add(nums[i]);</span><br><span class="line">                        unit.add(nums[low]);</span><br><span class="line">                        unit.add(nums[high]);</span><br><span class="line">                        res.add(unit);</span><br><span class="line">                        low++;</span><br><span class="line">                        high--;</span><br><span class="line">                        <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == nums[low - <span class="number">1</span>]) <span class="comment">// 避免重复</span></span><br><span class="line">                            low++;</span><br><span class="line">                        <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] == nums[high + <span class="number">1</span>]) <span class="comment">// 避免重复</span></span><br><span class="line">                            high--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">                        high--;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        low++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://GxkOrd.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://GxkOrd.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Medium" scheme="https://GxkOrd.github.io/tags/LeetCode-Medium/"/>
    
  </entry>
  
  <entry>
    <title>14. Longest Common Prefix(Easy)</title>
    <link href="https://GxkOrd.github.io/2019/01/23/%E7%AE%97%E6%B3%95/LeetCode/14.%20Longest%20Common%20Prefix(Easy)/"/>
    <id>https://GxkOrd.github.io/2019/01/23/算法/LeetCode/14. Longest Common Prefix(Easy)/</id>
    <published>2019-01-23T12:08:22.000Z</published>
    <updated>2019-10-13T10:11:38.399Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description</strong>:<br>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><blockquote><p><strong>Example 1</strong>: </p><blockquote><p><strong>Input</strong>: [“flower”,”flow”,”flight”]<br><strong>Output</strong>: “fl”</p></blockquote><p><strong>Example 2</strong>: </p><blockquote><p><strong>Input</strong>: [“dog”,”racecar”,”car”]<br><strong>Output</strong>: “”<br><strong>Explanation</strong>: There is no common prefix among the input strings.</p></blockquote></blockquote><p><strong>Note</strong>:</p><blockquote><p>All given inputs are in lowercase letters a-z.</p></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述</strong>:<br>编写一个函数来查找字符串数组中最长的公共前缀字符串。</p><p>如果没有公共前缀，则返回空字符串””。</p><blockquote><p><strong>例1</strong>: </p><blockquote><p><strong>输入</strong>: [“flower”,”flow”,”flight”]<br><strong>输出</strong>: “fl”</p></blockquote><p><strong>例2</strong>: </p><blockquote><p><strong>输入</strong>: [“dog”,”racecar”,”car”]<br><strong>输出</strong>: “”<br><strong>解释</strong>: 输入字符串中没有公共前缀。</p></blockquote></blockquote><p><strong>注意</strong>:</p><blockquote><p>所有给定的输入都是小写字母a-z。</p></blockquote></blockquote><h1 id="解法一-Mine"><a href="#解法一-Mine" class="headerlink" title="解法一(Mine)"></a>解法一(Mine)</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>按每位依次比对字符串数组中的每个字符。<br>注意：若遍历到某个字符串的第i个字符，其为当前字符串的最后一位，后面的字符就无需比对了。</p><blockquote><p>运行速度：超过了74.19%的解答。</p><p>内存使用：超过了100%的解答。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if (strs.length == 0)</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        else if (strs.length == 1)</span><br><span class="line">            return strs[0];</span><br><span class="line">        StringBuilder res = new StringBuilder();</span><br><span class="line">        int index = 0;</span><br><span class="line">        char temp = &apos; &apos;;</span><br><span class="line">        boolean flag = true;</span><br><span class="line">        f1: while (flag) &#123;</span><br><span class="line">            f2: for (int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">                if (&quot;&quot;.equals(strs[i]))</span><br><span class="line">                    break f1;</span><br><span class="line">                if (i == 0)</span><br><span class="line">                    temp = strs[i].charAt(index);</span><br><span class="line">                else if (temp != strs[i].charAt(index))</span><br><span class="line">                    break f1;</span><br><span class="line">                else if (i == strs.length - 1)</span><br><span class="line">                    if (temp == strs[i].charAt(index))</span><br><span class="line">                        res.append(temp);</span><br><span class="line">                if (index &gt;= strs[i].length() - 1)</span><br><span class="line">                    flag = false;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote><p>比较前两个字符串，得到公共前缀，与第三个字符串比较，直至公共前缀为空。</p></blockquote><blockquote><p>运行速度：超过了100%的解答。</p><p>内存使用：超过了80.70%的解答。</p></blockquote><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">        if (strs.length == 0) </span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        String prefix = strs[0];</span><br><span class="line">        for (int i = 1; i &lt; strs.length; i++)</span><br><span class="line">            while (strs[i].indexOf(prefix) != 0) &#123;</span><br><span class="line">                prefix = prefix.substring(0, prefix.length() - 1);</span><br><span class="line">                if (prefix.isEmpty()) return &quot;&quot;;</span><br><span class="line">            &#125;        </span><br><span class="line">        return prefix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><h2 id="主要思想-2"><a href="#主要思想-2" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote><p>与我的解法思想相同。</p></blockquote><p>想象一下，一个非常短的字符串位于数组的末尾。上述方法仍将非常困难。优化此情况的一种方法是进行垂直扫描。在转到下一列之前，我们在同一列（字符串的相同字符索引）上从上到下比较字符。</p><blockquote><p>运行速度：超过了74.19%的解答。</p><p>内存使用：超过了100%的解答。</p></blockquote><h2 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length() ; i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.length; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c)</span><br><span class="line">                    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);             </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h1><h2 id="主要思想-3"><a href="#主要思想-3" class="headerlink" title="主要思想"></a>主要思想</h2><p>分治。先求左半边，再求右半边，然后合并。</p><blockquote><p>运行速度：超过了74.19%的解答。</p><p>内存使用：超过了100%的解答。</p></blockquote><h2 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;    </span><br><span class="line">            <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span> , strs.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> strs[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">            String lcpLeft =   longestCommonPrefix(strs, l , mid);</span><br><span class="line">            String lcpRight =  longestCommonPrefix(strs, mid + <span class="number">1</span>,r);</span><br><span class="line">            <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">commonPrefix</span><span class="params">(String left,String right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = Math.min(left.length(), right.length());       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( left.charAt(i) != right.charAt(i) )</span><br><span class="line">                <span class="keyword">return</span> left.substring(<span class="number">0</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.substring(<span class="number">0</span>, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法五"><a href="#解法五" class="headerlink" title="解法五"></a>解法五</h1><h2 id="主要思想-4"><a href="#主要思想-4" class="headerlink" title="主要思想"></a>主要思想</h2><p>二分法。把第一个字符串分成两半，判断前一半是不是公共前缀。若是，后一半分成两半；若不是，前一半分成两半。</p><blockquote><p>运行速度：超过了100%的解答。</p><p>内存使用：超过了97.08%的解答。</p></blockquote><h2 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (String str : strs)</span><br><span class="line">            minLen = Math.min(minLen, str.length());</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> high = minLen;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isCommonPrefix(strs, middle))</span><br><span class="line">                low = middle + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                high = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, (low + high) / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">        String str1 = strs[<span class="number">0</span>].substring(<span class="number">0</span>,len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">            <span class="keyword">if</span> (!strs[i].startsWith(str1))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://GxkOrd.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://GxkOrd.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Easy" scheme="https://GxkOrd.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>13. Roman to Integer(Easy)</title>
    <link href="https://GxkOrd.github.io/2019/01/16/%E7%AE%97%E6%B3%95/LeetCode/13.%20Roman%20to%20Integer(Easy)/"/>
    <id>https://GxkOrd.github.io/2019/01/16/算法/LeetCode/13. Roman to Integer(Easy)/</id>
    <published>2019-01-16T11:33:21.000Z</published>
    <updated>2019-10-13T09:52:01.305Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description</strong>:<br>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><table><thead><tr><th>Symbol</th><th>Value</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9. <blockquote><ul><li>X can be placed before L (50) and C (100) to make 40 and 90. </li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul></blockquote></li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><blockquote><p><strong>Example 1</strong>: </p><blockquote><p><strong>Input</strong>: “III”<br><strong>Output</strong>: 3</p></blockquote><p><strong>Example 2</strong>: </p><blockquote><p><strong>Input</strong>: “IV”<br><strong>Output</strong>: 4</p></blockquote><p><strong>Example 3</strong>: </p><blockquote><p><strong>Input</strong>: “IX”<br><strong>Output</strong>: 9</p></blockquote><p><strong>Example 4</strong>: </p><blockquote><p><strong>Input</strong>: “LVIII”<br><strong>Output</strong>: 58<br><strong>Explanation</strong>: L = 50, V = 5, III = 3.</p></blockquote><p><strong>Example 5</strong>: </p><blockquote><p><strong>Input</strong>: “MCMXCIV”<br><strong>Output</strong>: 1994<br><strong>Explanation</strong>: M = 1000, CM = 900, XC = 90 and IV = 4.</p></blockquote></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述</strong>:<br>罗马数字由七个不同的符号表示：I，V，X，L，C，D和M。</p><table><thead><tr><th>符号</th><th>值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。十二写为XII，简称为X + II。<br>第二十七号写成XXVII，即XX + V + II。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<blockquote><ul><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul></blockquote></li></ul><p>给定一个罗马数字，将其转换为整数。<br>输入确保在1到3999的范围内。</p><blockquote><p><strong>例1</strong>: </p><blockquote><p><strong>输入</strong>: “III”<br><strong>输出</strong>: 3</p></blockquote><p><strong>例2</strong>: </p><blockquote><p><strong>输入</strong>: “IV”<br><strong>输出</strong>: 4</p></blockquote><p><strong>例3</strong>: </p><blockquote><p><strong>输入</strong>: “IX”<br><strong>输出</strong>: 9</p></blockquote><p><strong>例4</strong>: </p><blockquote><p><strong>输入</strong>: “LVIII”<br><strong>输出</strong>: 58<br><strong>解释</strong>: L = 50, V = 5, III = 3.</p></blockquote><p><strong>例5</strong>: </p><blockquote><p><strong>输入</strong>: “MCMXCIV”<br><strong>输出</strong>: 1994<br><strong>解释</strong>: M = 1000, CM = 900, XC = 90， IV = 4.</p></blockquote></blockquote></blockquote><h1 id="解法一-Mine"><a href="#解法一-Mine" class="headerlink" title="解法一(Mine)"></a>解法一(Mine)</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>result（int类型）保存结果，从右向左遍历字符。<br>若上一个大于当前，则result减当前value；否则，result加当前value。</p><blockquote><p>运行速度：超过了100%的解答。</p><p>内存使用：超过了100%的解答。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = s.length();</span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(--i);</span><br><span class="line">            <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                    now = <span class="number">0</span>;</span><br><span class="line">                    result = getResult(now, pre, <span class="number">1</span>, result);</span><br><span class="line">                    pre = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'V'</span>: </span><br><span class="line">                    now = <span class="number">1</span>;</span><br><span class="line">                    result = getResult(now, pre, <span class="number">5</span>, result);</span><br><span class="line">                    pre = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'X'</span>: </span><br><span class="line">                    now = <span class="number">2</span>;</span><br><span class="line">                    result = getResult(now, pre, <span class="number">10</span>, result);</span><br><span class="line">                    pre = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'L'</span>: </span><br><span class="line">                    now = <span class="number">3</span>;</span><br><span class="line">                    result = getResult(now, pre, <span class="number">50</span>, result);</span><br><span class="line">                    pre = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'C'</span>: </span><br><span class="line">                    now = <span class="number">4</span>;</span><br><span class="line">                    result = getResult(now, pre, <span class="number">100</span>, result);</span><br><span class="line">                    pre = <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'D'</span>: </span><br><span class="line">                    now = <span class="number">5</span>;</span><br><span class="line">                    result = getResult(now, pre, <span class="number">500</span>, result);</span><br><span class="line">                    pre = <span class="number">5</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'M'</span>: </span><br><span class="line">                    now = <span class="number">6</span>;</span><br><span class="line">                    result = getResult(now, pre, <span class="number">1000</span>, result);</span><br><span class="line">                    pre = <span class="number">6</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre, <span class="keyword">int</span> value, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pre &gt; now)</span><br><span class="line">            result -= value;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            result += value;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote><p>第一名的答案，与方法一思想类似。</p></blockquote><p>使用两次for循环。<br>第一次把当前位置是否大于下一位置保存到boolean数组中。<br>第二次根据boolean数组和字符串的同一位置，得到结果。</p><blockquote><p>运行速度：超过了100%的解答。</p><p>内存使用：超过了100%的解答。</p></blockquote><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] mem = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (test(s.charAt(i)) &lt; test(s.charAt(i+<span class="number">1</span>))) &#123;</span><br><span class="line">                mem[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mem[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mem[s.length() - <span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mem[i])&#123;</span><br><span class="line">                result = result - test(s.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result = result + test(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="string">'I'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'V'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'X'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'L'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'C'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'D'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'M'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://GxkOrd.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://GxkOrd.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Easy" scheme="https://GxkOrd.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>2018</title>
    <link href="https://GxkOrd.github.io/2018/12/31/%E4%B8%80%E4%BA%9B%E8%AF%9D/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/2018/"/>
    <id>https://GxkOrd.github.io/2018/12/31/一些话/年终总结/2018/</id>
    <published>2018-12-31T05:20:00.000Z</published>
    <updated>2019-01-23T07:57:46.342Z</updated>
    
    <content type="html"><![CDATA[<p>2018，可以称得上悠闲，也可以说是惨淡。</p><p>2018，考上了新的学校，有了一个新的身份，也创建了自己的博客。看了不少的电影，学了不多的知识。</p><p>2018，留下了不少遗憾：想刷LeetCode，由于某些原因只做了12道；想学Spring，却也没有每天坚持；想学机器学习，借到的书被一直搁置在书角；想通关的游戏，在Steam里没时间玩；电视剧电影看了一部又一部，反而极少拿出时间安静地读书……</p><p>2019，给自己定了几个小目标：刷完LeetCode前200，搞懂SSM并有个小成果，学完吴恩达的CS229课程，拿到《Iris.Fall》《Slay the Spire》所有奖杯，每天都要学英语、读书……</p><p>最后，放上B站关注了好久的一位UP主（独立菌儿）的视频：<br><a href="http://www.bilibili.com/video/av39426478" target="_blank" rel="noopener">http://www.bilibili.com/video/av39426478</a></p><p>诚如电影《熔炉》的结尾时所说：“我们一路奋斗，不是为了改变世界，而是为了不让这个世界改变我们”。<strong>愿我们在新的一年都能保持独立思考，不卑不亢不怂，长成自己想要到的样子。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="//GxkOrd.github.io/2018/12/31/一些话/年终总结/2018/你好，2019.png" alt="你好，2019" title>                </div>                <div class="image-caption">你好，2019</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018，可以称得上悠闲，也可以说是惨淡。&lt;/p&gt;
&lt;p&gt;2018，考上了新的学校，有了一个新的身份，也创建了自己的博客。看了不少的电影，学了不多的知识。&lt;/p&gt;
&lt;p&gt;2018，留下了不少遗憾：想刷LeetCode，由于某些原因只做了12道；想学Spring，却也没有每天
      
    
    </summary>
    
      <category term="一些话" scheme="https://GxkOrd.github.io/categories/%E4%B8%80%E4%BA%9B%E8%AF%9D/"/>
    
    
      <category term="年终总结" scheme="https://GxkOrd.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
