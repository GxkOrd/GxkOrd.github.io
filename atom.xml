<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>GxkOrd - blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gxkord.github.io/"/>
  <updated>2019-08-20T08:46:23.185Z</updated>
  <id>https://gxkord.github.io/</id>
  
  <author>
    <name>GxkOrd</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>1. 不要使用ArrayList、LinkedList！</title>
    <link href="https://gxkord.github.io/2019/08/20/Java/Java%E6%8A%80%E5%B7%A7/1.%20%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8ArrayList%E3%80%81LinkdList%EF%BC%81/"/>
    <id>https://gxkord.github.io/2019/08/20/Java/Java技巧/1. 不要使用ArrayList、LinkdList！/</id>
    <published>2019-08-20T06:48:00.000Z</published>
    <updated>2019-08-20T08:46:23.185Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>LinkedeList和ArrayList都实现了List接口，但是它们的工作原理却不一样。它们之间最主要的区别在于ArrayList是可改变大小的数组，而LinkedList是双向链接串列(doubly LinkedList)。</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul><li><p>Array是基于索引(index)的数据结构，它使用索引在数组中搜索和读取数据是很快的。Array获取数据的时间复杂度是O(1)，但是要删除数据却是开销很大的，因为这需要重排数组中的所有数据。</p></li><li><p>相对于ArrayList，LinkedList插入是更快的。因为LinkedList不像ArrayList一样，不需要改变数组的大小，也不需要在数组装满的时候要将所有的数据重新装入一个新的数组，这是ArrayList最坏的一种情况，时间复杂度是O(n)，而LinkedList中插入或删除的时间复杂度仅为O(1)。ArrayList在插入数据时还需要更新索引（除了插入数组的尾部）。</p></li><li><p>类似于插入数据，删除数据时，LinkedList也优于ArrayList。</p></li><li><p>LinkedList需要更多的内存，因为ArrayList的每个索引的位置是实际的数据，而LinkedList中的每个节点中存储的是实际的数据和前后节点的位置。</p></li></ul><h1 id="为什么“不要使用ArrayList！”"><a href="#为什么“不要使用ArrayList！”" class="headerlink" title="为什么“不要使用ArrayList！”"></a>为什么“不要使用ArrayList！”</h1><ul><li><p>因为ArrayList是线程不安全的。</p><p>以下为ArrayList的add()方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个元素时，做了如下两步操作</span></span><br><span class="line"><span class="comment">     * 1.判断列表的capacity容量是否足够，是否需要扩容</span></span><br><span class="line"><span class="comment">     * 2.真正将元素放在列表的元素数组里面</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>); </span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>ensureCapacityInternal()这个方法的详细代码我们可以暂时不看，它的作用就是判断如果将当前的新元素加到列表后面，列表的elementData数组的大小是否满足，如果size + 1的这个需求长度大于了elementData这个数组的长度，那么就要对这个数组进行扩容。</p><p>由此看到add元素时，实际做了两个大的步骤：</p><ol><li><p>判断elementData数组容量是否满足需求。</p></li><li><p>在elementData对应位置上设置值。</p></li></ol><p>这样也就出现了第一个导致线程不安全的隐患，在多个线程进行add操作时可能会导致elementData数组越界。具体逻辑如下：</p><ol><li><p>列表大小为9，即size=9。</p></li><li><p>线程A开始进入add方法，这时它获取到size的值为9，调用ensureCapacityInternal方法进行容量判断。</p></li><li><p>线程B此时也进入add方法，它获取到size的值也为9，也开始调用ensureCapacityInternal方法。</p></li><li><p>线程A发现需求大小为10，而elementData的大小就为10，可以容纳。于是它不再扩容，返回。</p></li><li><p>线程B也发现需求大小为10，也可以容纳，返回。</p></li><li><p>线程A开始进行设置值操作， elementData[size++] = e 操作。此时size变为10。</p></li><li><p>线程B也开始进行设置值操作，它尝试设置elementData[10] = e，而elementData没有进行过扩容，它的下标最大为9。于是此时会报出一个数组越界的异常ArrayIndexOutOfBoundsException。</p></li></ol></li><li><p>另外，elementData[size++] = e 设置值的操作同样会导致线程不安全。</p><p>这步操作其实并不是一个原子操作，它由如下两步操作构成：</p><p>elementData[size] = e;</p><p>size = size + 1;</p><p>在单线程执行这两条代码时没有任何问题，但是当多线程环境下执行时，可能就会发生一个线程的值覆盖另一个线程添加的值，具体逻辑如下：</p><ol><li><p>列表大小为0，即size=0。</p></li><li><p>线程A开始添加一个元素，值为A。此时它执行第一条操作，将A放在了elementData下标为0的位置上。</p></li><li><p>接着线程B刚好也要开始添加一个值为B的元素，且走到了第一步操作。此时线程B获取到size的值依然为0，于是它将B也放在了elementData下标为0的位置上。</p></li><li><p>线程A开始将size的值增加为1。</p></li><li><p>线程B开始将size的值增加为2。</p></li></ol></li></ul><h1 id="为什么“不要使用LinkedList！”"><a href="#为什么“不要使用LinkedList！”" class="headerlink" title="为什么“不要使用LinkedList！”"></a>为什么“不要使用LinkedList！”</h1><ul><li>因为LinkedList也是线程不安全的。</li></ul><h1 id="怎么解决"><a href="#怎么解决" class="headerlink" title="怎么解决"></a>怎么解决</h1><ul><li><p>使用Collections.synchronizedList(List<t> list)。</t></p><p>无论是读取还是写入，它都会进行加锁。</p><p><strong>当我们并发级别特别高，线程之间在任何操作上都会进行等待，因此在某些场景中它不是最好的选择。</strong></p></li><li><p>使用CopyOnWriteArrayList。</p><p>该类在使用过程中，读读之间不互斥，而且<strong>读写也不互斥</strong>。</p><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//得到旧数组并获取旧数组的长度</span></span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        <span class="comment">//复制旧数组的元素到新的数组中并且大小在原基础上加1</span></span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//把值插入到新数组中</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        <span class="comment">//使用新数组替换老数组</span></span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  从源码中，我们可以看出add操作中使用了重入锁，但是此锁只针对写-写操作。为什么读写之间不用互斥，关键就在于添加值的操作并不是直接在原有数组中完成，而是使用原有数组复制一个新的数组，然后将值插入到新的数组中，最后使用新数组替换旧数组，这样插入就完成了。</p><p>  使用这种方式，在add的过程中旧数组没有得到修改，因此写入操作不影响读取操，另外，数组定义private transient volatile Object[] array，其中采用volatile修饰，保证内存可见性，读取线程可以马上知道这个修改。下面我们来看看读取的操作：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;LinkedeList和ArrayList都实现了List接口，但是它们的工作原理却不一样。它们之间最主要的区别在于ArrayList是可改
      
    
    </summary>
    
      <category term="Java" scheme="https://gxkord.github.io/categories/Java/"/>
    
    
      <category term="List" scheme="https://gxkord.github.io/tags/List/"/>
    
      <category term="ArrayList" scheme="https://gxkord.github.io/tags/ArrayList/"/>
    
      <category term="LinkedList" scheme="https://gxkord.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>17. Letter Combinations of a Phone Number(Medium)</title>
    <link href="https://gxkord.github.io/2019/08/20/%E7%AE%97%E6%B3%95/LeetCode/17.%20Letter%20Combinations%20of%20a%20Phone%20Number(Medium)/"/>
    <id>https://gxkord.github.io/2019/08/20/算法/LeetCode/17. Letter Combinations of a Phone Number(Medium)/</id>
    <published>2019-08-20T02:28:00.000Z</published>
    <updated>2019-08-20T05:52:44.850Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description</strong>:<br>Given a string containing digits from  <code>2-9</code>  inclusive, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="题目描述.png" alt="题目描述" title>                </div>                <div class="image-caption">题目描述</div>            </figure><blockquote><p><strong>Example</strong>: </p><blockquote><p><strong>Input:</strong> “23”<br><strong>Output:</strong> [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></blockquote><p><strong>Note:</strong></p><blockquote><p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p></blockquote></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述</strong>:<br>给定包含2-9（包含2和9）的数字的字符串，返回该数字可能表示的所有可能的字母组合。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="题目描述.png" alt="题目描述" title>                </div>                <div class="image-caption">题目描述</div>            </figure><blockquote><p><strong>例如</strong>:</p><blockquote><p><strong>输入:</strong> “23”</p><p><strong>输出:</strong> [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p></blockquote><p><strong>另外:</strong></p><blockquote><p>虽然上述例子的输出是按字典顺序排列的，但您的答案可以是任何顺序。</p></blockquote></blockquote></blockquote><h1 id="解法一（mine）"><a href="#解法一（mine）" class="headerlink" title="解法一（mine）"></a>解法一（mine）</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><ol><li><p>使用String数组保存字符串和数字映射关系（只需数组下标+2，即可获取对应数字）。</p></li><li><p>获得输入字符串中所有数字对应的字符串，存入集合（letterList）。</p></li><li><p>取出letterList中第一个元素，分割成字符数组，分别放入集合1（res1）。</p></li><li><p>取出letterList中第二个元素，分割成字符数组，与集合1中的所有元素进行<code>乘积</code>运算，将结果分别放入集合2（res2）。</p></li><li><p>res1和res2交换，以保证需要进行<code>乘积</code>运算的集合为res1。</p></li><li><p>重复步骤3和4，直至遍历完letterList。</p></li><li><p>最后一步无需再交换res1和res2，直接返回res2即可。</p></li></ol><blockquote><p>运行速度：超过了65.32%的解答。</p><p>内存使用：超过了98.63%的解答。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用string数组保存a-z,</span></span><br><span class="line">        String[] letters = <span class="keyword">new</span> String[]&#123;<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] charArray = digits.toCharArray();</span><br><span class="line">        <span class="comment">// 保存digits每个字符对应的string集合</span></span><br><span class="line">        List&lt;String&gt; letterList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : charArray) &#123;</span><br><span class="line">            <span class="comment">// 注意：这里需要char转int，若直接(int)c，会返回ascII码</span></span><br><span class="line">            letterList.add(letters[Integer.parseInt(String.valueOf(c)) - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;String&gt; res1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; res2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (String letter : letterList) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] chars = letter.toCharArray();</span><br><span class="line">            <span class="keyword">if</span> (res2.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 若res2为空，直接将letter放入即可</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">                    res2.add(String.valueOf(c));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 若res2不为空，交换res1和res2</span></span><br><span class="line">                temp = res1;</span><br><span class="line">                res1 = res2;</span><br><span class="line">                res2 = temp;</span><br><span class="line">                <span class="comment">// 将遍历letter中每个字符，分别拼接res1中的每一个字符串，并放入res2</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">char</span> c : chars) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String s : res1) &#123;</span><br><span class="line">                        res2.add(s + c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 清空res1</span></span><br><span class="line">                res1.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法二（官方）"><a href="#解法二（官方）" class="headerlink" title="解法二（官方）"></a>解法二（官方）</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><ol><li><p>使用map存储（比解法一中的直接数组下标进行存取，更方便维护）。</p></li><li><p>回溯。</p></li></ol><blockquote><p>运行速度：超过了65.32%的解答。</p><p>内存使用：超过了98.63%的解答。</p></blockquote><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; phone = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">        put(<span class="string">"2"</span>, <span class="string">"abc"</span>);</span><br><span class="line">        put(<span class="string">"3"</span>, <span class="string">"def"</span>);</span><br><span class="line">        put(<span class="string">"4"</span>, <span class="string">"ghi"</span>);</span><br><span class="line">        put(<span class="string">"5"</span>, <span class="string">"jkl"</span>);</span><br><span class="line">        put(<span class="string">"6"</span>, <span class="string">"mno"</span>);</span><br><span class="line">        put(<span class="string">"7"</span>, <span class="string">"pqrs"</span>);</span><br><span class="line">        put(<span class="string">"8"</span>, <span class="string">"tuv"</span>);</span><br><span class="line">        put(<span class="string">"9"</span>, <span class="string">"wxyz"</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    List&lt;String&gt; output = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(String combination, String next_digits)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if there is no more digits to check</span></span><br><span class="line">        <span class="keyword">if</span> (next_digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// the combination is done</span></span><br><span class="line">            output.add(combination);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if there are still digits to check</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// iterate over all letters which map</span></span><br><span class="line">            <span class="comment">// the next available digit</span></span><br><span class="line">            String digit = next_digits.substring(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">            String letters = phone.get(digit);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; letters.length(); i++) &#123;</span><br><span class="line">                String letter = phone.get(digit).substring(i, i + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// append the current letter to the combination</span></span><br><span class="line">                <span class="comment">// and proceed to the next digits</span></span><br><span class="line">                backtrack(combination + letter, next_digits.substring(<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.length() != <span class="number">0</span>)</span><br><span class="line">            backtrack(<span class="string">""</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><h2 id="主要思想-2"><a href="#主要思想-2" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote><p>讨论区的答案，与官方答案类似。</p></blockquote><p>注意几点优化的操作：</p><ol><li><p>使用StringBuilder优化String的拼接。</p></li><li><p><code>arr[c - &#39;0&#39;]</code>的写法，比解法一中的<code>arr[Integer.parseInt(String.valueOf(c))]</code>更间接有效，</p></li><li><p>LinkedList比ArrayList更快地增删元素。</p></li></ol><blockquote><p>运行速度：超过了100%的解答。</p><p>内存使用：超过了98.63%的解答。</p></blockquote><h2 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    String arr[] = &#123;<span class="string">""</span>, <span class="string">""</span>, <span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>, <span class="string">"jkl"</span>, <span class="string">"mno"</span>, <span class="string">"pqrs"</span>, <span class="string">"tuv"</span>, <span class="string">"wxyz"</span>&#125;;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (digits.length() != <span class="number">0</span>) &#123;</span><br><span class="line">            recurse(<span class="keyword">new</span> StringBuilder(), digits, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurse</span><span class="params">(StringBuilder sb, String digits, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = digits.charAt(pos);</span><br><span class="line">        String curr = arr[c - <span class="string">'0'</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; curr.length(); i++) &#123;</span><br><span class="line">            c = curr.charAt(i);</span><br><span class="line">            sb.append(c);</span><br><span class="line">            <span class="keyword">if</span> (pos == digits.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                res.add(sb.toString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                recurse(sb, digits, pos + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb = sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://gxkord.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://gxkord.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Medium" scheme="https://gxkord.github.io/tags/LeetCode-Medium/"/>
    
  </entry>
  
  <entry>
    <title>1. SpringBoot入门</title>
    <link href="https://gxkord.github.io/2019/07/20/Java/SpringBoot/1.%20SpringBoot%E5%85%A5%E9%97%A8/"/>
    <id>https://gxkord.github.io/2019/07/20/Java/SpringBoot/1. SpringBoot入门/</id>
    <published>2019-07-20T00:05:00.000Z</published>
    <updated>2019-07-25T10:35:57.812Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot入门"><a href="#Springboot入门" class="headerlink" title="Springboot入门"></a>Springboot入门</h1><h2 id="SpringBoot简介"><a href="#SpringBoot简介" class="headerlink" title="SpringBoot简介"></a>SpringBoot简介</h2><ul><li><p>简化Spring应用开发的一个框架</p></li><li><p>整个Spring技术栈的一个大整合</p></li><li><p>J2EE开发的一站式解决方案</p></li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>2014，martin fowler</p><p>微服务：架构风格（服务微化）</p><p>一个应用应该是一组小型服务，可以通过HTTP的方式进行互通。</p><blockquote><ul><li><p>单体应用：ALL IN ONE</p></li><li><p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p></li></ul></blockquote><p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa" target="_blank" rel="noopener">微服务文档</a></p><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>功能：浏览器发送hello请求，服务器接受请求并处理，响应“Hello World!”字符串。</p><h3 id="创建maven项目"><a href="#创建maven项目" class="headerlink" title="创建maven项目"></a>创建maven项目</h3><h3 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;project xmlns=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span><br><span class="line">         xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         xsi:schemaLocation=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.gxk&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-01-helloworld&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h3 id="编写主程序"><a href="#编写主程序" class="headerlink" title="编写主程序"></a>编写主程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个SpringBoot主程序类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 启动SpringBoot应用</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写Controller、Service"><a href="#编写Controller、Service" class="headerlink" title="编写Controller、Service"></a>编写Controller、Service</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>直接右键运行主程序类即可</p><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><ol><li><p>maven中导入插件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 可将应用打包成可执行jar包的插件 --&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure></li><li><p>点击idea右侧工具栏中的<strong>Maven</strong>，运行”<strong>项目名-Lifecycle-package</strong>“</p></li><li><p>将target目录下jar包拷出，使用cmd的”<strong>java -jar xxx.jar</strong>“运行即可</p></li></ol><h2 id="HelloWorld探究"><a href="#HelloWorld探究" class="headerlink" title="HelloWorld探究"></a>HelloWorld探究</h2><h3 id="POM文件"><a href="#POM文件" class="headerlink" title="POM文件"></a>POM文件</h3><ol><li><p>父项目</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">他的父项目是：</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring‐boot‐dependencies&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath&gt;../../spring‐boot‐dependencies&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">他来真正管理Spring Boot应用里面的所有依赖版本</span><br></pre></td></tr></table></figure></li></ol><p>   Spring Boot的版本仲裁中心。</p><p>   以后我们导入依赖默认是不需要写版本（没有在dependencies里面管理的依赖自然需要声明版本号）</p><ol start="2"><li><p>启动器</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ol><p>   spring-boot-starter：springboot的场景启动器，帮我们导入了指定模块（如：web）正常运行所依赖的组件。</p><p>   <strong>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter，相关场景的所有依赖都会导入进来。需要什么功能就导入什么场景启动器</strong></p><h3 id="主程序类"><a href="#主程序类" class="headerlink" title="主程序类"></a>主程序类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 声明一个SpringBoot主程序类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动SpringBoot应用</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@SpringBootApplication</strong>：用来标注SpringBoot的主程序类，SpringBoot<br>应该运行这个类的main方法来启动SpringBoot应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), <span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>@SpringBootConfiguration</strong>：标注SpringBoot的配置类</p><ul><li><strong>@Configuration</strong>：标注配置类（Spring）</li></ul></li><li><p><strong>@EnableAutoConfiguration</strong>：开启自动配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;...&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>@AutoConfigurationPackage</strong>：自动配置包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;Registrar.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line">    Registrar() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AutoConfigurationPackages.register(registry, (<span class="keyword">new</span> AutoConfigurationPackages.PackageImport(metadata)).getPackageName());</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> AutoConfigurationPackages.PackageImport(metadata));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>**将主配置类所在包及下面所有子包里面的所有组件扫描到Spring容器。**</code></pre><ul><li><p><strong>@Import</strong>({AutoConfigurationImportSelector.class})</p><p>AutoConfigurationImportSelector：导入哪些组件的选择器。</p><p>将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。</p><p>会给容器中导入非常多的自动配置类（xxxAutoConfiguration），就是给容器中导入这个场景需要的所有组件，并配置好这些组件。</p><p>Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。以前我们需要自己配置的东西，自动配置类都帮我们。</p></li></ul><h2 id="使用Spring-Initializer快速创建SpringBoot项目"><a href="#使用Spring-Initializer快速创建SpringBoot项目" class="headerlink" title="使用Spring Initializer快速创建SpringBoot项目"></a>使用Spring Initializer快速创建SpringBoot项目</h2><p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目<br>选择我们需要的模块；向导会联网创建Spring Boot项目<br>默认生成的Spring Boot项目</p><ul><li><p>主程序已经生成好了，我们只需要我们自己的逻辑</p></li><li><p>resources文件夹中目录结构</p><ul><li><p>static：保存所有的静态资源(js/css/images)</p></li><li><p>templates：保存所有的模板页面(SpringBoot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面，可以使用模板引擎(如：freemarker、thymeleaf))</p></li><li><p>application.properties：SpringBoot应用的配置文件，可以修改一些默认设置</p></li></ul></li></ul><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><p>Spring Boot使用全局配置文件，配置文件名是固定的：</p><ul><li><strong>application.properties</strong></li><li><strong>application.yml</strong></li></ul><p>配置文件作用：修改Spring Boot在底层封装好的默认值。</p><blockquote><p>YAML（YAML AIN’T Markup Language）：</p><p>是一个标记语言，</p><p>又不是一个标记语言。</p></blockquote><p>以前的配置文件，大多数使用的是 <strong>xxx.xml</strong>文件。</p><p>yaml以<strong>数据</strong>为中心，比json、xml等更适合做配置文件。</p><ul><li><p>YMAL：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">9000</span></span><br></pre></td></tr></table></figure></li><li><p>xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">port</span>&gt;</span>9000<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h2><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p><strong>k:(空格)v</strong>:表示一堆键值对（<strong>空格必须有</strong>）；</p><p>以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一层级的：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/hello</span></span><br></pre></td></tr></table></figure><p>属性和值也是大小写敏感。</p><h3 id="值的写法"><a href="#值的写法" class="headerlink" title="值的写法"></a>值的写法</h3><p><strong>字面量：普通的值（数字，字符串，布尔）</strong></p><p>k: v:字面量直接来写</p><ul><li><p>字符串默认不用加上单引号或者双引号</p></li><li><p>“”:<strong>双引号</strong>  不会转义字符串里的特殊字符；特殊字符会作为本身想要表示的意思如：<code>name:&quot;zhangsan\n lisi&quot;</code>  输出：<code>zhangsan换行 lisi</code></p></li><li><p>‘’:<strong>单引号</strong>  会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p><p>如：<code>name:&#39;zhangsan\n lisi&#39;</code>  输出：<code>zhangsan\n lisi</code></p></li><li><p><strong>对象、Map（属性和值）键值对</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">frends:</span></span><br><span class="line"><span class="attr">    lastName:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></li></ul><p>  行内写法：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">friends:</span> <span class="string">&#123;lastName:</span> <span class="string">zhangsan,age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>数组（List、Set）:</strong> 用-表示数组中的一个元素</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line">    <span class="string">‐</span> <span class="string">cat</span></span><br><span class="line">    <span class="string">‐</span> <span class="string">dog</span></span><br><span class="line">    <span class="string">‐</span> <span class="string">pig</span></span><br></pre></td></tr></table></figure></li></ul><p>  行内写法：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>组合变量</strong>：</p><p>多个组合到一起</p></li></ul><h2 id="配置文件值注入"><a href="#配置文件值注入" class="headerlink" title="配置文件值注入"></a>配置文件值注入</h2><h3 id="ConfigurationProperties"><a href="#ConfigurationProperties" class="headerlink" title="@ConfigurationProperties"></a>@ConfigurationProperties</h3><ol><li><p>application.yml 配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">person:</span></span><br><span class="line"><span class="attr">  age:</span> <span class="number">18</span></span><br><span class="line"><span class="attr">  boss:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  birth:</span> <span class="number">2017</span><span class="string">/12/12</span></span><br><span class="line"><span class="attr">  maps:</span> <span class="string">&#123;k1:</span> <span class="string">v1,k2:</span> <span class="number">12</span><span class="string">&#125;</span></span><br><span class="line"><span class="attr">  lists:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">lisi</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">zhaoliu</span></span><br><span class="line"><span class="attr">  dog:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">wangwang</span></span><br><span class="line"><span class="attr">    age:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  last-name:</span> <span class="string">wanghuahua</span></span><br></pre></td></tr></table></figure></li><li><p>application.properties 配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">person.age=12</span><br><span class="line">person.boss=false</span><br><span class="line">person.last-name=张三</span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=v2</span><br><span class="line">person.lists=a,b,c</span><br><span class="line">person.dog.name=wanghuahu</span><br><span class="line">person.dog.age=15</span><br></pre></td></tr></table></figure></li></ol><p>   idea配置文件编码为utf-8，properties文件编码默认GBK，所以中文输出乱码。</p><p>   解决方法：settings → file encoding → [property → utf-8，勾选转成ascii]</p><ol start="3"><li><p>javaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将配置文件的配置每个属性的值，映射到组件中</span></span><br><span class="line"><span class="comment">* <span class="doctag">@ConfigurationProperties</span>:告诉SpringBoot将文本的所有属性和配置文件中的相关配置进行绑定</span></span><br><span class="line"><span class="comment">* prefix = "person" 与配置文件进行一一映射</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 只有这个组件是容器中的组件，才能提供到容器中</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; lists;</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   导入配置文件处理器，以后编写配置就有提示了</p>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring‐boot‐configuration‐processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 相当于：</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *     &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量/#&#123;spEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/bean&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.last-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;11*2&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"true"</span>)</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件属性</td><td>单个指定</td></tr><tr><td>松散绑定(语法)</td><td>支持</td><td>不支持</td></tr><tr><td>spEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型</td><td>支持</td><td>不支持</td></tr></tbody></table><blockquote><p><strong>松散语法</strong>：javaBean中last-name(或者lastName)  → application.properties中的last-name</p><p><strong>spEL语法</strong>：#{11*2}</p><p><strong>JSR303</strong>：@Value会直接忽略，校验规则</p></blockquote><p><strong>JSR303校验</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Email</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂类型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;bean class="Person"&gt;</span></span><br><span class="line"><span class="comment">     *     &lt;property name="lastName" value="字面量/$&#123;key&#125;从环境变量/#&#123;spEL&#125;"&gt;&lt;/property&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/bean&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Boolean boss;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.maps&#125;"</span>) <span class="comment">// 会报错，@Value不支持复杂类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Object&gt; maps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用场景分析</strong>：</p><ul><li><p>如果我们只是在某个业务逻辑中获取一下配置文件的某一项值，使用@Value</p></li><li><p>如果专门编写了一个javaBean和配置文件进行映射，我们直接使用@ConfigurationProperties</p></li></ul><p>例如：</p><ol><li><p>编写新的Controller文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;person.last-name&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>+ name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">person.age=12</span><br><span class="line">person.boss=false</span><br><span class="line">person.last-name=李四</span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=v2</span><br><span class="line">person.lists=a,b,c</span><br><span class="line">person.dog.name=wanghuahu</span><br><span class="line">person.dog.age=15</span><br></pre></td></tr></table></figure></li><li><p>运行结果</p><p><code>Hello 李四</code></p></li></ol><h3 id="其他注解"><a href="#其他注解" class="headerlink" title="其他注解"></a>其他注解</h3><ul><li><p><strong>@PropertySource</strong>：</p><p><strong>作用</strong>：加载指定的properties配置文件</p><p><strong>举例</strong>：</p><ol><li><p>新建一个person.properties文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">person.age=12</span><br><span class="line">person.boss=false</span><br><span class="line">person.last-name=李四</span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=v2</span><br><span class="line">person.lists=a,b,c</span><br><span class="line">person.dog.name=wanghuahu</span><br><span class="line">person.dog.age=15</span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>在javaBean中加入@PropertySource注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource</span>(value = &#123;<span class="string">"classpath:person.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"person"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li><p><strong>@ImportResource</strong></p><p><strong>作用</strong>：导入Spring配置文件，并且让这个配置文件生效</p><p><strong>举例</strong>：</p><ol><li><p>新建一个Spring的配置文件，bean.xml  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"HelloService"</span> <span class="attr">class</span>=<span class="string">"com.wdjr.springboot.service.HelloService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><ol start="2"><li><p>编写测试类，检查容器是否加载Spring配置文件写的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ApplicationContext ioc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> b = ioc.containsBean(<span class="string">"HelloService"</span>);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>运行结果</p><p>false</p></li><li><p>使用@ImportResource注解</p><p>将@ImportResource标注在主配置类上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ImportResource</span>(locations=&#123;<span class="string">"classpath:beans.xml"</span>&#125;)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBoot02ConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">            SpringApplication.run(SpringBoot02ConfigApplication.class, args)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>运行结果</p><p>true</p></li></ol><p>  <strong>缺点</strong>：每次指定xml文件太麻烦</p><p>  SpringBoot推荐给容器添加组件的方式（@Configuration + @Bean）：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Configuration</span>：指明当前类是一个配置类；就是来代替之前的Spring配置文件</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在配置文件中用&lt;bean&gt;&lt;/bean&gt;标签添加组件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAppConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将方法的返回值添加到容器中,这个组件的id默认为方法名</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"配置类给容器添加了HelloService组件"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ApplicationContext ioc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHelloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> b = ioc.containsBean(<span class="string">"helloService01"</span>);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h2><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;random.value&#125; 、$&#123;random.int&#125;、$&#123;random.long&#125;、</span><br><span class="line">$&#123;random.int(10)&#125;、$&#123;random.int[100,200]&#125;</span><br></pre></td></tr></table></figure><h3 id="获取配置值"><a href="#获取配置值" class="headerlink" title="获取配置值"></a>获取配置值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">person.age=$&#123;random.int&#125;</span><br><span class="line">person.boss=false</span><br><span class="line">person.last-name=张三$&#123;random.uuid&#125;</span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=v2</span><br><span class="line">person.lists=a,b,c</span><br><span class="line">person.dog.name=$&#123;person.last-name&#125;&apos;s wanghuahu</span><br><span class="line">person.dog.age=15</span><br></pre></td></tr></table></figure><p>存在以下两种情况：</p><p>没有声明<code>person.last-name</code>会报错，新声明的需要加默认值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">person.age=$&#123;random.int&#125;</span><br><span class="line">person.boss=false</span><br><span class="line">person.last-name=张三$&#123;random.uuid&#125;</span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=v2</span><br><span class="line">person.lists=a,b,c</span><br><span class="line">person.dog.name=$&#123;person.hello:hello&#125;&apos;s wanghuahu</span><br><span class="line">person.dog.age=15</span><br></pre></td></tr></table></figure><p><strong>输出结果</strong>：<code>hello&#39;s wanghuahua</code></p><h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><h3 id="多Profile文件"><a href="#多Profile文件" class="headerlink" title="多Profile文件"></a>多Profile文件</h3><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml</p><ul><li>application.properties</li><li>application-dev.properties</li><li>application-prod.properties</li></ul><p>默认使用application.properties</p><p>application.properties配置文件指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure><h3 id="YAML文档块"><a href="#YAML文档块" class="headerlink" title="YAML文档块"></a>YAML文档块</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  profiles:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure><h3 id="激活指定profile"><a href="#激活指定profile" class="headerlink" title="激活指定profile"></a>激活指定profile</h3><ol><li><p>在配置文件中激活</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.profiles.active=dev</span><br></pre></td></tr></table></figure></li><li><p>命令行</p><p><code>java -jar xxx.jar --spring.profiles.active=dev</code></p></li><li><p>虚拟机参数</p><p><code>-Dspring.profiles.active=dev</code></p></li></ol><h2 id="加载配置文件位置"><a href="#加载配置文件位置" class="headerlink" title="加载配置文件位置"></a>加载配置文件位置</h2><p>SpringBoot启动扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p><ul><li>file:./config/</li><li>file./</li><li>classpath:/config/</li><li>classpath:/</li></ul><p><strong>优先级从高到低顺序，高优先级会覆盖低优先级的相同配置，互补配置</strong>。</p><p>也可以通过spring.config.location来改变默认配置文件位置 。</p><p><strong>项目打包好了以后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认的配置文件会共同起作用，互补配置</strong>。</p><p><code>java -jar xxx.jar --spring.config.location=E:/work/application.properties</code></p><p><strong>运维比较有用，从外部加载，不用修改别的文件</strong></p><h2 id="外部配置的加载顺序"><a href="#外部配置的加载顺序" class="headerlink" title="外部配置的加载顺序"></a>外部配置的加载顺序</h2><p><strong>SpringBoot也可以从以下位置加载配置，优先级从高到低，高优先级覆盖低优先级，可以互补。</strong></p><ol><li><p>命令行参数</p><p>java -jar xxx.jar –server.port=9005 –server.context-path=/abc</p></li><li><p>来自java:comp/env的JNDI属性</p></li><li><p>java系统属性（System.getProperties()）</p></li><li><p>操作系统环境变量</p></li><li><p>RandomValuePropertySource配置的random.*属性值</p></li><li><p><strong>jar包外部的application-{profile}.properties 或 application.yml(带Spring.profile)配置文件</strong></p></li><li><p><strong>jar包内部的application-{profile}.properties 或 application.yml(带Spring.profile)配置文件</strong></p></li><li><p><strong>jar包外部的application.properties 或 application.yml(带Spring.profile)配置文件</strong></p></li><li><p><strong>jar包内部的application.properties 或 application.yml(不带spring.profile)配置文件</strong></p></li><li><p>@Configuration注解类的@PropertySource</p></li><li><p>通过SpringApplication.setDefaultProperties指定的默认属性</p></li></ol><h2 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">Spring的所有配置参数</a></p><h3 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h3><ol><li><p>SpringBoot启动的时候加载主配置类，开启自动配置功能，@EnableAutoConfiguration</p></li><li><p>@EnableAutoConfiguration 作用：</p><ul><li><p>利用AutoConfigurationImportSelector给容器中导入一些组件？</p></li><li><p>可以查看selectImports()方法的内容</p></li><li><p>List configurations = this.getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置</p><ul><li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames(）</span><br><span class="line">扫描所有jar包类路径下的 MATA-INF/spring.factories</span><br><span class="line">把扫描到的这些文件的内容包装成properties对象</span><br><span class="line">从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加到容器中</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ol><p>   <strong>将类路径下 MATE-INF/spring.factories里面配置的所有的EnableAutoConfiguration的值加入到了容器中。</strong></p><ol start="3"><li><p>每一个自动配置类进行自动配置功能</p></li><li><p>以<strong>HttpEncodingAutoConfiguration</strong> 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">//表示是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;HttpEncodingProperties.class&#125;)<span class="comment">//启动指定类的Configurationproperties功能；将配置文件中的值和HttpEncodingProperties绑定起来了；并把HttpEncodingProperties加入ioc容器中</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span><span class="comment">//根据不同的条件，进行判断，如果满足条件，整个配置类里面的配置就会失效，判断是否为web应用；</span></span><br><span class="line">(</span><br><span class="line">    type = Type.SERVLET</span><br><span class="line">)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123;CharacterEncodingFilter.class&#125;)<span class="comment">//判断当前项目有没有这个类，解决乱码的过滤器</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(</span><br><span class="line">    prefix = <span class="string">"spring.http.encoding"</span>,</span><br><span class="line">    value = &#123;<span class="string">"enabled"</span>&#125;,</span><br><span class="line">    matchIfMissing = <span class="keyword">true</span></span><br><span class="line">)<span class="comment">//判断配置文件是否存在某个配置 spring.http.encoding，matchIfMissing = true如果不存在也是成立，即使不配置也生效</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line">   <span class="comment">//给容器添加组件，这个组件的值需要从properties属性中获取</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HttpEncodingProperties properties;</span><br><span class="line">    <span class="comment">//只有一个有参数构造器情况下，参数的值就会从容器中拿</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(HttpEncodingProperties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line">        filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line">        filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.REQUEST));</span><br><span class="line">        filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.RESPONSE));</span><br><span class="line">        <span class="keyword">return</span> filter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>所有在配置文件中能配置的属性都是在xxxProperties类中封装着，配置文件能配置什么就可以参照某个功能对应的这个属性类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.http.encoding"</span>) <span class="comment">// 从配置文件中的值进行绑定和bean属性进行绑定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingProperties</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ol><p>   根据当前不同条件判断，决定这个配置类是否生效？</p><p>   一旦这个配置类生效；这个配置类会给容器添加各种组件；这些组件的属性是从对应的properties中获取的，这些类里面的每个属性又是和配置文件绑定的。</p><h3 id="所有自动配置组件"><a href="#所有自动配置组件" class="headerlink" title="所有自动配置组件"></a>所有自动配置组件</h3><p>每一个xxxAutoConfiguration这样的类都是容器中的一个组件，都加入到容器中。</p><p>作用：用它们做自动配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityRequestMatcherProviderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration</span><br></pre></td></tr></table></figure><h3 id="精髓"><a href="#精髓" class="headerlink" title="精髓"></a>精髓</h3><ol><li><p><strong>SpringBoot启动会加载大量的自动配置类</strong></p></li><li><p><strong>我们看我们需要的功能有没有SpringBoot默认写好的自动配置类</strong></p></li><li><p><strong>如果有，再看这个自动配置类中配置了哪些组件（只要有需要用的组件，就不需要再手动配置）；如果有，则需要自己手动配置。</strong></p></li><li><p><strong>给容器中自动配置添加组件的时候，会从properties类中获取属性。我们就可以在配置文件中指定这些属性的值</strong></p></li></ol><p>xxxAutoConfiguration：自动配置类，给容器中添加组件。</p><p>xxxProperties：封装配置文件中的属性。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><ul><li><p>@Conditional派生注解</p><blockquote><p>利用Spring注解版原生的@Conditional注解</p></blockquote><p> 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效。</p></li></ul><table><thead><tr><th>@Conditional派生注解</th><th>作用（判断是否满足当前指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean</td></tr><tr><td>@ConditionalOnMissBean</td><td>容器中不存在指定Bean</td></tr><tr><td>@ConditionalOnExpression</td><td>满足spEL表达式</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean,或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定的资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><ul><li><p>自动配置报告</p><p> 自动配置类必须在一定条件下生效。</p><p> 我们可以通过启用<code>debug=true</code>属性，配置文件，打印自动配合报告，这样就可以知道自动配置类生效。</p><p> 自动配置报告：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">============================</span><br><span class="line">  </span><br><span class="line">CONDITIONS EVALUATION REPORT</span><br><span class="line">============================</span><br><span class="line">  </span><br><span class="line"> Positive matches:（启动的，匹配成功的）</span><br><span class="line"> -----------------</span><br><span class="line">  </span><br><span class="line">   CodecsAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnClass</span> found required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">http</span>.<span class="title">codec</span>.<span class="title">CodecConfigurer</span>'</span>; <span class="meta">@ConditionalOnMissingClass</span> <span class="function">did not find unwanted <span class="title">class</span> <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">   ......</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">Negative matches:（没有启动的，没有匹配成功的）</span></span><br><span class="line"><span class="function">-----------------</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">   ActiveMQAutoConfiguration:</span></span><br><span class="line"><span class="function">      Did not match:</span></span><br><span class="line"><span class="function">         - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' <span class="params">(OnClassCondition)</span></span></span><br><span class="line"><span class="function">   ......</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h2><table><thead><tr><th>日志抽象层</th><th>日志实现</th></tr></thead><tbody><tr><td><del>JCL(Jakarta Commons Logging)</del>  SLF4j(Simple Logging Facade for Java)  <del>jboss-logging</del></td><td>Log4j  <del>JUL(java.util.logging)</del>  Log4j2 Logback</td></tr></tbody></table><p>选用SLF4J + Logback</p><blockquote><p>SpringBoot的底层是Spring框架，使用的JCL，SpringBoot改用了SLF4J。</p></blockquote><h2 id="SLF4J的使用"><a href="#SLF4J的使用" class="headerlink" title="SLF4J的使用"></a>SLF4J的使用</h2><h3 id="如何在系统中使用SLF4J"><a href="#如何在系统中使用SLF4J" class="headerlink" title="如何在系统中使用SLF4J"></a>如何在系统中使用SLF4J</h3><p>以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法。</p><p>应该给系统里面导入slf4j的jar包和logback的实现jar包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="SLF4J具体绑定.png" alt="SLF4J具体绑定" title>                </div>                <div class="image-caption">SLF4J具体绑定</div>            </figure><p>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现框架的配置文件</strong>。</p><h3 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h3><p>如开发a系统（slf4j+logback）：Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis……</p><p>c</p><p><strong>如何让系统中所有日志统一到slf4j？</strong></p><ol><li><p><strong>将系统中其他日志框架排除出去</strong></p></li><li><p><strong>用中间包来替换原有的日志框架</strong></p></li><li><p><strong>导入slf4j的其他实现</strong></p></li></ol><h2 id="SpringBoot日志关系"><a href="#SpringBoot日志关系" class="headerlink" title="SpringBoot日志关系"></a>SpringBoot日志关系</h2><p>SpringBoot的日志功能：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="SpringBoot日志关系.jpg" alt="SpringBoot日志关系" title>                </div>                <div class="image-caption">SpringBoot日志关系</div>            </figure><p>总结：</p><ol><li><p>SpringBoot底层也是使用slf4jJ+logback</p></li><li><p>SpringBoot也把其他日志替换成了slf4j</p></li><li><p>起着commons.loggings的名字其实new的SLF4J替换中间包</p></li><li><p>如果要引入其他框架？一定要把这个框架的默认日志依赖移除掉</p></li></ol><h2 id="日志使用"><a href="#日志使用" class="headerlink" title="日志使用"></a>日志使用</h2><h3 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h3><p>trace-debug-info-warn-error</p><p>可以调整需要的日志级别进行输出，不用注释语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录器</span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 日志的级别</span></span><br><span class="line">    <span class="comment">// 从低到高</span></span><br><span class="line">    <span class="comment">// 可以调整输出的日志级别；日志就只会在这个级别以后的高级别生效</span></span><br><span class="line">    logger.trace(<span class="string">"这是trace日志"</span>);</span><br><span class="line">    logger.debug(<span class="string">"这是debug信息"</span>);</span><br><span class="line">    <span class="comment">// SpringBoot默认给的是info级别，如果没指定就是默认的root级别</span></span><br><span class="line">    logger.info(<span class="string">"这是info日志"</span>);</span><br><span class="line">    logger.warn(<span class="string">"这是warn信息"</span>);</span><br><span class="line">    logger.error(<span class="string">"这是Error信息"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调整指定包的日志级别在配置文件中进行配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.com.gxk</span>=trace</span><br></pre></td></tr></table></figure><p>日志输出格式：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#控制台输出的日志格式 </span></span><br><span class="line"><span class="comment">#%d：日期</span></span><br><span class="line"><span class="comment">#%thread：线程号 </span></span><br><span class="line"><span class="comment">#%-5level：靠左 级别 </span></span><br><span class="line"><span class="comment">#%logger&#123;50&#125;：全类名50字符限制,否则按照句号分割</span></span><br><span class="line"><span class="comment">#%msg：消息+换行</span></span><br><span class="line"><span class="comment">#%n：换行</span></span><br><span class="line"><span class="attr">logging.pattern.console</span>=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-<span class="number">5</span>level %logger&#123;<span class="number">50</span>&#125; - %msg%n</span><br></pre></td></tr></table></figure><p>SpringBoot修改日志的默认配置：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging.level.com.gxk</span>=trace</span><br><span class="line"><span class="comment">#不指定path就是当前目录下生成springboot.log</span></span><br><span class="line"><span class="comment">#logging.file=springboot.log</span></span><br><span class="line"><span class="comment">#当前磁盘下根路径创建spring文件中log文件夹，使用spring.log作为默认</span></span><br><span class="line"><span class="attr">logging.path</span>=/spring/log</span><br><span class="line"><span class="comment">#控制台输出的日志格式 日期 + 线程号 + 靠左 级别 +全类名50字符限制+消息+换行</span></span><br><span class="line"><span class="attr">logging.pattern.console</span>=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-<span class="number">5</span>level %logger&#123;<span class="number">50</span>&#125; - %msg%n</span><br><span class="line"><span class="comment">#指定文件中日志输出的格式</span></span><br><span class="line"><span class="attr">logging.pattern.file</span>=xxx</span><br></pre></td></tr></table></figure><h3 id="指定配置"><a href="#指定配置" class="headerlink" title="指定配置"></a>指定配置</h3><p>给类路径下放上每个日志框架自己的配置文件，SpringBoot就不会使用默认的配置</p><table><thead><tr><th>logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>,<code>logback-spring.groovy</code>,<code>logback.xml</code> or <code>logback.groovy</code></td></tr><tr><td>Log4J2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK(Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table><p><code>logback.xml</code>直接被logback日志框架识别 ，<code>logback-spring.xml</code>先由SpringBoot识别。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用参数 <code>--spring.profiles.active=dev</code>运行，即使用这段配置。</p><h3 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h3><ol><li><p>logback → log4j</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">        &lt;exclusion&gt;</span><br><span class="line">            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;</span><br><span class="line">            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;</span><br><span class="line">        &lt;/exclusion&gt;</span><br><span class="line">    &lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li><li><p>切换为log4j2的starter</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Springboot入门&quot;&gt;&lt;a href=&quot;#Springboot入门&quot; class=&quot;headerlink&quot; title=&quot;Springboot入门&quot;&gt;&lt;/a&gt;Springboot入门&lt;/h1&gt;&lt;h2 id=&quot;SpringBoot简介&quot;&gt;&lt;a href=&quot;#S
      
    
    </summary>
    
      <category term="Java" scheme="https://gxkord.github.io/categories/Java/"/>
    
    
      <category term="SpringBoot" scheme="https://gxkord.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>第7章 指令系统</title>
    <link href="https://gxkord.github.io/2019/06/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC7%E7%AB%A0%20%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"/>
    <id>https://gxkord.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/</id>
    <published>2019-06-17T06:24:00.000Z</published>
    <updated>2019-06-18T10:16:32.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器指令"><a href="#机器指令" class="headerlink" title="机器指令"></a>机器指令</h1><ul><li><p><strong>机器指令</strong>：每一条机器语言的语句。</p></li><li><p><strong>指令系统</strong>：全部机器指令的集合。</p></li></ul><blockquote><ul><li><p>指令的格式是什么</p><ul><li>指令码 地址码 寻址方式</li></ul></li><li><p>指令的字长</p><ul><li>固定长度、可变字长</li></ul></li></ul></blockquote><h2 id="指令的一般格式"><a href="#指令的一般格式" class="headerlink" title="指令的一般格式"></a>指令的一般格式</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="指令的一般格式.jpg" alt="指令的一般格式" title>                </div>                <div class="image-caption">指令的一般格式</div>            </figure><ol><li><p>操作码（反映机器做说明操作）</p><p>(1) <strong>长度固定</strong></p><p>用于指令字长较长的情况，<em>RISC</em></p><p>如 <em>IBM 370</em>，操作码八位</p><p>(2) <strong>长度可变</strong></p><p>操作码分散在指令字的不同字段中。</p><p>(3) <strong>扩展操作码技术</strong></p><p><strong>操作码的位数随地址数的减少而增加</strong></p><p><img src="%E4%B8%80%E7%A7%8D%E6%89%A9%E5%B1%95%E6%93%8D%E4%BD%9C%E7%A0%81%E7%9A%84%E5%AE%89%E6%8E%92%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="一种扩展操作码的安排示意图"></p><p>三地址指令操作码每减少一种最多可多构成$2^4$种二地址指令；</p><p>二地址指令操作码每减少一种最多可多构成$2^4$种一地址指令。</p><blockquote><p><strong>思考</strong>：若给定一个指令集，要求对指令集中的指令的操作码进行编码，哪些指令的操作码用长操作码表示，哪些指令的操作码用短操作码表示？</p><p><strong>答</strong>：一般在程序执行过程中，经常出现的高频指令可以用短操作码来表示，低频指令用长操作码表示。</p></blockquote></li><li><p>地址码</p><p>(1) <strong>四地址</strong></p><p><img src="%E5%9B%9B%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.jpg" alt="四地址指令"></p><p>$A_1$第一操作数地址</p><p>$A_2$第二操作数地址</p><p>$A_3$结果的地址</p><p>$A_4$下一条指令的地址</p><p>$(A_1)OP(A_2)→A_3$</p><p>设指令字长为32位，操作码固定为8位，4个地址字段各占6位，寻址范围为$2^6=64$。如果地址字段均指示内存的地址，则完成一条四地址指令，共需<strong>4次访存</strong>（取指令一次，取两个操作码两次，存放结果一次）。</p><blockquote><p>程序计数器PC既能存放当前欲执行的指令的地址，又有计数功能，因此它能自动形成下一条指令的地址。这样，指令字中的第四地址字段$A_4$便可省去，即得<strong>三地址指令</strong>格式。</p></blockquote><p>(2) <strong>三地址</strong></p><p><img src="%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.jpg" alt="三地址指令"></p><p>$(A_1)OP(A_2)→A_3$</p><p><strong>4次访存</strong>，寻址范围$2^8=256$</p><blockquote><p>机器在运行过程中，没必要将每次运行结果都存入主存，中间结果可以暂时存放在CPU的寄存器（如ACC）中，这样又省去一个地址字段$A_3$，从而得出<strong>二地址指令</strong>。</p></blockquote><p>(3) <strong>二地址</strong></p><p><img src="%E4%BA%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4.jpg" alt="二地址指令"></p><p>$(A_1)OP(A_2)→A_1$ 或 $(A_1)OP(A_2)→A_2$：<strong>4次访存</strong></p><p>$(A_1)OP(A_2)→ACC$：<strong>3次访存</strong></p><p>寻址范围$2^{12}=4K$</p><blockquote><p>如果将一个操作数的地址隐含在运算器的ACC中，则指令字中只需给出一个地址码，构成<strong>一地址指令</strong>。</p></blockquote><p>(4) <strong>一地址</strong></p><p>$(ACC)OP(A_1)→ACC$</p><p><strong>2次访存</strong></p><p>寻址范围$2^{24}=16M$</p><p>(5) <strong>零地址</strong></p><p>在指令字中无地址码，例如，空地址（NOP）、停机（HLT）这类指令只有操作码。而子程序返回（RET）、中断返回（IRET）这类指令没有地址码，其操作数的地址隐含在堆栈指针SP中。</p></li></ol><h2 id="指令字长"><a href="#指令字长" class="headerlink" title="指令字长"></a>指令字长</h2><p>$$<br>指令字长决定于\begin{cases}操作码的长度\操作数地址的长度\操作数地址的个数\end{cases}<br>$$</p><ol><li><p>指令字长<strong>固定</strong></p><p>指令字长 = 存储字长</p></li><li><p>指令字长<strong>可变</strong></p><p>按字节的倍数变化</p></li></ol><h1 id="操作数类型和操作种类"><a href="#操作数类型和操作种类" class="headerlink" title="操作数类型和操作种类"></a>操作数类型和操作种类</h1><h2 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h2><p>地址：无符号整数</p><p>数字：定点数、浮点数、十进制数</p><p>字符：ASCII</p><p>逻辑数：逻辑运算</p><h2 id="数据在存储器中的存放方式"><a href="#数据在存储器中的存放方式" class="headerlink" title="数据在存储器中的存放方式"></a>数据在存储器中的存放方式</h2><p><strong>例</strong>：12345678H的存放方式</p><p>(1) <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="大端、大尾方式.jpg" alt="大端、大尾方式" title>                </div>                <div class="image-caption">大端、大尾方式</div>            </figure></p><p>(2) <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="小端、小尾方式.jpg" alt="小端、小尾方式" title>                </div>                <div class="image-caption">小端、小尾方式</div>            </figure></p><p>字节编址，数据在存储器中的存放方式</p><ol><li><p>从任意位置开始存储</p><p> <img src="%E4%BB%8E%E4%BB%BB%E6%84%8F%E4%BD%8D%E7%BD%AE%E5%BC%80%E5%A7%8B%E5%AD%98%E5%82%A8.jpg" alt="从任意位置开始存储"></p><ul><li><p>优点：不浪费存储资源。</p></li><li><p>缺点：除了访问一个字节之外，访问其它任何类型的数据都可能花费两个存储周期的时间。读写控制比较复杂。</p></li></ul></li><li><p>从一个存储字的起始位置开始访问</p><p><img src="%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E5%AD%97%E7%9A%84%E8%B5%B7%E5%A7%8B%E4%BD%8D%E7%BD%AE%E5%BC%80%E5%A7%8B%E8%AE%BF%E9%97%AE.jpg" alt="从一个存储字的起始位置开始访问"></p><ul><li><p>优点：无论访问何种类型的数据，在一个周期内均可完成，读写控制简单。</p></li><li><p>缺点：严重浪费存储资源。</p></li></ul></li><li><p>边界对准方式——从地址的整数倍位置开始访问</p><p><img src="%E8%BE%B9%E7%95%8C%E5%AF%B9%E5%87%86%E6%96%B9%E5%BC%8F.jpg" alt="边界对准方式"></p><p>数据存放的起始地址是数据长度（按照编址单位进行计算）的整数倍。</p><p>本方案是前两个方案的折衷，在一个周期内可以完成存储访问，空间浪费也不太严重。</p></li></ol><h2 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h2><ol><li>数据传输</li></ol><table><thead><tr><th>源</th><th>目的</th><th>例如</th></tr></thead><tbody><tr><td>寄存器</td><td>寄存器</td><td>MOVE</td></tr><tr><td>寄存器</td><td>存储器</td><td>STORE/MOVE/PUSH</td></tr><tr><td>存储器</td><td>寄存器</td><td>LOAD/MOVE/POP</td></tr><tr><td>存储器</td><td>存储器</td><td>MOVE</td></tr></tbody></table><ol start="2"><li><p>算术逻辑操作</p><p>加、减、乘、除、增1、减1、求补、浮点运算、十进制运算、与或、非、异或、位操作、位测试、位清除、位求反等。</p></li><li><p>移位操作</p><p>算术移位 逻辑移位 循环移位（带进位和不带进位）</p></li><li><p>转移</p><p>(1) 无条件转移 <strong>JMP</strong></p><p>(2) 条件转移</p><ul><li><p>结果为零转 (Z=1) <strong>JZ</strong></p></li><li><p>结果溢出转 (O=1) <strong>JO</strong></p></li><li><p>结果有进位转 (C=1) <strong>JC</strong></p></li><li><p>跳过一条指令 <strong>SKP</strong></p></li></ul><p>(3) 调用和返回</p><p><img src="%E8%B0%83%E7%94%A8%E5%92%8C%E8%BF%94%E5%9B%9E%E6%8C%87%E4%BB%A4%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="调用和返回指令示意图"></p><p>(4) 陷阱（Trap）与陷阱指令</p><blockquote><p><strong>意外事故的中断</strong></p></blockquote><ul><li><p>一般不提供给用户直接使用</p><p>在出现事故时，由CPU自动产生并执行（隐指令）</p></li><li><p>设置供用户使用的陷阱指令</p></li></ul></li><li><p>输入输出</p><p>入：端口中的内容 → CPU的寄存器</p><p>出：CPU的寄存器 → 端口的内容</p></li></ol><h1 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h1><p><strong>寻址方式</strong>：确定<strong>本条指令</strong>的<strong>操作数地址</strong>以及<strong>下一条</strong>将要执行的<strong>指令</strong>的<strong>指令地址</strong>的方式，它与硬件结构紧密相关，而且直接影响指令格式和指令功能。</p><p>$$<br>寻址方式\begin{cases}指令寻址\数据寻址\end{cases}<br>$$</p><h2 id="指令寻址"><a href="#指令寻址" class="headerlink" title="指令寻址"></a>指令寻址</h2><ul><li><p>顺序寻址</p><p>$(PC)+1→PC$</p></li><li><p>跳跃寻址</p><p>由转移指令指出</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="指令的寻址方式示意图.jpg" alt="指令的寻址方式示意图" title>                </div>                <div class="image-caption">指令的寻址方式示意图</div>            </figure><h2 id="数据寻址"><a href="#数据寻址" class="headerlink" title="数据寻址"></a>数据寻址</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="一种一地址指令的格式.jpg" alt="一种一地址指令的格式" title>                </div>                <div class="image-caption">一种一地址指令的格式</div>            </figure><p><strong>形式地址</strong>：指令字中的地址</p><p><strong>有效地址</strong>：操作数的真实地址</p><p>约定：<strong>指令字长 = 存储字长 = 机器字长</strong></p><ol><li><p>立即寻址</p><p><strong>形式地址A就是操作数</strong></p><p><img src="%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80.jpg" alt="立即寻址示意图"></p><p>数据采用补码的形式存放。</p><ul><li><p><strong>指令执行阶段不访存</strong></p></li><li><p><strong>A的位数限制了立即数的范围</strong></p></li></ul></li><li><p>直接寻址</p><p>$EA=A$</p><p><strong>有效地址由形式地址直接给出</strong></p><p><img src="%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.jpg" alt="直接寻址示意图"></p><ul><li><p><strong>执行阶段访问一次存储器</strong></p></li><li><p><strong>A的位数决定了该指令操作数的寻址范围</strong></p></li><li><p><strong>操作数的地址不易修改（必须修改A）</strong></p></li></ul></li><li><p>隐含寻址</p><p><strong>操作数地址隐含在操作码中</strong></p><p><img src="%E9%9A%90%E5%90%AB%E5%AF%BB%E5%9D%80.jpg" alt="隐含寻址示意图"></p><ul><li><strong>指令字中少了一个地址字段，可缩短指令字长</strong></li></ul></li><li><p>间接寻址</p><p>$EA=(A)$ </p><p><strong>有效地址由形式地址间接提供</strong></p><p><img src="%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.jpg" alt="间接寻址示意图"></p><ul><li><p><strong>执行指令阶段 2次访寻</strong></p></li><li><p><strong>可扩大寻址范围</strong></p></li><li><p><strong>便于编制程序</strong></p></li></ul></li><li><p>寄存器寻址</p><p>$EA=R_i$</p><p><strong>有效地址即为寄存器编号</strong></p><p><img src="%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80.jpg" alt="寄存器寻址示意图"></p><ul><li><p><strong>执行阶段不访存，只访问寄存器，执行速度快</strong></p></li><li><p><strong>寄存器个数有限，可缩短指令字长</strong></p></li></ul></li><li><p>寄存器间接寻址</p><p>$EA=(R_i)$</p><p><strong>有效地址在寄存器中</strong></p><p><img src="%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80.jpg" alt="寄存器间接寻址示意图"></p><ul><li><p><strong>有效地址在寄存器中，操作数在存储器中，执行阶段访存1次</strong></p></li><li><p><strong>便于编写循环程序</strong></p></li></ul></li><li><p>基址寻址</p><p>(1) 采用专用寄存器作基址寄存器</p><p>$EA=(BR)+A$</p><p><strong>BR为基址寄存器</strong></p><p><img src="%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80-%E4%B8%93%E7%94%A8%E5%9F%BA%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8BR.jpg" alt="专用基址寄存器BR"></p><ul><li><p><strong>可扩大寻址范围</strong></p></li><li><p><strong>有利于多道程序</strong></p></li><li><p><strong>BR内容由操作系统或管理程序确定</strong></p></li><li><p><strong>在程序的执行过程中BR内容不变，形式地址A可变</strong></p></li></ul><p>(2) 采用通用寄存器作基址寄存器</p><p><img src="%E5%9F%BA%E5%9D%80%E5%AF%BB%E5%9D%80-%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt="通用寄存器作基址寄存器"></p><ul><li><p><strong>由用户指定哪个通用寄存器作为基址寄存器</strong></p></li><li><p><strong>基址寄存器的内容由操作系统确定</strong></p></li><li><p><strong>在程序的执行过程中$R_0$内容不变，形式地址A可变</strong></p></li></ul></li><li><p>变址寻址</p><p>$EA=(IX)+A$ </p><p><strong>IX为变址寄存器（专用）</strong></p><p><strong>通用寄存器也可以作为变址寄存器</strong></p><p><img src="%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80.jpg" alt="变址寻址示意图"></p><ul><li><p><strong>可扩大寻址范围</strong></p></li><li><p><strong>IX的内容由用户给定</strong></p></li><li><p><strong>在程序的执行过程中IX内容可变，形式地址A不变</strong></p></li><li><p><strong>便于处理数组问题</strong></p></li></ul></li><li><p>相对寻址</p><p>$EA=(PC)+A$</p><p>A是相对于当前指令的位移量（可正可负，补码）</p><p><img src="%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80.jpg" alt="相对寻址示意图"></p><ul><li><p><strong>A的位数决定操作数的寻址范围</strong></p></li><li><p><strong>程序浮动</strong></p></li><li><p><strong>广泛用于转移指令</strong></p></li></ul></li><li><p>堆栈寻址</p><p>(1) 堆栈的特点</p><p>$$<br>堆栈\begin{cases}硬堆栈\ \ 多个寄存器\软堆栈\ \ 指定的存储空间\end{cases}<br>$$</p><p><strong>先进后出</strong>（一个入出口）</p><p><strong>栈顶地址</strong>由<strong>SP</strong>指出</p><p>$进栈(SP)-1→SP$</p><p>$出栈(SP)+1→SP$</p><p>(2) 堆栈寻址举例</p><p><img src="%E5%A0%86%E6%A0%88%E5%AF%BB%E5%9D%80%E4%B8%BE%E4%BE%8B.jpg" alt="堆栈寻址举例"></p><p>(3) SP的修改与主存编址方法有关</p><p>① 按<strong>字</strong>编址</p><p>$进栈(SP)-1→SP$</p><p>$进栈(SP)+1→SP$</p><p>② 按<strong>字节</strong>编址</p><ul><li><p>存储字长<strong>16</strong>位：</p><p>$进栈(SP)-2→SP$</p><p>$进栈(SP)+2→SP$</p></li><li><p>存储字长<strong>32</strong>位：</p><p>$进栈(SP)-4→SP$</p><p>$进栈(SP)+4→SP$</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器指令&quot;&gt;&lt;a href=&quot;#机器指令&quot; class=&quot;headerlink&quot; title=&quot;机器指令&quot;&gt;&lt;/a&gt;机器指令&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;机器指令&lt;/strong&gt;：每一条机器语言的语句。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;s
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://gxkord.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成原理" scheme="https://gxkord.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第6章 计算机的运算方法</title>
    <link href="https://gxkord.github.io/2019/05/03/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC6%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95/"/>
    <id>https://gxkord.github.io/2019/05/03/计算机基础/计算机组成原理/第6章 计算机的运算方法/</id>
    <published>2019-05-03T06:00:00.000Z</published>
    <updated>2019-06-27T10:59:05.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无符号数和有符号数"><a href="#无符号数和有符号数" class="headerlink" title="无符号数和有符号数"></a>无符号数和有符号数</h1><h2 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h2><p>寄存器的位数反映无符号数的表示范围。</p><h2 id="有符号数"><a href="#有符号数" class="headerlink" title="有符号数"></a>有符号数</h2><h3 id="机器数与真值"><a href="#机器数与真值" class="headerlink" title="机器数与真值"></a>机器数与真值</h3><table><thead><tr><th>真值</th><th>机器数</th></tr></thead><tbody><tr><td>带符号的数</td><td>符号数字化的数</td></tr><tr><td><strong>+</strong>0.1011</td><td><strong>0</strong>.1011</td></tr><tr><td><strong>-</strong>0.1011</td><td><strong>1</strong>.1011</td></tr><tr><td><strong>+</strong>1100</td><td><strong>0</strong>,1100</td></tr><tr><td><strong>-</strong>1100</td><td><strong>1</strong>,1100</td></tr></tbody></table><h3 id="原码表示法"><a href="#原码表示法" class="headerlink" title="原码表示法"></a>原码表示法</h3><ol><li><p>定义</p><ul><li><p><strong>整数</strong></p><p>$[x]_原=\begin{cases}0,\ x\quad\quad2^n&gt;x\geq0\2^n-x\quad\quad0\geq x&gt;-2^n\end{cases}$</p><p>x为真值，n为整数的位数。</p><p><strong>使用逗号（,）将符号位与数值部分隔开。</strong></p><p>如：</p><ul><li><p>$x=+1110\quad[x]_原=0,1110$</p></li><li><p>$x=-1110\quad[x]_原=2^4+1110=1,1110$</p></li></ul></li><li><p><strong>小数</strong></p><p>$[x]_原=\begin{cases}x\quad\quad1&gt;x\geq0\1-x\quad\quad0\geq x&gt;-1\end{cases}$</p><p>x为真值。</p><p><strong>使用小数点（.）将符号位与数值部分隔开。</strong></p><p>如：</p><ul><li><p>$x=+0.1101\quad[x]_原=0.1101$</p></li><li><p>$x=-0.1101\quad[x]_原=1-(-0.1101)=1.1101$</p></li><li><p>$x=+0.1000000\quad[x]_原=0.1000000$</p></li></ul></li></ul><blockquote><p>特别地：</p><ul><li><p>当$x=0$时，</p><p>$[+0.0000]_原=0.0000$</p><p>$[-0.0000]_原=1-(0.0000)=1.0000$</p><p>可见，$[+0]_原\neq[-0]_原$，即原码中的“零”有两种表示形式</p></li><li><p>当$x=-1$时，</p><p>x不存在原码。（因为按照定义来看，-1和0地补码都为1）</p></li></ul></blockquote></li><li><p>特点</p><p>简单、直观。</p><p>但是用原码作加法时，会出现如下问题：</p></li></ol><table><thead><tr><th>要求</th><th>数1</th><th>数2</th><th>实际操作</th><th>结果符号</th></tr></thead><tbody><tr><td>加法</td><td>正</td><td>正</td><td><strong>加</strong></td><td>正</td></tr><tr><td>加法</td><td>正</td><td>负</td><td><strong>减</strong></td><td>可正可负</td></tr><tr><td>加法</td><td>负</td><td>正</td><td><strong>减</strong></td><td>可正可负</td></tr><tr><td>加法</td><td>负</td><td>负</td><td><strong>加</strong></td><td>负</td></tr></tbody></table><blockquote><p>能否<strong>只作加法</strong>？</p><p><strong>找到一个与负数等价的正数来代替这个负数</strong>，就可使<strong>减→加</strong>。（补码）</p></blockquote><h3 id="补码表示法"><a href="#补码表示法" class="headerlink" title="补码表示法"></a>补码表示法</h3><ol><li><p>补的概念</p><ul><li><p>一个负数加上<strong>“模”</strong>即得该负数的补数。</p></li><li><p>一个正数和一个负数互为补数时，它们的绝对值之和即为<strong>模</strong>数。</p></li></ul><blockquote><p>如<strong>计数器</strong>（模16），求$1011→0000$？</p><ul><li><p>$1011-1011=0000$</p></li><li><p>$1011+0101=(1)0000$（1超过表示范围，舍去）</p></li></ul><p>可见，-1011可用+0101代替。</p><p>记作：<strong>$-1011\equiv+0101\quad(mod\ 2^4)$</strong></p><p>同理：<strong>$-011\equiv+101\quad(mod\ 2^3)$</strong></p><p><strong>$-0.1001\equiv+1.01111\quad(mod\ 2)$</strong></p></blockquote></li><li><p>正数的补码即为其本身</p><p>两个互为补数的数，分别加上模，结果仍互为补数：</p><blockquote><p>例如：$-1011\equiv+0101\quad(mod\ 2^4)$</p><ul><li><p>$-1011+10000=+0101$</p></li><li><p>$+0101+10000=+(1)0101$</p></li></ul><p>所以，<strong>$+0101\equiv+0101\quad(mod\ 2^4)$</strong></p></blockquote><p>可见，<strong>+0101既可作+0101的补码，又可做-1011的补码</strong>。</p><p>为了区分，需要为补码添加其原码的符号位：</p><ul><li><p><strong>0</strong>,0101→<strong>+</strong>0101</p></li><li><p><strong>1</strong>,0101→<strong>-</strong>1011</p></li><li><p><strong>如何得到？</strong></p><p>只需增加一位模，即</p><p>$2^{4+1}-1011=100000-1011=1,0101$</p><p>$2^{4+1}+0101=100000+0101=(1)0,0101$</p></li></ul></li><li><p>补码的定义</p><ul><li><p>整数</p><p>$[x]_补=\begin{cases}0,\ x\quad\quad2^n&gt;x\geq0\2^{n+1}+x\quad\quad0&gt;x\geq-2^n\ (mod\ 2^{n+1})\end{cases}$</p><p>x为真值，n为整数的位数。</p><p>如：</p><ul><li><p>$x=+1010\quad[x]_补=0,1010$</p></li><li><p>$x=-1011000\quad[x]_补=2^{7+1}+(-1011000)$</p></li></ul></li><li><p>小数</p><p>$[x]_补=\begin{cases}x\quad\quad1&gt;x\geq 0\2+x\quad\quad0&gt;x\geq-1\ (mod\ 2)\end{cases}$</p><p>如：</p><ul><li><p>$x=+0.1110\quad[x]_补=0.1110$</p></li><li><p>$x=-0.1100000\quad[x]_补=2+(-0.1100000)=10.0000000-0.1100000=1.0100000$</p></li></ul></li></ul></li><li><p>求补码的快捷方式</p><p>设$x=-1010$，</p><p>则$[x]_补=2^{4+1}-1010=100000-1010=1,0110$</p><p>$=11111+1-1010=10101+1=1,0110$</p><p>又$[x]_原=1,1010$</p><p>当真值为<strong>负</strong>时，<strong>补码</strong>可用<strong>原码除符号位外每位取反，末位加1求得</strong>。</p></li><li><p>举例</p><ul><li><p>已知$[x]_补=0.0001$，求x</p><p>解：由定义得 $x=+0.0001$</p></li><li><p>已知$[x]_补=1.0001$，求x</p><p>解：方法(1)：由定义得 $x=[x]_补-2=1.0001-10.0000=-0.1111$</p><p>方法(2)：$[x]_原=1.1111,则x=-0.1111$</p></li><li><p>已知$[x]_补=1,1110，求x$</p><p>解：方法(1)：由定义得 $x=[x]_补-2^{4+1}=1,1110-100000=-0010$</p><p>方法(2)：$[x]_原=1,0010，则x=-0010$</p></li></ul><p>当真值为<strong>负</strong>时，<strong>原码</strong>可用<strong>补码除符号位外每位取反，末位加1求得</strong>。</p><blockquote><p>特别地：</p><ul><li><p>当$x=0$时，</p><p>$[+0.0000]_补=[-0.0000]_补=0.0000$</p></li><li><p>当$x=-1$时，</p><p>$[-1]_补=2+x=10.000-1.0000=1.0000$</p><p>（但无原码）</p></li></ul></blockquote></li></ol><h3 id="反码表示法"><a href="#反码表示法" class="headerlink" title="反码表示法"></a>反码表示法</h3><ol><li><p>定义</p><ul><li><p>整数</p><p>$[x]_反=\begin{cases} 0,x\quad 2^n&gt;x\geq0\\ (2^{n+1}-1)+x\quad 0\geq x&gt;-2^n(mod2^{n+1}-1)\end{cases}$</p><p>x为真值，n为整数的位数</p><p>如：</p><ul><li><p>$x=+1101\quad [x]_反=0,1101$</p></li><li><p>$x=-1101\quad [x]_反=(2^{4+1}-1)-1101=11111-1101=1,0010$</p></li></ul></li><li><p>小数</p><p>$[x]_反=\begin{cases} x\quad 1&gt;x\geq 0 \\ (2-2^{-n})+x\quad 0\geq x&gt;-1(mod\ 2-2^{-n})\end{cases}$</p><p>如：</p><ul><li><p>$x=+0.1101\quad[x]_反=0.1101$</p></li><li><p>$x=-0.1010\quad[x]_反=(2-2^{-4})-0.1010=1.1111-0.1010=1.0101$</p></li></ul></li></ul></li><li><p>举例</p><ul><li><p>已知$[x]_反=0,1110，求x$</p><p>解：$x=+1110$</p></li><li><p>已知$[x]_反=1,1110$，求x</p><p>解：$x=-0001$</p></li></ul><blockquote><p>特别地：</p><p>当$x=0$时，</p><p>设$x=+0.0000$，则$[+0.0000]_反=0.0000$</p><p>设$x=-0.0000$，则$[-0.0000]_反=1.1111$</p><p>同理，对于整数：$[+0]_反=0,0000$，$[-0]_反=1,1111$</p><p>因此，$[+0]_反\neq[-0]_反$</p></blockquote></li></ol><h3 id="三种机器数的小结"><a href="#三种机器数的小结" class="headerlink" title="三种机器数的小结"></a>三种机器数的小结</h3><ul><li><p><strong>最高位</strong>为<strong>符号位</strong>，书写上用“,”（整数）或“.”（小数）将数值部分和符号位隔开。</p></li><li><p>对于<strong>正数</strong>，<strong>原码=补码=反码</strong>。</p></li><li><p>对于<strong>负数</strong>，<strong>符号位为1</strong>，其<strong>数值部分</strong></p><p><strong>原码除符号位外每位取反末位加1 → 补码</strong></p><p><strong>原码除符号位外每位取反 → 反码</strong></p></li></ul><p><strong>例题1</strong>：设机器字长为8位（其中1位为符号位），对于正数，当其分别代表无符号数、原码、补码和反码时，对应的真值范围各为多少？</p><p><strong>解</strong>：</p><table><thead><tr><th>二进制代码</th><th>无符号数的对应真值</th><th>原码</th><th>补码</th><th>反码</th></tr></thead><tbody><tr><td>00000000</td><td>0</td><td>+0</td><td><strong>$\pm0$</strong></td><td>+0</td></tr><tr><td>00000001</td><td>1</td><td>+1</td><td>+1</td><td>+1</td></tr><tr><td>00000010</td><td>2</td><td>+2</td><td>+2</td><td>+2</td></tr><tr><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td></tr><tr><td>01111111</td><td>127</td><td>+127</td><td>+127</td><td>+127</td></tr><tr><td>10000000</td><td>128</td><td>-0</td><td><strong>-128</strong></td><td>-127</td></tr><tr><td>10000001</td><td>129</td><td>-1</td><td>-127</td><td>-126</td></tr><tr><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td></tr><tr><td>11111101</td><td>253</td><td>-125</td><td>-3</td><td>-2</td></tr><tr><td>11111110</td><td>254</td><td>-126</td><td>-2</td><td>-1</td></tr><tr><td>11111111</td><td>255</td><td>-127</td><td>-1</td><td>-0</td></tr></tbody></table><p><strong>例题2</strong>：已知$[y]_补$，求$[-y]_补$。</p><p><strong>解</strong>：设$[y]_补=y_0.y_1y_2\ldots y_n$</p><ul><li><p>若y为正数，$[y]_补=0.y_1y_2\ldots y_n$</p><p>则$y=0.y_1y_2\ldots y_n$</p><p>$-y=-0.y_1y_2\ldots y_n$</p><p>得$[-y]_补=1.\overline{y_1}\overline{y_2}\ldots\overline{y_n}+2^{-n}$</p><blockquote><p><strong>$[y]_补$连同符号位在内，每位取反，末位加1，即得$[-y]_补$。</strong></p></blockquote></li><li><p>若y为负数，$[y]_补=1.y_1y_2\ldots y_n$</p><p>则$[y]_原=1.\overline{y_1}\overline{y_2}\ldots \overline{y_n}+2^{-n}$</p><p>$y=-(0.\overline{y_1}\overline{y_2}\ldots \overline{y_n}+2^{-n})$</p><p>$-y=0.\overline{y_1}\overline{y_2}\ldots \overline{y_n}+2^{-n}$</p><p>$[-y]_补=0.\overline{y_1}\overline{y_2}\ldots\overline{y_n}+2^{-n}$</p><blockquote><p><strong>$[y]_补$连同符号位在内，每位取反，末位加1，即得$[-y]_补$。</strong></p></blockquote></li></ul><h3 id="移码表示法"><a href="#移码表示法" class="headerlink" title="移码表示法"></a>移码表示法</h3><p><strong>补码表示很难直接判断其真值大小。</strong></p><p>如：</p><table><thead><tr><th>十进制</th><th>二进制</th><th>补码</th></tr></thead><tbody><tr><td>+21</td><td>+10101</td><td>0,10101</td></tr><tr><td>-21</td><td>-10101</td><td>1,01011</td></tr><tr><td>+31</td><td>+11111</td><td>0,11111</td></tr><tr><td>-31</td><td>-11111</td><td>1,00001</td></tr></tbody></table><p>上述补码表示中“,”在计算机内部是不存在的，因此，从代码形式看，符号位也是一位二进制数。按这6位二进制代码比较大小的话，会得出$101011&gt;010101$，$100001&gt;011111$，其实恰恰相反。</p><p>如果每个真值加上一个$2^n$（n为整数的位数），则有：</p><p>$+10101+100000=110101$</p><p>$-10101+100000=001011$</p><p>$+11111+100000=111111$</p><p>$-11111+100000=000001$</p><ol><li><p>定义</p><p>$[x]_移=2^n+x(2^n&gt;x\geq-2^n)$</p><p>x为真值，n为整数的位数</p><p><img src="%E7%A7%BB%E7%A0%81%E5%9C%A8%E6%95%B0%E8%BD%B4%E4%B8%8A%E7%9A%84%E8%A1%A8%E7%A4%BA.jpg" alt="移码在数轴上的表示"></p><p>如：</p><ul><li><p>$x=10100$</p><p>$[x]_移=2^5+10100=1,10100$</p></li><li><p>$x=-10100$</p><p>$[x]_移=2^5-10100=0,01100$</p></li></ul></li><li><p>移码和补码的比较</p><ul><li><p>设 $x=+1100100$</p><p>$[x]_移=2^7+1100100=1,1100100$</p><p>$[x]_补=0,1100100$</p></li><li><p>设 $x=-1100100$</p><p>$[x]_移=2^7-1100100=0,0011100$</p><p>$[x]_补=1,0011100$</p></li></ul><p><strong>补码和移码只差一个符号位。</strong></p></li><li><p>真值、补码和移码的对照表</p><table><thead><tr><th>真值x(n=5)</th><th>$[x]_补$</th><th>$[x]_移$</th><th>$[x]_移对应的十进制整数$</th></tr></thead><tbody><tr><td><strong>-100000</strong></td><td>100000</td><td><strong>000000</strong></td><td>0</td></tr><tr><td>-11111</td><td>100001</td><td>000001</td><td>1</td></tr><tr><td>-11110</td><td>100010</td><td>000010</td><td>2</td></tr><tr><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td></tr><tr><td>-00001</td><td>111111</td><td>011111</td><td>31</td></tr><tr><td><strong>±00000</strong></td><td><strong>000000</strong></td><td><strong>100000</strong></td><td>32</td></tr><tr><td>+00001</td><td>000001</td><td>100001</td><td>33</td></tr><tr><td>+00010</td><td>000010</td><td>100010</td><td>34</td></tr><tr><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td><td>$\ldots$</td></tr><tr><td>+11110</td><td>011110</td><td>111110</td><td>62</td></tr><tr><td><strong>+11111</strong></td><td>011111</td><td><strong>111111</strong></td><td>63</td></tr></tbody></table></li><li><p>移码的特点</p><ul><li><p>当x=0时</p><ul><li><p>$[+0]_移=2^5+0=1,00000$</p></li><li><p>$[-0]_移=2^5-0=1,00000$</p></li></ul><p>$[+0]_移=[-0]_移$</p></li><li><p>当n=5时</p><p>最小真值为$-2^5=-100000$</p><p>$[-100000]_移=2^5-100000=000000$</p><p>可见，<strong>最小真值的移位为全0</strong>。</p></li></ul></li></ol><h1 id="数的定点表示和浮点表示"><a href="#数的定点表示和浮点表示" class="headerlink" title="数的定点表示和浮点表示"></a>数的定点表示和浮点表示</h1><h2 id="定点表示"><a href="#定点表示" class="headerlink" title="定点表示"></a>定点表示</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="小数定点机.jpg" alt="小数定点机" title>                </div>                <div class="image-caption">小数定点机</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="整数定点机.jpg" alt="整数定点机" title>                </div>                <div class="image-caption">整数定点机</div>            </figure><table><thead><tr><th>定点机</th><th>原码</th><th>补码</th><th>反码</th></tr></thead><tbody><tr><td>小数定点机</td><td>$-(1-2^{-n})$~$+(1-2^{-n})$</td><td>$-1$~$+(1-2^{-n})$</td><td>$-(1-2^{-n})$~$+(1-2^{-n})$</td></tr><tr><td>整数定点机</td><td>$-(2^n-1)$~$+(2^n-1)$</td><td>$-2^n$~$+(2^n-1)$</td><td>$-(2^n-1)$~$+(2^n-1)$</td></tr></tbody></table><h2 id="浮点表示"><a href="#浮点表示" class="headerlink" title="浮点表示"></a>浮点表示</h2><ul><li><p>为什么在计算机中要引入浮点数表示？</p><ul><li><p>编程困难，程序员要调节小数点的位置。</p></li><li><p>数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长。</p></li><li><p>数据存储单元的利用率往往很低。</p></li></ul></li><li><p>浮点表示的格式是什么？</p><p>浮点数的一般形式：$N=S×r^j$</p><p><strong>S</strong>：尾数</p><p><strong>j</strong>：阶码</p><p><strong>r</strong>：尾数的基值（计算机中<strong>r</strong>取<strong>2、4、8、16</strong>等）</p><ul><li><p>当$r=2$，</p><p>$N=11.0101=0.110101×2^{10}=1.10101×2^1=1101.01×2^{-10}$</p></li></ul><p>计算机中，<strong>S为小数、可正可负</strong>，<strong>j为整数、可正可负</strong>。</p></li><li><p>尾数和阶码的基值必须是2吗？基值的影响？</p></li><li><p>表数范围与精度和哪些因素有关？</p></li><li><p>为什么要引入规格化表示？</p></li><li><p>目前浮点数表示格式的标准是什么？</p></li></ul><h3 id="浮点数的表示形式"><a href="#浮点数的表示形式" class="headerlink" title="浮点数的表示形式"></a>浮点数的表示形式</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="浮点数的表示形式.jpg" alt="浮点数的表示形式" title>                </div>                <div class="image-caption">浮点数的表示形式</div>            </figure><h3 id="浮点数的表示范围"><a href="#浮点数的表示范围" class="headerlink" title="浮点数的表示范围"></a>浮点数的表示范围</h3><ul><li><p>上溢：阶码&gt;最大阶码</p></li><li><p>下溢：阶码&lt;最小阶码 按<strong>机器零</strong>处理</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="浮点数在数轴上的表示范围.jpg" alt="浮点数在数轴上的表示范围" title>                </div>                <div class="image-caption">浮点数在数轴上的表示范围</div>            </figure><h3 id="浮点数的规格化形式"><a href="#浮点数的规格化形式" class="headerlink" title="浮点数的规格化形式"></a>浮点数的规格化形式</h3><p><strong>基数不同，浮点数的规格化形式不同。</strong></p><ul><li><p>r=2 尾数最高位为1</p></li><li><p>r=4 尾数最高2位不全为0</p></li><li><p>r=8 尾数最高3位不全为0</p></li></ul><h3 id="浮点数的规格化"><a href="#浮点数的规格化" class="headerlink" title="浮点数的规格化"></a>浮点数的规格化</h3><ul><li><p>r=2</p><ul><li><p>左规 尾数左移1位，阶码减1</p></li><li><p>右规 尾数右移1位，阶码加1</p></li></ul></li><li><p>r=4</p><ul><li><p>左规 尾数左移2位，阶码减1</p></li><li><p>右规 尾数右移2位，阶码加1</p></li></ul></li><li><p>r=8</p><ul><li><p>左规 尾数左移3位，阶码减1</p></li><li><p>右规 尾数右移3位，阶码加1</p></li></ul></li></ul><p><strong>基数r越大，可表示的浮点数的范围越大。</strong></p><p><strong>基数r越大，浮点数的精度越低。</strong></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h2 id="IEEE-754-标准"><a href="#IEEE-754-标准" class="headerlink" title="IEEE 754 标准"></a>IEEE 754 标准</h2><h1 id="定点运算"><a href="#定点运算" class="headerlink" title="定点运算"></a>定点运算</h1><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><h3 id="移位运算的数学意义"><a href="#移位运算的数学意义" class="headerlink" title="移位运算的数学意义"></a>移位运算的数学意义</h3><h3 id="算术移位规则"><a href="#算术移位规则" class="headerlink" title="算术移位规则"></a>算术移位规则</h3><h3 id="算术移位的硬件实现"><a href="#算术移位的硬件实现" class="headerlink" title="算术移位的硬件实现"></a>算术移位的硬件实现</h3><h3 id="算术移位与逻辑移位的区别"><a href="#算术移位与逻辑移位的区别" class="headerlink" title="算术移位与逻辑移位的区别"></a>算术移位与逻辑移位的区别</h3><h1 id="浮点四则运算"><a href="#浮点四则运算" class="headerlink" title="浮点四则运算"></a>浮点四则运算</h1><h1 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;无符号数和有符号数&quot;&gt;&lt;a href=&quot;#无符号数和有符号数&quot; class=&quot;headerlink&quot; title=&quot;无符号数和有符号数&quot;&gt;&lt;/a&gt;无符号数和有符号数&lt;/h1&gt;&lt;h2 id=&quot;无符号数&quot;&gt;&lt;a href=&quot;#无符号数&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://gxkord.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成原理" scheme="https://gxkord.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
      <category term="二进制运算" scheme="https://gxkord.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>第5讲 穷举法</title>
    <link href="https://gxkord.github.io/2019/04/19/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/%E7%AC%AC5%E8%AE%B2%20%E7%A9%B7%E4%B8%BE%E6%B3%95/"/>
    <id>https://gxkord.github.io/2019/04/19/算法/算法设计与分析/第5讲 穷举法/</id>
    <published>2019-04-19T08:33:20.000Z</published>
    <updated>2019-05-21T11:58:23.576Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本专题为山东师范大学<a href="https://baike.baidu.com/item/%E6%AE%B5%E4%BC%9A%E5%B7%9D/5079888?fr=aladdin" target="_blank" rel="noopener">段会川老师</a>的课程学习笔记。</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><p>在计算机科学中，<strong>穷举搜索(exhaustive search)</strong>或<strong>蛮力搜索(brute-force search)</strong>，也称为<strong>生成+测试法(generate and test)</strong>，是一种非常通用的问题求解方法，也是最基本的算法设计方法。</p></li><li><p>该方法由两部分构成：</p><ul><li><p>系统化地枚举问题各种可能地候选解。</p></li><li><p>检查每个解是否满足问题地求解要求。</p></li></ul></li></ul><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ul><li><p>进行穷举搜索必须实现4个步骤，即<strong>首选(first)</strong>、<strong>验证(vaild)</strong>、<strong>输出(output)</strong>和<strong>再选(next)</strong>，它们必须以<strong>问题的实例(instance of the problem)</strong>为输入参数，实现下面具体地功能：</p><ol><li><p>c = first(I)：产生问题P的实例I的第一个候选解。</p></li><li><p>vaild(I, c)：检查候选解c是否为问题P的实例I的解。</p></li><li><p>output(I, c)：如果c为P的实例I的解则将其输出。</p></li><li><p>next(I, c)：从当前候选解c顺次产生下一个候选解。</p></li></ol></li><li><p>再选(next)步骤必须判断是否还有下一个候选解，如果没有通常返回一个“空候选”(“null candidate”)，常以$\Lambda$表示。</p><ul><li>首选(first)步骤在实例P没有候选时也应返回$\Lambda$。</li></ul></li></ul><h2 id="抽象算法"><a href="#抽象算法" class="headerlink" title="抽象算法"></a>抽象算法</h2><ul><li><p>算法名称：抽象穷举法(ExhaustiveSearch)</p></li><li><p>输入：问题实例I</p></li><li><p>输出：问题的解</p></li><li><p>1: c ← first(I)</p><p>2: while  $c\neq\Lambda$</p><p>3:     if vaild(I, c) then</p><p>4:         output(I, c)</p><p>5:     c ← next(I)</p><p>6: end while</p></li></ul><h2 id="算法实例"><a href="#算法实例" class="headerlink" title="算法实例"></a>算法实例</h2><h3 id="百元买百兔"><a href="#百元买百兔" class="headerlink" title="百元买百兔"></a>百元买百兔</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ul><li><p>”兔翁一值钱五，兔母一值钱三，兔雏三值钱一。百钱买百兔，问翁、母、雏各几何？” </p><p><em>—— 《张邱建算法》，公元五世纪，北魏</em></p></li><li><p>算法问题：n元买n兔</p><blockquote><p>一个问题转化为算法问题，首先要泛化为一类问题，即将问题看成是规模n任s意大的问题。</p></blockquote></li><li><p>数学模型：</p><ul><li><p>$x+y+z=100$</p></li><li><p>$5x+3y+\frac{z}{3}=100$</p></li></ul></li></ul><h4 id="朴素的穷举法"><a href="#朴素的穷举法" class="headerlink" title="朴素的穷举法"></a>朴素的穷举法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; y++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt;= n; z++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (z % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">5</span>x + <span class="number">3</span>y + z/<span class="number">3</span> == n) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"兔翁："</span> + x + <span class="string">"\t兔母："</span> + y + <span class="string">"\t兔雏:"</span> + z);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述算法存在的问题：</p><ul><li><p>x变量的循环中设置的上限为n，但n元可能买得到n只兔翁吗？</p></li><li><p>若兔翁买$x_0$只，兔母买$y_0$只，那么一定存在唯一的$z_0$，使得$x_0+y_0+z_0$最接近$n$，即$z_0=\lfloor{n-x_0-y_0}\rfloor$。此时，是否还需要$z$取其他值的情况？</p></li></ul></blockquote><h4 id="改进的穷举法"><a href="#改进的穷举法" class="headerlink" title="改进的穷举法"></a>改进的穷举法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> z;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n/<span class="number">5</span>; x++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n/<span class="number">3</span>; y++) &#123;</span><br><span class="line">        z = n - x - y;</span><br><span class="line">        <span class="keyword">if</span> (z % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">5</span>x + <span class="number">3</span>y + z/<span class="number">3</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"兔翁："</span> + x + <span class="string">"\t兔母："</span> + y + <span class="string">"\t兔雏:"</span> + z);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h3><h4 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h4><blockquote><p>问题的形式化定义：通过数学符号和必要的数学公式来表达问题。</p></blockquote><ul><li><p>给定n个重量为$w_1,w_2,\cdots,w_n$价值为$v_1,v_2,\cdots,v_n$的物体和容器为$W$的背包，其中$W&lt;\sum^n_{i=1}w_i$且物体不可分割，问装入哪些物体可以获得最大的价值？</p></li><li><p>以$x_1,x_2,\cdots,x_n$表示物品的装入情况，其中$x_i\in{0,1}$，则0-1背包问题可以表述为如下所示的<strong>优化问题</strong>：</p></li></ul><p>$$<br>\max_{x_1,x_2,\cdots,x_n}V(x_1,x_2,\cdots,x_n)=\sum_{i=1}^{n}x_iv_i，<br>\s.t.\ \ \ \ \ \ \ \ \ \ \sum_{i=1}^{n}x_iw_i\leq{W},<br>\x_i\in{0,1},i=1,2,\cdots,n.<br>$$</p><blockquote><p>优化问题：“最优化问题”的简称，属于运筹学。</p></blockquote><ul><li>给定n个重量为$w_1,w_2,\cdots,w_n$价值为$v_1,v_2,\cdots,v_n$的物品和容器为$W$的背包，其中$W&lt;\sum^n_{i=1}w_i$且物体不可分割，和价值$v_0$，问是否存在价值不低于$V_0$的总重量不超过$W$的物品组合？</li></ul><h4 id="手算穷举"><a href="#手算穷举" class="headerlink" title="手算穷举"></a>手算穷举</h4><p>Q:</p><table><thead><tr><th>i</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>$w_i$</td><td>5</td><td>4</td><td>6</td><td>3</td></tr><tr><td>$v_i$</td><td>10</td><td>40</td><td>30</td><td>50</td></tr></tbody></table><p>$W=10$</p><p>A: </p><table><thead><tr><th>i</th><th>1</th><th>2</th><th>3</th><th>4</th><th>$w_t$</th><th>$v_t$</th></tr></thead><tbody><tr><td>$x_0$</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>$x_1$</td><td>1</td><td>0</td><td>0</td><td>0</td><td>5</td><td>10</td></tr><tr><td>$x_2$</td><td>0</td><td>1</td><td>0</td><td>0</td><td>4</td><td>40</td></tr><tr><td>$\cdots$</td><td>$\cdots$</td><td>$\cdots$</td><td>$\cdots$</td><td>$\cdots$</td><td>$\cdots$</td><td>$\cdots$</td></tr><tr><td>$x_{15}$</td><td>1</td><td>1</td><td>1</td><td>1</td><td>18</td><td>130</td></tr></tbody></table><h4 id="子集树"><a href="#子集树" class="headerlink" title="子集树"></a>子集树</h4><p>子集树：0-1背包问题的<strong>状态空间树</strong>。</p><blockquote><p>状态空间树：将问题的候选解用树来描述。</p></blockquote><ul><li><p>一个问题的决策变量的取值空间（范围）被称为<strong>问题的解空间</strong>。</p></li><li><p>对于0-1背包问题，决策变量为$x_1,x_2,\cdots,x_n$，其中$x_i\in{0,1}$，因为其所有可能的取值组合可以用一颗完美二叉树。</p></li><li><p>而一个集合的所有子集也可以用此二叉树表示。</p><ul><li><p>可以为n个元素集合的各元素指定变量$x_1,x_2,\cdots,x_n$，其中$x_i\in{0,1}$，当$x_i$取1时，表示该元素在某个子集中，取0时，表示该元素不在子集中。</p></li><li><p>而子集问题又是一个比0-1背包问题更一般的问题，因而将该树命名为“<strong>子集树</strong>”。</p></li></ul></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="子集树.jpg" alt="子集树" title>                </div>                <div class="image-caption">子集树</div>            </figure><h4 id="子集树的穷举算法"><a href="#子集树的穷举算法" class="headerlink" title="子集树的穷举算法"></a>子集树的穷举算法</h4><blockquote><p>采用深度优先搜索（前序）遍历子集树。</p></blockquote><ol><li><p>树结点的bean类：TreeNode.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.toString(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>子集树的通用类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 子集树问题的通用父类，扩展它的outPut()方法以规定打印格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SubsetBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> n; <span class="comment">// 二叉树的深度</span></span><br><span class="line">    <span class="keyword">protected</span> Stack&lt;Integer&gt; stack; <span class="comment">// 用于保存0/1的栈</span></span><br><span class="line">    <span class="keyword">protected</span> TreeNode[] subsetBinaryTree; <span class="comment">// 二叉树</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Integer LEFT_BRANCH = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> Integer RIGHT_BRANCH = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SubsetBinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">SubsetBinaryTree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 穷举搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exhaustiveSearch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ES_initStack();</span><br><span class="line">        ES_initSubsetBinaryTree();</span><br><span class="line">        System.out.println(<span class="string">"The subset binary tree has been initialized successfully!"</span>);</span><br><span class="line">        ES_output();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化二叉树</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ES_initSubsetBinaryTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>; <span class="comment">// 总结点数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            m += (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        subsetBinaryTree = <span class="keyword">new</span> TreeNode[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            subsetBinaryTree[i] = <span class="keyword">new</span> TreeNode(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化Stack</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ES_initStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            stack.push(LEFT_BRANCH);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ES_output</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.size() == n)</span><br><span class="line">                outputOne();</span><br><span class="line">            <span class="keyword">int</span> i = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (i == LEFT_BRANCH) &#123;</span><br><span class="line">                stack.push(RIGHT_BRANCH);</span><br><span class="line">                <span class="keyword">while</span> (stack.size() != n) &#123;</span><br><span class="line">                    stack.push(LEFT_BRANCH);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">outputOne</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>简单扩展类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单子集树遍历：打印分支（0/1）和结点标号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSubsetBinaryTree</span> <span class="keyword">extends</span> <span class="title">SubsetBinaryTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleSubsetBinaryTree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出格式：</span></span><br><span class="line"><span class="comment">     *  以n=2为例：</span></span><br><span class="line"><span class="comment">     *      00: [1,2,4]</span></span><br><span class="line"><span class="comment">     *      01: [1,2,5]</span></span><br><span class="line"><span class="comment">     *      10: [1,3,6]</span></span><br><span class="line"><span class="comment">     *      11: [1,3,7]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">outputOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder s2 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n_now = <span class="number">0</span>; <span class="comment">// 当前层数</span></span><br><span class="line">        s2.append(<span class="string">"["</span>);</span><br><span class="line">        <span class="keyword">while</span> (n_now &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>; <span class="comment">// 当前节点</span></span><br><span class="line">            <span class="keyword">if</span> (n_now == <span class="number">0</span>) &#123;</span><br><span class="line">                s2.append(subsetBinaryTree[<span class="number">0</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_now - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                    index += (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, subsetBinaryTree[i].getId());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> temp = n_now - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_now; i++) &#123;</span><br><span class="line">                    index += (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, temp) * stack.get(i);</span><br><span class="line">                    temp--;</span><br><span class="line">                    <span class="keyword">if</span> (n == n_now) &#123;</span><br><span class="line">                        s1.append(stack.get(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                s2.append(subsetBinaryTree[index + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            n_now++;</span><br><span class="line">            s2.append(<span class="string">","</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        s2.delete(s2.length() - <span class="number">1</span>, s2.length()); <span class="comment">// 删除最后一个逗号</span></span><br><span class="line">        s1.append(<span class="string">": "</span>);</span><br><span class="line">        s2.append(<span class="string">"]"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1.append(s2).toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行测试</p><p>以二叉树深度为3为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSubsetBinaryTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试SimpleSubsetBinaryTree</span></span><br><span class="line">        SimpleSubsetBinaryTree tree1 = <span class="keyword">new</span> SimpleSubsetBinaryTree(<span class="number">3</span>);</span><br><span class="line">        tree1.init();</span><br><span class="line">        tree1.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试结果</p><p><img src="n=3%E7%9A%84%E5%AD%90%E9%9B%86%E6%A0%91%E9%81%8D%E5%8E%86%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpg" alt="n=3的子集树遍历测试结果"></p></li><li><p>思考</p><p><strong>要求</strong>：输入目标运行时间T，是否可以通过程序直接获得子集树规模的极大值？</p><ul><li><p>思路：</p><ul><li>为达到要求，需要对子集树的规模n从0开始递增遍历，直至运行时间到达规定值。</li></ul></li><li><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoTestMaxScaleWithinTime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> File file = <span class="keyword">new</span> File(<span class="string">"log.txt"</span>); <span class="comment">// 设置运行结果保存的文件位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> MINUTE_TO_SECOND = <span class="number">60</span>; <span class="comment">// 1min = 60s</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> SECOND_TO_MILLIS = <span class="number">1000</span>; <span class="comment">// 1s = 1000ms</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FileWriter fileWriter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">1</span>; <span class="comment">// 初始化n</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> targetTime_minute; <span class="comment">// 目标时间（min）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 控制台输入目标运行时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AutoTestMaxScaleWithinTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"请输入需要运行的时间(min)："</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        targetTime_minute = in.nextInt();</span><br><span class="line">        getResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器注入目标运行时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AutoTestMaxScaleWithinTime</span><span class="params">(<span class="keyword">long</span> targetTime_minute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetTime_minute = targetTime_minute;</span><br><span class="line">        getResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 程序主方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doMain</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到运算时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> targetTime_millis = targetTime_minute * MINUTE_TO_SECOND * SECOND_TO_MILLIS;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                file.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 循环穷举子集树</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> startTime = System.currentTimeMillis(); <span class="comment">// 开始时间</span></span><br><span class="line">                doMain(n);</span><br><span class="line">                <span class="keyword">long</span> endTime = System.currentTimeMillis(); <span class="comment">// 结束时间</span></span><br><span class="line">                <span class="keyword">long</span> spendTime_millis = getRunTimeByMillis(n, startTime, endTime); <span class="comment">// 计算运行时间</span></span><br><span class="line">                <span class="keyword">if</span> (spendTime_millis &lt;= targetTime_millis) &#123;</span><br><span class="line">                    n++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    n--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            fileWriter = <span class="keyword">new</span> FileWriter(file.getName(), <span class="keyword">true</span>);</span><br><span class="line">            String data = <span class="string">"result："</span> + targetTime_minute + <span class="string">"min内最大可运行的规模为"</span> + n + <span class="string">"\r\n\r\n"</span>;</span><br><span class="line">            System.out.println(data);</span><br><span class="line">            fileWriter.write(data);</span><br><span class="line">            fileWriter.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算n规模的运算需要的时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> long</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getRunTimeByMillis</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">long</span> startTime, <span class="keyword">long</span> endTime)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        fileWriter = <span class="keyword">new</span> FileWriter(file.getName(), <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">long</span> spendTime_millis = endTime - startTime;</span><br><span class="line">        StringBuilder data = <span class="keyword">new</span> StringBuilder(<span class="string">"log: 计算n="</span> + n + <span class="string">"规模，耗时："</span> + spendTime_millis + <span class="string">"ms"</span>);</span><br><span class="line">        <span class="keyword">long</span> spendTime_s = spendTime_millis / SECOND_TO_MILLIS;</span><br><span class="line">        <span class="keyword">if</span> (spendTime_s &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            data.append(<span class="string">", "</span> + spendTime_s + <span class="string">"s"</span>);</span><br><span class="line">            <span class="keyword">long</span> spendTime_min = spendTime_s / MINUTE_TO_SECOND;</span><br><span class="line">            <span class="keyword">if</span> (spendTime_min &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                data.append(<span class="string">", "</span> + spendTime_min + <span class="string">"min\r\n"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                data.append(<span class="string">"\r\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.append(<span class="string">"\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fileWriter.write(data.toString());</span><br><span class="line">        fileWriter.close();</span><br><span class="line">        <span class="keyword">return</span> spendTime_millis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleSubsetBinaryTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 测试AutoTestMaxScaleWithinTime</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            <span class="keyword">new</span> AutoTestMaxScaleWithinTime(i)&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doMain</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">                    SimpleSubsetBinaryTree tree1 = <span class="keyword">new</span> SimpleSubsetBinaryTree(n);</span><br><span class="line">                    tree1.exhaustiveSearch();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="0-1-背包问题的穷举算法"><a href="#0-1-背包问题的穷举算法" class="headerlink" title="0-1 背包问题的穷举算法"></a>0-1 背包问题的穷举算法</h4><ol><li><p>扩展子集树的通用类SubsetBinaryTree</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 0-1背包问题的子集树遍历，打印weight和value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackSubsetBinaryTree</span> <span class="keyword">extends</span> <span class="title">SubsetBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Item[] items;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KnapsackSubsetBinaryTree</span><span class="params">(Item[] items)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(items.length);</span><br><span class="line">        <span class="keyword">this</span>.items = items;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KnapsackSubsetBinaryTree</span><span class="params">(<span class="keyword">int</span>[] weightArr, <span class="keyword">int</span>[] valueArr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(weightArr.length);</span><br><span class="line">        <span class="keyword">int</span> weightArrLength = weightArr.length;</span><br><span class="line">        <span class="keyword">if</span> (weightArrLength != valueArr.length) &#123;</span><br><span class="line">            System.out.println(<span class="string">"The length of the weight array must be equal to the length of the value array!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Item[] items = <span class="keyword">new</span> Item[weightArrLength];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weightArrLength; i++) &#123;</span><br><span class="line">                items[i] = <span class="keyword">new</span> Item(weightArr[i], valueArr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.items = items;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">outputOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        StringBuilder s1 = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stack.size(); i++) &#123;</span><br><span class="line">            s1.append(stack.get(i));</span><br><span class="line">            <span class="keyword">int</span> branch = stack.get(i);</span><br><span class="line">            <span class="keyword">if</span> (branch == TreeNode.RIGHT_BRANCH) &#123;</span><br><span class="line">                w += items[i].getWeight();</span><br><span class="line">                v += items[i].getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.append(s1);</span><br><span class="line">        res.append(<span class="string">"\t"</span>);</span><br><span class="line">        res.append(<span class="string">"weight:"</span> + w + <span class="string">","</span>);</span><br><span class="line">        res.append(<span class="string">"value:"</span> + v);</span><br><span class="line">        System.out.println(res.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 0-1背包问题的子集树遍历算法测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KnapsackSubsetBinaryTreeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] weightArr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] valueArr = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        KnapsackSubsetBinaryTree knapsackSubsetBinaryTree = <span class="keyword">new</span> KnapsackSubsetBinaryTree(weightArr, valueArr);</span><br><span class="line">        knapsackSubsetBinaryTree.init();</span><br><span class="line">        knapsackSubsetBinaryTree.output();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试结果</p><p><img src="0-1%E8%83%8C%E5%8C%85%E7%9A%84%E5%AD%90%E9%9B%86%E6%A0%91%E9%81%8D%E5%8E%86%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpg" alt="0-1背包的子集树遍历测试结果"></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本专题为山东师范大学&lt;a href=&quot;https://baike.baidu.com/item/%E6%AE%B5%E4%BC%9A%E5%B7%9D/5079888?fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
      <category term="算法" scheme="https://gxkord.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法设计与分析" scheme="https://gxkord.github.io/tags/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>第5章 输入输出系统</title>
    <link href="https://gxkord.github.io/2019/04/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC5%E7%AB%A0%20%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://gxkord.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/</id>
    <published>2019-04-18T07:05:00.000Z</published>
    <updated>2019-04-27T13:34:38.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="输入输出系统的发展概况"><a href="#输入输出系统的发展概况" class="headerlink" title="输入输出系统的发展概况"></a>输入输出系统的发展概况</h2><ol><li><p>早期</p><p>分散连接</p><p>CPU和I/0设备<strong>串行</strong>工作 程序查询方式</p></li><li><p>接口模块和DMA阶段</p><p>总线连接</p><p>CPU和I/O设备<strong>并行</strong>工作（中断方式、DMA方式）</p></li><li><p>具有通道结构的阶段</p></li><li><p>具有I/0处理机的阶段</p></li></ol><h2 id="输入输出系统的组成"><a href="#输入输出系统的组成" class="headerlink" title="输入输出系统的组成"></a>输入输出系统的组成</h2><ol><li><p>I/0软件</p><p>(1) I/O指令</p><ul><li>CPU指令的一部分</li></ul><p><img src="IO%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%80%E8%88%AC%E6%A0%BC%E5%BC%8F.jpg" alt="I/O指令的一般格式"></p><p>(2) 通道指令</p><ul><li><p>通道自身的指令</p></li><li><p>指出数组的首地址、传送字数、操作命令</p></li></ul></li><li><p>I/0硬件</p><p>设备  I/O接口</p><p>设备  设备控制器  通道</p></li></ol><h2 id="I-0设备与主机的联系方式"><a href="#I-0设备与主机的联系方式" class="headerlink" title="I/0设备与主机的联系方式"></a>I/0设备与主机的联系方式</h2><ol><li><p>I/0设备编址方式</p><p>(1) 统一编址</p><ul><li>可以直接用取数、存数指令对I/O设备进行访问</li></ul><p>(2)  不统一编址</p><ul><li>有专门的I/O指令</li></ul></li><li><p>设备选址</p><p>用<strong>设备选择电路</strong>识别是否被选中</p></li><li><p>传送方式</p><p>(1) 串行</p><p>(2) 并行</p></li><li><p>联络方式</p><p>(1) 立即响应</p><p>(2) 异步工作采用应答信号</p><ul><li><p>并行</p><p><img src="%E5%BC%82%E6%AD%A5%E5%B9%B6%E8%A1%8C%E5%BA%94%E7%AD%94%E8%81%94%E7%BB%9C%E6%96%B9%E5%BC%8F.jpg" alt="异步并行“应答”联络方式"></p></li><li><p>串行</p><p><img src="%E5%BC%82%E6%AD%A5%E4%B8%B2%E8%A1%8C%E8%81%94%E7%BB%9C%E6%96%B9%E5%BC%8F.jpg" alt="异步串行联络方式"></p></li></ul><p>(3) 同步工作采用同步时标</p></li><li><p>I/0设备与主机的连接方式</p><p>(1) 辐射式连接</p><p><img src="IO%E8%AE%BE%E5%A4%87%E4%B8%8E%E4%B8%BB%E6%9C%BA%E8%BF%9E%E6%8E%A5-%E8%BE%90%E5%B0%84%E5%BC%8F%E8%BF%9E%E6%8E%A5.jpg" alt="辐射式连接"></p><ul><li><p>每台设备都配有一套控制线路和一组信号线</p></li><li><p><strong>不便于增删设备</strong></p></li></ul><p>(2) 总线连接</p><ul><li><strong>便于增删设备</strong></li></ul></li></ol><h2 id="I-O设备与主机信息传送的控制方式"><a href="#I-O设备与主机信息传送的控制方式" class="headerlink" title="I/O设备与主机信息传送的控制方式"></a>I/O设备与主机信息传送的控制方式</h2><ol><li><p>程序查询方式</p><p><img src="%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%E6%B5%81%E7%A8%8B.jpg" alt="程序查询方式流程"></p><ul><li><p><strong>CPU和I/O串行工作</strong></p></li><li><p><strong>踏步等待</strong></p></li></ul></li><li><p>程序中断方式</p><p>倘若CPU在启动I/O设备后，不查询设备是否已准备就绪，继续执行自身程序，只是当I/O设备准备就绪并向CPU发出中断请求后才予以响应。</p><p><img src="%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F.jpg" alt="程序中断方式"></p><ul><li><p><strong>没有踏步等待现象</strong></p></li><li><p><strong>中断现行程序</strong></p></li></ul><p><img src="%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E6%B5%81%E7%A8%8B.jpg" alt="程序中断方式流程"></p></li><li><p>直接存储器存取方式（DMA）</p><p>主存和I/O之间有一条直接数据通道</p><p>不中断现行程序</p><p>周期挪用（周期窃用）</p><p><strong>CPU和I/O并行工作</strong></p><p><img src="DMA%E6%96%B9%E5%BC%8F.jpg" alt="DMA方式"></p></li><li><p>I/0通道方式</p></li><li><p>I/O处理机方式</p></li></ol><blockquote><p>4、5两种方式详解可以参照《计算机系统结构》的教材。</p></blockquote><ol start="6"><li><p>前三种方式的CPU工作效率比较</p><p><img src="%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84CPU%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E6%AF%94%E8%BE%83.jpg" alt="三种方式的CPU工作效率比较"></p></li></ol><h1 id="I-0设备（了解）"><a href="#I-0设备（了解）" class="headerlink" title="I/0设备（了解）"></a>I/0设备（了解）</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="IO设备结构框图.jpg" alt="I/O设备结构框图" title>                </div>                <div class="image-caption">I/O设备结构框图</div>            </figure><p>I/0设备大致分为三类：</p><ol><li><p>人机交互设备</p><p>键盘、鼠标、的研究、显示器</p></li><li><p>计算机信息存储设备</p><p>磁盘、光盘、磁带</p></li><li><p>机-机通信设备</p><p>调制解调器等</p></li></ol><h2 id="输入设备"><a href="#输入设备" class="headerlink" title="输入设备"></a>输入设备</h2><ol><li><p>键盘</p><p>按键</p><p>判断哪个键按下</p><p>将此键翻译成ASCII码（编码键盘法）</p></li><li><p>鼠标</p><p>机械式：金属球、电位器</p><p>光电式：光电转换器</p></li><li><p>触摸屏</p></li></ol><h2 id="输出设备"><a href="#输出设备" class="headerlink" title="输出设备"></a>输出设备</h2><ol><li><p>显示器</p><p>(1) 字符显示：字符发生器</p><p>(2) 图形显示：主观图像</p><p>(3) 图像显示：客观图像</p></li><li><p>打印机</p><p>(1) 击打式：点阵式（逐字、逐行）</p><p>(2) 非打击式：激光（逐页）、喷墨（逐页）</p></li></ol><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol><li><p>A/D、D/A</p><p>模拟/数字（数字/模拟）转换器。</p></li><li><p>终端</p><p>由键盘和显示器组成。</p><p>完成显示控制与存储、键盘管理及通信控制。</p></li><li><p>汉字处理</p><p>汉字输入、汉字存储、汉字输出。</p></li></ol><h2 id="多媒体技术"><a href="#多媒体技术" class="headerlink" title="多媒体技术"></a>多媒体技术</h2><ol><li><p>什么是多媒体？</p></li><li><p>多媒体计算机的关键技术？</p></li></ol><h1 id="I-0接口"><a href="#I-0接口" class="headerlink" title="I/0接口"></a>I/0接口</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>为什么设置接口？</p><ol><li><p>实现设备的选择</p></li><li><p>实现数据缓冲达到速度匹配</p></li><li><p>实现数据串-并格式转换</p></li><li><p>实现电平转换</p></li><li><p>传送控制命令</p></li><li><p>反应设备的状态（“忙”、“就绪”、“错误”、“中断请求”）</p></li></ol><h2 id="接口的功能和组成"><a href="#接口的功能和组成" class="headerlink" title="接口的功能和组成"></a>接口的功能和组成</h2><ol><li><p>总线连接方式的I/O接口电路</p><p>(1) 设备选择线</p><p>(2) 数据线</p><p>(3) 命令线</p><p>(4) 状态线</p><p><img src="IO%E6%80%BB%E7%BA%BF%E5%92%8C%E6%8E%A5%E5%8F%A3%E9%83%A8%E4%BB%B6.jpg" alt="I/O总线和接口部件"></p></li><li><p>接口的功能和组成</p></li></ol><table><thead><tr><th>功能</th><th>组成</th></tr></thead><tbody><tr><td>选址功能</td><td>设备选择电路</td></tr><tr><td>传送命令的功能</td><td>命令寄存器、命令译码器</td></tr><tr><td>传送数据的功能</td><td>数据缓冲寄存器</td></tr><tr><td>反映设备状态的功能</td><td>设备状态标记</td></tr></tbody></table><p>$$<br>\begin{cases}完成触发器D\工作触发器B\中断请求触发器INTR\屏蔽触发器MASK\end{cases}.<br>$$</p><ol start="3"><li><p>I/O接口的基本组成</p><p><img src="IO%E8%AE%BE%E5%A4%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.jpg" alt="I/O设备的基本组成"></p></li></ol><h2 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h2><ol><li><p>按数据<strong>传送方式</strong>分类</p><p>并行接口（Intel 8255）</p><p>串行接口（Intel 8251）</p></li><li><p>按功能<strong>选择的灵活性</strong>分类</p><p>可编程接口（Intel 8255、Intel 8251）</p><p>不可编程接口（Intel 8212）</p></li><li><p>按<strong>通用性</strong>分类</p><p>通用接口（Intel 8255、Intel 8251）</p><p>专用接口（Intel 8279、Intel 8275）</p></li><li><p>按数据传送的<strong>控制方式</strong>分类</p><p>程序型接口</p><p>DMA型接口</p></li></ol><h1 id="程序查询方式"><a href="#程序查询方式" class="headerlink" title="程序查询方式"></a>程序查询方式</h1><h2 id="程序查询方式的流程"><a href="#程序查询方式的流程" class="headerlink" title="程序查询方式的流程"></a>程序查询方式的流程</h2><ol><li><p>查询流程</p><p><img src="IO%E8%AE%BE%E5%A4%87%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.jpg" alt="IO设备的查询流程"></p></li><li><p>程序流程</p><p><img src="%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%E7%9A%84%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B.jpg" alt="程序查询方式的程序流程"></p></li></ol><h2 id="程序查询方式的接口电路"><a href="#程序查询方式的接口电路" class="headerlink" title="程序查询方式的接口电路"></a>程序查询方式的接口电路</h2><ol><li><p>输入</p><p><img src="%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90-%E8%BE%93%E5%85%A5.jpg" alt="程序查询方式接口电路的基本组成-输入"></p><p>① 当CPU通过I/O指令启动输入设备时，指令的设备码字段通过地址线送至设备选择电路。</p><p>② 若该接口的设备码与地址线上的代码吻合，其输出SEL有效。</p><p>③ I/O指令的启动命令经过“与非”门将工作触发器B置为1，将完成触发器D置为0。</p><p>④ 由B触发器启动设备工作。</p><p>⑤ 输入设备将数据送至数据缓冲寄存器（DBR）中。</p><p>⑥ 由设备发设备工作结束信号，将D置“1”，B置“0”，表示外设准备就绪。</p><p>⑦ D触发器以“准备就绪”状态通知CPU，表示“数据缓冲满”。</p><p>⑧ CPU执行输入指令，将DBR中的数据送至CPU的通用寄存器，再存入主存相关单元。</p></li><li><p>输出</p><p>① 当CPU通过I/O指令启动输出设备时，指令的设备码字段通过地址线送至设备选择电路。</p><p>② 若该接口的设备码与地址线上的代码吻合，其输出SEL有效。</p><p>③ I/O指令的启动命令经过“与非”门将工作触发器B置为1，将完成触发器D置为0。</p><p>④ CPU通过输出指令将数据送至数据缓冲 寄存器（DBR）中。</p><p>⑤ 由B触发器启动设备工作，将数据从DBR中取走。</p><p>⑥ 由设备发设备工作结束信号，将D置“1”，B置“0”，表示外设输出完成。</p><p>⑦ D触发器以“准备就绪”状态通知CPU，表示“数据缓冲空”。</p><p>⑧ CPU可再次向DBR输出数据，进行第二次传送。</p></li></ol><h1 id="程序中断方式"><a href="#程序中断方式" class="headerlink" title="程序中断方式"></a>程序中断方式</h1><h2 id="中断的概念"><a href="#中断的概念" class="headerlink" title="中断的概念"></a>中断的概念</h2><p>计算机在执行程序的过程中，当出现异常情况或特殊情况时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回现行程序的间断处，继续执行原程序，这就是“中断”。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="程序中断方式.jpg" alt="程序中断方式" title>                </div>                <div class="image-caption">程序中断方式</div>            </figure><p>计算机系统引入中断技术的原因：</p><ol><li><p>为了提高计算机的整机效率。</p></li><li><p>为了应对突发事件。</p><blockquote><p>例如，当计算机运行过程中，若出现突然掉电这种异常情况，将会导致CPU中的全部信息丢失。倘若在突然掉电的瞬间立即启动另一个备份电源，并迅速进行一些必要的处理，例如，将有用的信息送至不受电源影响的存储系统内，待电源恢复后接着使用，这种处理技术也要用中断技术来实现。</p></blockquote></li><li><p>为了实时控制的需要。</p><blockquote><p>在实时控制领域中，要求CPU能即时响应外来信号的请求，并能完成相应的操作，也都要求采用中断技术。</p></blockquote></li></ol><h2 id="中断的产生"><a href="#中断的产生" class="headerlink" title="中断的产生"></a>中断的产生</h2><p>以打印机为例</p><p><strong>CPU与打印机部分并行工作</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="CPU与打印机并行工作的时间示意图.jpg" alt="CPU与打印机并行工作的时间示意图" title>                </div>                <div class="image-caption">CPU与打印机并行工作的时间示意图</div>            </figure><h2 id="程序中断方式的接口电路"><a href="#程序中断方式的接口电路" class="headerlink" title="程序中断方式的接口电路"></a>程序中断方式的接口电路</h2><ol><li><p>配置中断请求触发器和中断屏蔽触发器</p><p>INTR：中断请求触发器（INTR=1表示有请求）</p><p>MASK：中断屏蔽触发器（MASK=1表示被屏蔽）</p><p>D：完成触发器</p><p><img src="%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF%E4%B8%ADD%E3%80%81INTR%E3%80%81MASK%E5%92%8C%E4%B8%AD%E6%96%AD%E6%9F%A5%E8%AF%A2%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="接口电路中D、INTR、MASK和中断查询信号的关系"></p><blockquote><p>&amp;：与非门，其运算为$\overline{A\cdot B}$。</p><p>1：非门，其运算为$\overline{A}$，相当于$\overline{A\cdot 1}$。</p><p>&amp;和1：效果相当于与门，但由于电路的原因，只能使用与非门。</p></blockquote></li><li><p>排队器</p></li></ol><p>$$<br>排队\begin{cases} 硬件\ \ 在CPU内或在接口电路中（链式排队器） \ 软件\ \ 详见第八章\end{cases}<br>$$</p><p>   <img src="%E9%93%BE%E5%BC%8F%E6%8E%92%E9%98%9F%E5%99%A8.jpg" alt="链式排队器"></p><p>   设备1、2、3、4的优先级按<strong>降序排列</strong></p><p>   $INTR_i=1$有请求，即$\overline{INTR_i}=0$</p><blockquote><p>第一个反相器左侧接地（恒为0），经过反向器，信号变为1，</p><p>若${INTR_1}$有请求，即$INTR_1=1$，经过上方的<strong>与非门</strong>和<strong>非门</strong>，选中1号设备；</p><p>若${INTR_1}$无请求，即$\overline{INTR_1}=1$，经过<strong>与非门</strong>，将1信号传到下一个排队器。</p><p>依此类推…</p></blockquote><ol start="3"><li>中断向量地址形成部件</li></ol><p>$$<br>入口地址\begin{cases} 由软件产生\ \ 详见第八章 \ 硬件向量法\ \ 由硬件产生向量地址，再由向量地址找到入口地址\end{cases}<br>$$</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="中断向量地址形成部件框图.jpg" alt="中断向量地址形成部件框图" title>                </div>                <div class="image-caption">中断向量地址形成部件框图</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="通过向量地址寻找入口地址.jpg" alt="通过向量地址寻找入口地址" title>                </div>                <div class="image-caption">通过向量地址寻找入口地址</div>            </figure><ol start="4"><li><p>程序中断方式接口电路的基本组成</p><p><img src="%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F%E6%8E%A5%E5%8F%A3%E7%94%B5%E8%B7%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.jpg" alt="程序中断方式接口电路的基本组成"></p></li></ol><h2 id="I-O中断处理过程"><a href="#I-O中断处理过程" class="headerlink" title="I/O中断处理过程"></a>I/O中断处理过程</h2><ol><li><p>CPU响应中断的条件和时间</p><ul><li><p>条件</p><p>允许中断触发器<strong>EINT=1</strong></p><p>用<strong>开中断</strong>指令将EINT置“<strong>1</strong>”</p><p>用<strong>关中断</strong>指令将EINT置“<strong>0</strong>”或硬件<strong>自动复位</strong></p></li><li><p>时间</p><p>当D = <strong>1</strong>（随机）且MASK = <strong>0</strong>时</p><p><strong>在每条指令执行阶段的结束前</strong></p><p><strong>CPU</strong>发<strong>中断查询信号</strong>（将INTR置“<strong>1</strong>”）</p></li></ul></li><li><p>I/O中断处理过程</p><p><img src="IO%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.jpg" alt="I/O中断处理过程"></p><p>① 由CPU发启动I/O设备的命令，将I/O接口中的B置“1”，D触发器置”0“。</p><p>② 接口启动输入设备开始工作。</p><p>③ 输入设备将数据送入数据缓冲寄存器。</p><p>④ 输入设备向接口发出”设备工作结束“信号，将D置”1“，B置”0“，标志设备准备就绪。</p><p>⑤ 当设备准备就绪（D=1），且本设备未被屏蔽（MASK=0）时，在指令执行阶段的结束时刻，由CPU发出中断查询信号。</p><p>⑥ 设备中断请求触发器INTR被置”1“，标志设备向CPU提出<strong>中断请求</strong>。与此同时，INTR送至排队器，进行<strong>中断判优</strong>。</p><p>⑦ 若CPU允许中断（EINT=1），设备又被排队选中，即进入<strong>中断响应</strong>阶段，由中断响应信号INTA将排队器输出送至编码器形成向量地址。</p><p>⑧ 向量地址送至PC，作为下一条指令的地址。</p><p>⑨ 由于向量地址中存放的是一条无条件转移指令，故这条指令执行结束后，即无条件转至该设备的服务程序入口地址，开始执行中断服务程序，进入<strong>中断服务</strong>阶段，通过输入指令将数据缓冲寄存器的输入数据送至CPU的通用寄存器，再存入主存相关单元。</p><p>⑩ 中断服务程序的最后一条指令是中断返回指令，当其执行结束时，<strong>中断返回</strong>至原程序的断点处。至此，一个完整的程序中断处理过程即告结束。</p><p><strong>综上所述，可将异常中断处理过程简单归纳为中断请求、中断判优、中断响应、中断服务和中断返回5个阶段。</strong></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;输入输出系统的发展概况&quot;&gt;&lt;a href=&quot;#输入输出系统的发展概况&quot; class=&quot;headerlink&quot; title=&quot;输入输
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://gxkord.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成原理" scheme="https://gxkord.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>1. Spring入门</title>
    <link href="https://gxkord.github.io/2019/03/27/Java/Spring/1.%20Spring%E5%85%A5%E9%97%A8/"/>
    <id>https://gxkord.github.io/2019/03/27/Java/Spring/1. Spring入门/</id>
    <published>2019-03-27T05:05:00.000Z</published>
    <updated>2019-04-29T06:12:05.759Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h2><p>Spring是分层的java SE/EE 应用一站式的<strong>轻量级</strong>开源框架，以 IoC（Inverse of Control，控制反转）和 AOP（Aspect Oriented Programming，切面编程）为内核，提供了展示层Spring MVC、持久层Spring JDBC及业务层事务管理等一站式的企业级应用技术。</p><h2 id="Spring之父"><a href="#Spring之父" class="headerlink" title="Spring之父"></a>Spring之父</h2><p><strong>Rod Johnson</strong></p><ul><li><p>一个技术和商业上的天才。Spring的缔造者。</p></li><li><p>2004年3月24日发布了Spring1.0正式版并成立了SpringSource公司。</p></li></ul><h2 id="Spring优点"><a href="#Spring优点" class="headerlink" title="Spring优点"></a>Spring优点</h2><ol><li><p>方便解耦，简化开发。</p><p>通过Spring的IoC容器，用户可以将对象之间的依赖关系交由Spring进行控制，避免硬解码所造成的过度程序耦合。</p></li><li><p>AOP编程的支持。</p><p>通过Spring提供的AOP功能，方便进行面向切面的编程。</p></li><li><p>声明式事务的支持。</p><p>通过声明的方式灵活地管理事务。</p></li><li><p>方便进行程序测试。</p><p>可以用非容器依赖的编程方式进行几乎所有的测试工作。</p></li><li><p>方便集成各种优秀的框架。</p><p>Spring对其他框架不排斥。更可以降低各种框架的使用难度。它提供了对各种优秀框架的直接支持。（如：Struts、Hibernate、Hessian、Quartz等）</p></li><li><p>降低了Java EE API的使用难度。</p><p>Spring对很多难用的Java EE API（如JDBC、JavaMail、远程调用等）提供了薄层封装，大大降低了这些API的使用难度。</p></li><li><p>Spring源码是经典的学习范例。</p><p>对Spring源码的学习无疑是Java技术的最佳实践范例。</p></li></ol><h2 id="Spring体系结构"><a href="#Spring体系结构" class="headerlink" title="Spring体系结构"></a>Spring体系结构</h2><p>Spring核心框架由4000多个类组成，整个框架按其所属功能可以划分为5个模块，如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Spring框架结构.png" alt="Spring框架结构" title>                </div>                <div class="image-caption">Spring框架结构</div>            </figure><h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><ol><li><p>创建一个JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用了无参构造器..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello:"</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Spring配置文件中注册bean</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans</span><br><span class="line">    xmlns=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    xmlns:xsi=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    xmlns:p=<span class="string">"http://www.springframework.org/schema/p"</span></span><br><span class="line">    xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans-4.1.xsd"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 配置Bean --&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"helloWorld"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"cn.gxk.spring.beans.HelloWorld"</span>&gt;</span><br><span class="line">        &lt;property name="name" value="Spring"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>获取对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 传统方法创建对象 */</span></span><br><span class="line">HelloWorld helloWorld1 = <span class="keyword">new</span> HelloWorld();</span><br><span class="line">helloWorld1.setName(<span class="string">"simple"</span>);</span><br><span class="line">helloWorld1.hello();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Spring方法 */</span></span><br><span class="line"><span class="comment">// 1.创建Spring的IoC容器</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"><span class="comment">// 2.获得xml里的对象（xml解析，反射创建对象）</span></span><br><span class="line">HelloWorld helloWorld2 = (HelloWorld) ctx.getBean(<span class="string">"helloWorld"</span>);</span><br><span class="line"><span class="comment">// 3.调用对象的方法</span></span><br><span class="line">helloWorld2.hello();</span><br></pre></td></tr></table></figure></li></ol><h1 id="IoC容器"><a href="#IoC容器" class="headerlink" title="IoC容器"></a>IoC容器</h1><h2 id="Bean的配置"><a href="#Bean的配置" class="headerlink" title="Bean的配置"></a>Bean的配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans ...&gt;</span><br><span class="line">    &lt;!-- </span><br><span class="line">        配置Bean：</span><br><span class="line">            class：bean的全类名，通过反射的方法在IoC容器中创建对象，所以javabean中必须有无参构造器。</span><br><span class="line">            id：bean的唯一标识。</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;bean id=&quot;helloWorld&quot; class=&quot;cn.gxk.spring.beans.HelloWorld&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h2 id="IoC容器的实现"><a href="#IoC容器的实现" class="headerlink" title="IoC容器的实现"></a>IoC容器的实现</h2><ul><li><p>BeanFactory：IoC容器的基本实现。（一般不用）</p></li><li><p>ApplicationContext：提供了更多高级的特性，是BeanFactory的子类。</p><ul><li><p>ConfigurableApplicationContext：扩展refresh()和close()，让ApplicationContext具有启动、刷新和关闭上下文的能力。</p><ul><li><p>ClassPathXmlApplicationContext：从类路径下加载配置文件。</p></li><li><p>FileSystemXmlApplicationContext：从文件系统中加载配置文件。</p></li></ul></li></ul></li><li><p>常用方法：</p><ul><li><p>getBean(String)</p><p>通过xml中配置的id来创建唯一对象。</p></li><li><p>getBean(类名.class)</p><p>利用类型返回bean，但要求IoC中只有一个该类型的bean。</p></li></ul></li></ul><h2 id="bean注入方法"><a href="#bean注入方法" class="headerlink" title="bean注入方法"></a>bean注入方法</h2><ul><li><p>属性注入（setter方法）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt;</span><br></pre></td></tr></table></figure></li><li><p>构造器注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor-arg value=&quot;v1&quot; index=&quot;0&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;constructor-arg index=&quot;1&quot; type=&quot;int&quot;&gt;</span><br><span class="line">    &lt;value&gt;100&lt;/value&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    index、type可以不写。</span><br><span class="line">    type用来区分重载的构造器。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li><li><p>工厂方法注入（很少使用，不推荐）</p></li></ul><h2 id="特殊的赋值"><a href="#特殊的赋值" class="headerlink" title="特殊的赋值"></a>特殊的赋值</h2><ul><li><p>特殊字符（使用&lt;!CDATA[]]&gt;包裹）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;address&quot;&gt;</span><br><span class="line">    &lt;value&gt;&lt;!CDATA[&lt;hello&gt;]&gt;&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></li><li><p>null</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor-arg type=&quot;java.lang.String&quot;&gt;</span><br><span class="line">    &lt;null/&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br></pre></td></tr></table></figure></li><li><p>内部bean或外部bean</p><ul><li><p>内部bean，不能被外部引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;person&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;person1&quot; class=&quot;包名.Person&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/property&gt;</span><br></pre></td></tr></table></figure></li><li><p>外部bean，用ref引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;person2&quot; class=&quot;包名.Person&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;property name=&quot;person&quot; ref=&quot;person2&quot;&gt;&lt;/property&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>集合</p><blockquote><p>java.util.List - &lt;list&gt;</p><p>java.util.Set - &lt;set&gt;</p></blockquote><ul><li><p>内部集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor-arg&gt;</span><br><span class="line">    &lt;list&gt;</span><br><span class="line">        &lt;ref bean=&quot;person1&quot;/&gt;</span><br><span class="line">        &lt;ref bean=&quot;person2&quot;/&gt;</span><br><span class="line">    &lt;/list&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br></pre></td></tr></table></figure></li><li><p>外部集合</p><blockquote><p>需要在spring配置文件中引入util命名空间。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;util:list id=&quot;persons&quot;&gt;</span><br><span class="line">    &lt;ref bean=&quot;person1&quot;/&gt;</span><br><span class="line">    &lt;ref bean=&quot;person2&quot;/&gt;</span><br><span class="line">&lt;/util:list&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Map</p><blockquote><p>java.util.Map - &lt;map&gt;</p><p>java.util.Properties - &lt;prop&gt;</p></blockquote><ul><li><p>内部Map</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;constructor-arg  type=&quot;java.util.Map&quot;&gt;</span><br><span class="line">    &lt;map&gt;</span><br><span class="line">        &lt;entry key=&quot;aa&quot; value-ref=&quot;person1&quot;&gt;&lt;/entry&gt;</span><br><span class="line">        &lt;entry key=&quot;bb&quot; value-ref=&quot;person2&quot;&gt;&lt;/entry&gt;</span><br><span class="line">    &lt;/map&gt;</span><br><span class="line">&lt;/constructor-arg&gt;</span><br></pre></td></tr></table></figure></li><li><p>外部Map</p><blockquote><p>需要在spring配置文件中引入util命名空间。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;util:map id=&quot;persons&quot;&gt;</span><br><span class="line">    &lt;entry key=&quot;aa&quot; value-ref=&quot;person1&quot;&gt;&lt;/entry&gt;</span><br><span class="line">    &lt;entry key=&quot;bb&quot; value-ref=&quot;person2&quot;&gt;&lt;/entry&gt;</span><br><span class="line">&lt;/util:map&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="使用p命名空间赋值"><a href="#使用p命名空间赋值" class="headerlink" title="使用p命名空间赋值"></a>使用p命名空间赋值</h2><blockquote><p>在spring配置文件中引入p命名空间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;person3&quot; class=&quot;包名.person&quot; p:name=&quot;zhangsan&quot; p:age=&quot;30&quot; p:cars-ref=&quot;cars&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="自动装配（了解，一般不用）"><a href="#自动装配（了解，一般不用）" class="headerlink" title="自动装配（了解，一般不用）"></a>自动装配（了解，一般不用）</h2><ol><li><p>byName</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;car&quot; class=&quot;包名.Car&quot; ...&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;person4&quot; class=&quot;包名.Person&quot; p:name=&quot;zhangsan&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    若person有car属性，设置autowire=&quot;byName&quot;，IoC容器会自动寻找叫&quot;car&quot;的bean，自动装配。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li><li><p>byType</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;car1&quot; class=&quot;包名.car&quot; ...&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;person4&quot; class=&quot;包名.person&quot; p:name=&quot;zhangsan&quot;  autowire=&quot;byType&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    若person有car属性，设置autowire=&quot;byType&quot;，会寻找类car的bean，自动装配（若car有多个bean，会抛异常）</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="bean之间的关系"><a href="#bean之间的关系" class="headerlink" title="bean之间的关系"></a>bean之间的关系</h2><ol><li><p>继承</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;address&quot; p:city=&quot;BeiJing&quot; abstract=&quot;true&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;address2&quot; class=&quot;包名.Address&quot; p:street=&quot;DaZhongShi&quot; parent=&quot;address1&quot;/&gt;</span><br></pre></td></tr></table></figure><ul><li><p>先给给出的属性赋值，未给出的属性继承父bean。</p></li><li><p>设置了abstract=”true”的bean为抽象bean，不能将它实例化，只用于继承。（该抽象bean可以不指定class）</p></li></ul></li><li><p>依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;person1&quot; p:age=&quot;23&quot; depends-on=&quot;name&quot;/&gt;</span><br></pre></td></tr></table></figure><p>depends-on=”name”指定了依赖属性，而name未赋值，会抛异常。</p></li></ol><h2 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;car&quot; class=&quot;包名.car&quot; scope=&quot;?&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">    singleton：默认值，单例的，容器初始化时创建bean对象，在整个容器的生命周期中只有这一个对象。</span><br><span class="line"></span><br><span class="line">    prototype：原型的，每次getBean都会创建一个对象。</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure><h2 id="外部属性文件（可用于配置数据库连接等）"><a href="#外部属性文件（可用于配置数据库连接等）" class="headerlink" title="外部属性文件（可用于配置数据库连接等）"></a>外部属性文件（可用于配置数据库连接等）</h2><ol><li><p>新建属性文件person.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pname=zhangsan</span><br><span class="line">page=20</span><br></pre></td></tr></table></figure></li><li><p>引入属性文件</p><ul><li><p>Spring2.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;包名.person&quot;&gt;</span><br><span class="line">&lt;property name=&quot;location&quot; value=&quot;classpath:person.properties&quot;&gt;&lt;/property&gt;</span><br><span class="line"></span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>Spring2.5以后</p><blockquote><p>需要在spring配置文件中引入context工作空间</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:property-paceholder location=&quot;classpath:person.properties&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;person&quot; class=&quot;包名.person&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;$&#123;pname&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;property name=&quot;age&quot; value=&quot;$&#123;page&#125;&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Spring表达式语言-Spring-EL"><a href="#Spring表达式语言-Spring-EL" class="headerlink" title="Spring表达式语言(Spring EL)"></a>Spring表达式语言(Spring EL)</h2><ul><li><p>一个支持运行时查询和操作对象图的表达式语言。</p></li><li><p>使用#{…}作为定界符。</p></li><li><p>为动态赋值提供了便利。</p></li><li><p>用法：</p><ul><li><p>字面值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;ZhangSan&apos;&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用bean、属性和方法</p><ul><li><p>引用其他bean对象（等同ref属性）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;car&quot; value=&quot;#&#123;car1&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>引用其他对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;car_price&quot; value=&quot;#&#123;car1.price&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>调用其他方法，还可以链式操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;person&quot; value=&quot;#&#123;person1.toString().toUpperCase()&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>静态方法或属性，通过T()调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;property name=&quot;initValue&quot; value=&quot;#&#123;T(java.lang.Math).PI&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>运算符</p><ul><li><p>算数运算符：+, -, *, /, &amp;, ^</p></li><li><p>加号进行字符串连接</p></li><li><p>比较运算符：&lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge</p></li><li><p>逻辑运算符：and, or, not, |</p></li><li><p>if-else运算：</p><ul><li><p>a&gt;b ?: (result1), a&lt;=b ?: (result2)</p></li><li><p>a&gt;b ? ‘reslut1’ : ‘result2‘</p></li></ul></li><li><p>正则表达式</p></li></ul></li></ul></li></ul><h2 id="管理bean的生命周期"><a href="#管理bean的生命周期" class="headerlink" title="管理bean的生命周期"></a>管理bean的生命周期</h2><ul><li><p>Spring IoC容器可以管理Bean的生命周期，并允许在Bean生命周期的特殊点执行相关方法。</p></li><li><p>Spring IoC容器对Bean的生命周期进行管理的过程：</p><ol><li><p>通过构造器或工厂方法创建Bean实例</p></li><li><p>为Bean的属性设值和对其他Bean的引用</p></li><li><p><strong>调用Bean的初始化方法</strong></p></li><li><p>使用Bean</p></li><li><p><strong>容器关闭时，调用bean的销毁方法</strong></p></li></ol></li><li><p>在Bean的声明里设置 init-method 和 destory-method 属性，为bean指定初始化和销毁方法。</p></li><li><p>Bean的后置处理器</p><ul><li><p>创建MyBeanPostProcessor类实现BeanPostProcessor接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两方法的返回值是用户拿到的bean（可以在这两个方法里对创建的bean进行处理）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean初始化（init-method）前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">PostProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bean初始化（init-method）后调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">PostProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在xml里配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean class=&quot;包名.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用工厂方法创建bean"><a href="#使用工厂方法创建bean" class="headerlink" title="使用工厂方法创建bean"></a>使用工厂方法创建bean</h2><ul><li><p>使用静态工厂方法</p><ul><li><p>创建工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticCarFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> map&lt;String,Car&gt; cars = nw HashMap&lt;String,Car&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        cars.put(<span class="string">"audi"</span>, <span class="keyword">new</span> Car(<span class="string">"audi"</span>));</span><br><span class="line">        cars.put(<span class="string">"ford"</span>, <span class="keyword">new</span> Car(<span class="string">"ford"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cars.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在applictionContext.xml里配置bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;car1&quot; class=&quot;包名.StaticCarFactory&quot; factory-method=&quot;getCar&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;audi&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用实例工厂方法</p><ul><li><p>创建工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceCarFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Car&gt; cars = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceCarFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cars = <span class="keyword">new</span> HashMap&lt;String,Car&gt;();</span><br><span class="line">        cars.put(<span class="string">"audi"</span>, <span class="keyword">new</span> Car(<span class="string">"audi"</span>));</span><br><span class="line">        cars.put(<span class="string">"ford"</span>, <span class="keyword">new</span> Car(<span class="string">"ford"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cars.get(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在applictionContext.xml里配置bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;carFactory&quot; class=&quot;包名.InstanceCarFactory&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;car2&quot; factory-bean=&quot;carFactory&quot; factory-method=&quot;getCar&quot;&gt;</span><br><span class="line">    &lt;constructor-arg value=&quot;ford&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用FactoryBean配置bean"><a href="#使用FactoryBean配置bean" class="headerlink" title="使用FactoryBean配置bean"></a>使用FactoryBean配置bean</h2><ul><li><p>创建CarFactoryBean实现FactoryBean接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Car.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在applictionContext.xml里配置bean</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;car1&quot; class=&quot;包名.CarFactoryBean&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;name&quot; value=&quot;BMW&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="基于注解方式配置Bean"><a href="#基于注解方式配置Bean" class="headerlink" title="基于注解方式配置Bean"></a>基于注解方式配置Bean</h2><ul><li><p>组件扫描(component scanning)</p><p>Spring能从classpath下自动扫描，侦测和实例化具有特定注解的组件。</p><ul><li><p>特定组件包括：（这些注解只是用来给编程人员看的，Spring只识别有没有这些注解而不区别）</p><ul><li><p>@Component：基本注解，标识了一个受Spring管理的组件</p></li><li><p>@Respository：标识持久层组件</p></li><li><p>@Service：标识服务层（业务层）组件</p></li><li><p>@Controller：标识表现层组件</p></li></ul></li></ul></li><li><p>在applictionContext.xml里配置bean</p><blockquote><p>在spring配置文件中引入context命名空间。</p></blockquote><ul><li><p>用法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan </span><br><span class="line">    base-package=&quot;包名&quot;</span><br><span class="line">    resource-pattern=&quot;a/*.class&quot;&gt;</span><br><span class="line">&lt;/context:component-scan&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>属性：</p><p>base-package：指定包名，IoC容器扫描该包和子包下的所有类。</p><p>resource-pattern：限制扫描范围。</p></li><li><p>子标签：</p><ul><li><p>&lt;context:include-filter&gt;：包括指定的类</p><blockquote><p>若实现”只包含指定类”，需要在&lt;context:component-scan&gt;中添加属性use-default-filters=”false”</p></blockquote><ul><li><p>属性：</p><p>type：用来指定过滤类型。</p><ul><li><p>annotation(过滤指定类)</p></li><li><p>assinable(过滤继承或实现了指定类的子类)</p></li></ul></li></ul></li><li><p>&lt;context:exclude-filter&gt;：不包括指定的类。</p></li></ul></li><li><p>bean创建过程：</p><p>IoC容器会扫描指定的包和其子类(经过过滤)，对添加了注解的类进行实例化，id为非限定类名（第一个字母小写）。</p></li><li><p>特殊：</p><ul><li><p>若某被扫描的bean1里有其他bean2，可以在bean2前加 @Autowired 标记，该bean2也会被自动注入。（setter方法也可）</p><ul><li><p>若bean2没有被注解，会抛异常。</p><p>解决方法：可以设置 @Autowired(required=false)，容器会对它赋值null。</p></li><li><p>若有两个bean2，也会抛异常。</p><blockquote><p>如：UserService是抽象的接口，而项目中有两个实现类userService1和userService2，且都有注解。</p></blockquote><p>解决方法：</p><p>(1) 在组件中添加名字。（如： @Service(userService1) ）</p><p>(2) 在bean2前添加 @Qualifier 注解。（如： @Qualifier(“userService2”) ）</p></li></ul></li></ul></li></ul><h2 id="Spring4新特性——泛型限定式依赖注入"><a href="#Spring4新特性——泛型限定式依赖注入" class="headerlink" title="Spring4新特性——泛型限定式依赖注入"></a>Spring4新特性——泛型限定式依赖注入</h2><ol><li><p>Spring4.0以前，对于父类里setter方法，必须在子类再写一个setter方法，然后指定注入的具体类型，然后进行注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseService</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BaseRepository&lt;M&gt; repository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRepository</span><span class="params">(BaseRepository&lt;M&gt; repository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(M m)</span> </span>&#123;</span><br><span class="line">        repository.save(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserRepository</span><span class="params">(UserRepository userRepository)</span> </span>&#123;</span><br><span class="line">        setRepository(userRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">Organization</span>&gt; </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrganizationRepository</span><span class="params">(OrganizationRepository organizationRepository)</span> </span>&#123;  </span><br><span class="line">        setRepository(organizationRepository);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Spring4.0实现了泛型依赖</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseService</span>&lt;<span class="title">M</span> <span class="keyword">extends</span> <span class="title">Serializable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">protected</span> BaseRepository&lt;M&gt; repository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(M m)</span> </span>&#123;</span><br><span class="line">        repository.save(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">User</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganizationService</span> <span class="keyword">extends</span> <span class="title">BaseService</span>&lt;<span class="title">Organization</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="引入AOP"><a href="#引入AOP" class="headerlink" title="引入AOP"></a>引入AOP</h2><ol><li><p>如何实现一个计算器？（OOP）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArithmeticCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArithmeticCalculatorImpl</span> <span class="title">implents</span> <span class="title">ArithmeticCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = i + j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = i - j;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如何在使用计算器过程中打印日志？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"The method add begins with["</span> + i + <span class="string">","</span> + j + <span class="string">"]"</span>);</span><br><span class="line">    <span class="keyword">int</span> result = i + j;</span><br><span class="line">    System.out.println(<span class="string">"The method add ends with "</span> + result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上述代码存在的问题</strong>：</p></li></ol><ul><li><p>代码混乱：越来越多的非业务需求加入后，原来的业务方法急剧膨胀，每个方法在处理核心逻辑的同时还必须兼顾其他多个关注点。</p></li><li><p>代码分散：每个模块都必须做相似的动作，而如果需求改变，每个模块都必须修改。</p></li></ul><ol start="3"><li><p>如何解决？</p><p>使用动态代理（InvocationHandler）—— 使用反射(reflect)对目标对象的每个方法进行模块化操作。</p><ul><li><p>代理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArithmeticCalculatorLoggingProxy</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要代理的对象</span></span><br><span class="line">    <span class="keyword">private</span> ArithmeticCalculator target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArithmeticCalculatorLoggingProxy</span><span class="params">(ArithmeticCalculator target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArithmeticCalculator <span class="title">getLoggingProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ArithmeticCalculator proxy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 代理对象由哪个类加载器负责加载</span></span><br><span class="line">        ClassLoader loader = target.getClass().getClassLoader();</span><br><span class="line">        <span class="comment">// 代理对象的类型，即其中有那些方法</span></span><br><span class="line">        Class[] interfaces = <span class="keyword">new</span> Class[]&#123;ArithmeticCalculator.class&#125;;</span><br><span class="line">        <span class="comment">// 当调用代理对象其中方法时，执行的代码</span></span><br><span class="line">        InvocationHandler h = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * proxy：正在返回的代理对象，一般情况下，在invoke方法中都不使用该对象</span></span><br><span class="line"><span class="comment">             * —— 如果你想使用这个对象，并调用它的方法，又会调用invoke()方法，直至发生死循环。</span></span><br><span class="line"><span class="comment">             * method：正在调用的方法</span></span><br><span class="line"><span class="comment">             * args：调用方法时传入的参数</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                String methodName = method.getName();</span><br><span class="line">                <span class="comment">//日志</span></span><br><span class="line">                System.out.println(<span class="string">"The method "</span> + methodName + <span class="string">" begins with ["</span> + args[<span class="number">0</span>] + <span class="string">","</span> + args[<span class="number">1</span>] + <span class="string">"]"</span>);</span><br><span class="line">                <span class="comment">//执行方法</span></span><br><span class="line">                Object result = method.invoke(target, args);</span><br><span class="line">                <span class="comment">//日志</span></span><br><span class="line">                System.out.println(<span class="string">"The method "</span> + methodName + <span class="string">" ends with "</span> + result);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        proxy = Proxy.newProxyInstance(loader, interfaces, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用代理类创建对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArithmeticCalculator target = <span class="keyword">new</span> ArithmeticCalculatorImp();</span><br><span class="line">        ArithmeticCalculator proxy = <span class="keyword">new</span> ArithmeticCalculatorLoggingProxy(target).getLoggingProxy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = proxy.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"--&gt;"</span> + result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>问题</p><p>这种方法太麻烦，Spring把它封装起来，称为AOP。</p></li></ol><h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><ul><li><p><strong>AOP (Aspect-Oriented Programming，面向切面编程)</strong>：是对传统OOP(Object-Oriented Programming，面向对象编程)的补充。</p></li><li><p>AOP的主要编程对象是切面(aspect)，而切面模块化横切关注点。</p></li><li><p>在AOP仍需定义公共功能，但不必修改受影响的类，这样横切的关注点就被模块化到特殊的对象(切面)里。</p></li><li><p>使用AOP的好处：</p><ul><li><p>每个事物逻辑位于一个位置，代码不分散，便于维护和升级。</p></li><li><p>业务模块更简洁，只包含核心业务代码。</p></li></ul></li></ul><blockquote><p>在上述的例子（计算器）中：</p><p>对于每个业务逻辑(add/sub/mul/div)，在实现这些逻辑之后用一个另外的类，对特定的多个逻辑进行额外操作（验证参数、前置/后置日志），这个过程，称为面向切面编程（AOP）。</p></blockquote><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><ul><li><p>切面(aspect)：横切关注点（跨越应用程序多个模块的功能）被模块化的特殊对象。</p></li><li><p>通知(advice)：切面必须完成的工作。</p></li><li><p>目标(target)：被通知的对象。</p></li><li><p>代理(proxy)：向目标对象应用通知之后创建的对象。</p></li><li><p>连接点(joinpoint)：程序执行的某个特定位置（如：类某个方法调用前、调用后、方法抛出异常后等）。</p></li><li><p>切点(pointcut)：连接点是客观存在的事物。通过切点可以定位到特定的一个或多个连接点。</p></li></ul><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>在Spring2.0以上版本中，可以使用 基于AspectJ(一种AOP框架)注解 或 基于XML 来配置AOP。</p><h3 id="基于AspectJ注解"><a href="#基于AspectJ注解" class="headerlink" title="基于AspectJ注解"></a>基于AspectJ注解</h3><ul><li><p>需要的jar包：aopalliance.jar、aspectj.weaver.jar 和 spring-aspects.jar</p></li><li><p>配置文件中导入aop命名空间。</p></li><li><p>使用AspectJ让aop自动动态代理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</span><br></pre></td></tr></table></figure></li><li><p>配置自动扫描的包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;context:component-scan base-package=&quot;cn.gxk.spring.aop.impl&quot;&gt;&lt;/context:component-scan&gt;切面类</span><br></pre></td></tr></table></figure></li><li><p>切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把该类声明为一个切面：需要把该类放入IoC容器，再声明为切面</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前置通知：目标方法之前执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs());</span><br><span class="line">        System.out.println(<span class="string">"The method "</span> + methodName + <span class="string">" begins with"</span>+args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后置通知：目标方法之前执行(无论是否发生异常都执行)</span></span><br><span class="line"><span class="comment">     * 拿不到返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"The method "</span> + methodName + <span class="string">" ends"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回通知：方法正常执行后返回结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value=<span class="string">"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))"</span>,</span><br><span class="line">            returning=<span class="string">"result"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span></span>&#123;</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"The method "</span> + methodName + <span class="string">" return "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常通知：在目标方法发生异常时执行</span></span><br><span class="line"><span class="comment">     *     可以访问到异常对象，甚至过滤指定异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value=<span class="string">"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))"</span>,</span><br><span class="line">            throwing=<span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint, NullPointerException ex)</span></span>&#123;</span><br><span class="line">        String methodName = joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"The method "</span> + methodName + <span class="string">" occurs exception:"</span> + ex.getStackTrace());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 环绕通知：需要携带ProceedingJoinPoint类型的参数</span></span><br><span class="line"><span class="comment">     * ProceedingJoinPoint参数可以决定是否执行目标方法</span></span><br><span class="line"><span class="comment">     * 且环绕通知必须有返回值，返回值为目标方法的返回值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">aroundMethod</span><span class="params">(ProceedingJoinPoint pjd)</span></span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        String methodName = pjd.getSignature().getName();</span><br><span class="line">        <span class="comment">//执行目标方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//前置通知</span></span><br><span class="line">            System.out.println(<span class="string">"[环绕]The method "</span> + methodName + <span class="string">" begins with "</span> + Arrays.asList(pjd.getArgs()));</span><br><span class="line">            result = pjd.proceed();</span><br><span class="line">            <span class="comment">//返回通知</span></span><br><span class="line">            System.out.println(<span class="string">"[环绕]The method "</span> + methodName + <span class="string">"ends with "</span> + result);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">//异常通知</span></span><br><span class="line">            System.out.println(<span class="string">"[环绕]The method "</span> + methodName + <span class="string">" occurs exception:"</span> + e.getStackTrace());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//后置通知</span></span><br><span class="line">        System.out.println(<span class="string">"[环绕]The method "</span> + methodName + <span class="string">"ends"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通知的种类：</p><ul><li><p>@Before：前置通知</p></li><li><p>@After：后置通知(无论是否发生异常)，拿不到返回结果</p></li><li><p>@AfterRunning：返回通知，在方法返回结果后执行</p></li><li><p>@AfterThrowing：异常通知，在方法抛出异常后执行</p></li><li><p>@Around：环绕通知，围绕着方法执行，上述通知能做到的它都能做到。</p></li></ul><blockquote><p>注：可以使用通配符（*）来替代方法标志的任意部分（前缀、返回指、方法名等），方法参数则可以用(..)代替。</p></blockquote></li></ul><blockquote><p>注意：动态代理需要使用接口，所以自动动态代理后的bean会自动转化为接口的类型使用 ctx.getBean(接口.class); 得到bean。</p><p>另：若有多个切面 ，可以 @Order(1) 用来指定切面的优先级，值越小优先级越高！</p></blockquote></li></ul><h4 id="重用切面表达式"><a href="#重用切面表达式" class="headerlink" title="重用切面表达式"></a>重用切面表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个方法，用于声明切入点表达式，一般地，该方法不需要添加其他代码</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(...)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">declareJointPointExpression</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在通知注解中调用（不同包的不同类下需要声明包名和类名）</span></span><br><span class="line"><span class="meta">@Before</span>(<span class="string">"包名.类名.declareJointPointExpression()"</span>);</span><br></pre></td></tr></table></figure><h3 id="基于XML文件"><a href="#基于XML文件" class="headerlink" title="基于XML文件"></a>基于XML文件</h3><ul><li><p>切面(Aspect)类写法与上述一致，不需要使用注释</p></li><li><p>xml里配置（返回或异常通知的returning和throwing属性需要与切面类的参数名相同）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--bean--&gt;</span><br><span class="line">&lt;bean id=&quot;arithmeticCalculator&quot;</span><br><span class="line">      class=&quot;cn.gxk.spring.aop.xml.ArithmeticCalculatorImpl&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--切面的bean--&gt;</span><br><span class="line">&lt;bean id=&quot;loggingAspect&quot;</span><br><span class="line">      class=&quot;cn.gxk.spring.aop.xml.LoggingAspect&quot;&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;!--配置切点表达式--&gt;</span><br><span class="line">    &lt;aop:pointcut expression=&quot;execution(* cn.gxk.spring.aop.xml.ArithmeticCalculator.*(int, int))&quot;</span><br><span class="line">                  id=&quot;pointcut&quot;/&gt;</span><br><span class="line">    &lt;!--配置切面及通知--&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;loggingAspect&quot; order=&quot;1&quot;&gt;</span><br><span class="line">        &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt;</span><br><span class="line">        &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt;</span><br><span class="line">        &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pointcut&quot; returning=&quot;result&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt;</span><br><span class="line">        &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pointcut&quot; throwing=&quot;ex&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt;</span><br><span class="line">        &lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="JDBC相关"><a href="#JDBC相关" class="headerlink" title="JDBC相关"></a>JDBC相关</h1><h2 id="JDBC相关工具"><a href="#JDBC相关工具" class="headerlink" title="JDBC相关工具"></a>JDBC相关工具</h2><h3 id="c3p0配置数据源"><a href="#c3p0配置数据源" class="headerlink" title="c3p0配置数据源"></a>c3p0配置数据源</h3><ol><li><p>数据源配置文件 db.properties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.password = 123456</span><br><span class="line">jdbc.driverClass = com.mysql:///spring4</span><br><span class="line">jdbc.initPoolSize = 5</span><br><span class="line">jdbc.maxPoolSize = 10</span><br></pre></td></tr></table></figure></li><li><p>在applicationContext.xml里配置c3p0数据源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 导入资源文件 --&gt;</span><br><span class="line">&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;</span><br><span class="line">&lt;!-- 配置C3P0数据源 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot;</span><br><span class="line">      class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;initialPoolSize&quot; value=&quot;$&#123;jdbc.initialPoolSize&#125;&quot;/&gt;</span><br><span class="line">    &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;jdbc.maxPoolSize&#125;&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>测试连接数据源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ctx = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        DataSource dataSource = ctx.getBean(DataSource.class);</span><br><span class="line">        System.out.println(dataSource.getConnection());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Spring的JDBCTemplate"><a href="#Spring的JDBCTemplate" class="headerlink" title="Spring的JDBCTemplate"></a>Spring的JDBCTemplate</h3><ol><li><p>在applicationContext.xml里配置JDBCTemplate</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;jdbcTemplate&quot;</span><br><span class="line">      class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>JDBCTest</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ctx = nulll;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    &#123;</span><br><span class="line">        ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        jdbcTemplate = (JdbcTemplate) ctx.getBean(<span class="string">"jdbcTemplate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单条更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"UPDATE employee SET last_name = ? WHERE id=?"</span>;</span><br><span class="line">        jdbcTemplate.update(sql, <span class="string">"Jack"</span>, <span class="number">12</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 批量更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBatchUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"INSERT INTO employee(last_name, email, dept_id) VALUES(?, ?, ?)"</span>;</span><br><span class="line">        List&lt;Object[]&gt; betchArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"Zhang"</span>, <span class="string">"zhang@1.com"</span>, <span class="number">1</span>&#125;);</span><br><span class="line">        batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"Li"</span>, <span class="string">"li@2.com"</span>, <span class="number">2</span>&#125;);</span><br><span class="line">        batchArgs.add(<span class="keyword">new</span> Object[]&#123;<span class="string">"Wang"</span>, <span class="string">"wang@3.com"</span>, <span class="number">3</span>&#125;);</span><br><span class="line"></span><br><span class="line">        jdbcTemplate.batchUpdate(sql, batchArgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到数据库里一条记录，并生成对象</span></span><br><span class="line"><span class="comment">     * 注意：并不是使用queryForObject(String sql, Class&lt;Employee&gt; requiredType, Object...args)</span></span><br><span class="line"><span class="comment">     *        而是 queryForObject(String sql, RowMapper&lt;Employee&gt; requiredType, Object...args)</span></span><br><span class="line"><span class="comment">     *    1. 其中RowMapper指定如何去映射结果集的行，常用的实现类为BeanPropertyRowMapper</span></span><br><span class="line"><span class="comment">     *    2. 使用SQL中列的别名完成列名和类的属性名的映射。例如:last_name lastName</span></span><br><span class="line"><span class="comment">     *    3. 并不支持级联属性，JdbcTemplate只是JDBC的小工具，并非ORM框架</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"SELECT id,last_name lastName, email FROM employees WHERE id = ？"</span>;</span><br><span class="line">        RowMapper&lt;Employee&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Employee.class);</span><br><span class="line">        Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, <span class="number">1</span>);</span><br><span class="line">        System.out.println(employee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得单列的值，或做统计查询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"SELECT count(id) FROM employees"</span>;</span><br><span class="line">        <span class="keyword">long</span> count = jdbcTemplate.queryForObject(sql, Long.class);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询实体类的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryForList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"SELECT id, last_name lastName, email FROM employees WHERE id&gt; ?"</span>;</span><br><span class="line">        RowMapper&lt;Employee&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Employee.class);</span><br><span class="line">        List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper, <span class="number">5</span>);</span><br><span class="line">        System.out.println(employees);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>说明：</p><ul><li><p>每次使用都创建一个JdbcTemplate的新实例，这种做法效率低下。</p></li><li><p>JdbcTemplate类被设计成线程安全的，所有可以在IOC中声明它的单个实例，并把这个实例注入到所有的Dao里。</p></li></ul></li><li><p>代码实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Respository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentDao</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Employee <span class="title">get</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"SELECT id, last_name lastName, email FROM employees WHERE id= ?"</span>;</span><br><span class="line">        RowMapper&lt;Employee&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(Employee.class);</span><br><span class="line">        Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, id);</span><br><span class="line">        <span class="keyword">return</span> employee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="扩展JdbcDaoSupport"><a href="#扩展JdbcDaoSupport" class="headerlink" title="扩展JdbcDaoSupport"></a>扩展JdbcDaoSupport</h3><blockquote><p>使用起来更麻烦，不推荐！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Respository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepartmentDao</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要提供数据源(或使用JdbcTemplate)才能连接数据库</span></span><br><span class="line"><span class="comment">     *    但由于JdbcDaoSupport父类中已经有JdbcTemplate变量，</span></span><br><span class="line"><span class="comment">     *    且setDataSource()已经被设计成final类型，</span></span><br><span class="line"><span class="comment">     *    所以并不能直接注入数据源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource2</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        setDataSource(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要通过getJdbcTemplate()得到 JdbcTemplate对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DepartMent <span class="title">get</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"SELECT id, dept_name name FROM departments WHERE id= ?"</span>;</span><br><span class="line">        RowMapper&lt;DepartMent&gt; rowMapper = <span class="keyword">new</span> BeanPropertyRowMapper&lt;&gt;(DepartMent.class);</span><br><span class="line">        DepartMent departMent = getJdbcTemplate().queryForObject(sql, rowMapper, id);</span><br><span class="line">        <span class="keyword">return</span> departMent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用具名参数"><a href="#使用具名参数" class="headerlink" title="使用具名参数"></a>使用具名参数</h3><blockquote><p>不需要再在java代码里绑定dataSource。</p></blockquote><ul><li><p>配置NamedParameterJdbcTemplate</p><p>该对象可以使用具名参数，其没有无参构造器，必须对其构造器指定参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;namedParameterJdbcTemplate&quot;</span><br><span class="line"> class=&quot;org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate&quot;&gt;</span><br><span class="line">    &lt;constructor-arg ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>测试使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ctx = nulll;</span><br><span class="line">    <span class="keyword">private</span> NamedParameterJdbcTemplate namedParameterJdbcTemplate;</span><br><span class="line">    &#123;</span><br><span class="line">        ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">        namedParameterJdbcTemplate = ctx.getBean(NamedParameterJdbcTemplate.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以给参数起名字</span></span><br><span class="line"><span class="comment">     *    1.好处：若有多个参数，不需要再去对应位置，直接对应参数名，不方便维护。</span></span><br><span class="line"><span class="comment">     *    2.缺点：书写复杂。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedParameterJdbcTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"INSERT INTO employees(last_name, email, dept_id) VALUES(:ln, :email, :deptid)"</span>;</span><br><span class="line">        Map&lt;String,Object&gt; paramMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        paramMap.put(<span class="string">"ln"</span>,<span class="string">"Alice"</span>);</span><br><span class="line">        paramMap.put(<span class="string">"email"</span>,<span class="string">"Alice@123.com"</span>);</span><br><span class="line">        paramMap.put(<span class="string">"deptid"</span>,<span class="string">"2"</span>);</span><br><span class="line">        namedParameterJdbcTemplate.update(sql, paramMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * update(String sql, SqlParameterSource paramSource);</span></span><br><span class="line"><span class="comment">     *    1.sql语句中的参数名与类的属性名保持一致！</span></span><br><span class="line"><span class="comment">     *    2.使用SqlParameterSource的实现类BeanPropertySqlParameterSource作为参数。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedParameterJdbcTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String sql = <span class="string">"INSERT INTO employees(last_name, email, dept_id) VALUES(:lastName, :email, :deptId)"</span>;</span><br><span class="line">        Employee employee = <span class="keyword">new</span> Employee();</span><br><span class="line">        employee.setLastName(<span class="string">"zhang"</span>);</span><br><span class="line">        employee.setEmail(<span class="string">"zhang@1.com"</span>);</span><br><span class="line">        employee.setDeptId(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        SqlParameterSource paramSource = <span class="keyword">new</span> BeanPropertySqlParameterSource(Employee);</span><br><span class="line">        namedParameterJdbcTemplate.update(sql, paramSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="JDBC事务"><a href="#JDBC事务" class="headerlink" title="JDBC事务"></a>JDBC事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><ul><li><p>事务管理是企业级应用程序开发中必不可少的技术，用来确保数据的完整性和一致性。</p></li><li><p>事务管理就是一系列动作，它们作为一个单独的工作单元。这些动作需要全部完成后才能都起作用。</p></li><li><p>事务的四个属性：</p><ul><li><p>原子性(atomicity)</p></li><li><p>一致性(consistency)</p></li><li><p>隔离性(isolation)</p></li><li><p>持久性(durability)</p></li></ul></li></ul><h3 id="JDBC事务操作"><a href="#JDBC事务操作" class="headerlink" title="JDBC事务操作"></a>JDBC事务操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = dataSource.getConnection();</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">                    e1.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrance();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring中的事务管理"><a href="#Spring中的事务管理" class="headerlink" title="Spring中的事务管理"></a>Spring中的事务管理</h3><ul><li><p>编程式事务管理</p></li><li><p>声明式事务管理</p><p>将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。</p><ul><li><p>事务管理作为一种横切关注点，可以通过AOP方法模块化。Spring通过Spring AOP框架支持声明式事务管理。</p></li><li><p>Spring从不同的事务管理API中抽象了一整套的事务机制。从而让事务管理代码独立于特定的事务之外。</p></li><li><p>使用方法：</p><ul><li><p>applicationContext.xml配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot;</span><br><span class="line">      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!-- 启动事务 --&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用方法</p><p>在相应方法前增加注释 @Transactional，这个方法就会变成事务方法，IoC会让这个方法拥有事务的特性。</p></li></ul></li></ul></li></ul><h3 id="事务传播属性"><a href="#事务传播属性" class="headerlink" title="事务传播属性"></a>事务传播属性</h3><ul><li><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。</p></li><li><p>传播行为(propagation)</p><ul><li><p>REQUIRED(默认)：共用一个事务操作，回滚时都不执行。（例如：买了两本书，第二本购买失败，第一本也会失败）</p></li><li><p>REQUIRES_NEW：开启一个新的事务。（买了两本书，第二本购买失败，不影响第一本）</p></li></ul></li><li><p>隔离级别(isolation)</p><ul><li><p>DEFAULT</p><p>默认隔离级别，每种数据库支持的事务隔离级别不一样。</p></li><li><p>READ_UNCOMMITTED</p><p>读未提交，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用。</p></li><li><p>READ_COMMITED</p><p>读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读</p></li><li><p>REPEATABLE_READ</p><p>重复读取，即在数据读出来之后加锁，类似”select * from XXX for update”，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决。</p></li><li><p>SERLALIZABLE</p><p>串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了</p></li></ul><p><img src="%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7.png" alt="事务隔离等级的并发问题"></p></li><li><p>回滚类型</p><ul><li><p>默认情况下对所有运行时异常进行回滚。</p></li><li><p>对某些异常不会滚：noRollbackFor={UserAccountException.class}</p></li><li><p>对哪些异常回滚：rollbackFor={UserAccountException.class}</p></li></ul></li><li><p>只读(readOnly=true)</p><ul><li>标明这个事务只读取数据而不更新，这样可以帮助数据库引擎优化事务</li></ul></li><li><p>强制回滚时间(timeout=1)</p><ul><li>如果事务执行时间超过1s，会强制回滚。以保证不占用太多数据库连接时间。</li></ul></li><li><p>使用实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span>(propagation=Propagation.REQUIRES_NEW)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">purchase</span><span class="params">(String username, String isbn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询书的单价</span></span><br><span class="line">    <span class="keyword">int</span> price = bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line">    <span class="comment">//更新库存</span></span><br><span class="line">    bookShopDao.updateBookStock(isbn);</span><br><span class="line">    <span class="comment">//更新账户余额</span></span><br><span class="line">    bookShopDao.updateUserAccount(username, price);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用xml配置声明式事务"><a href="#使用xml配置声明式事务" class="headerlink" title="使用xml配置声明式事务"></a>使用xml配置声明式事务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置事务管理器 --&gt;</span><br><span class="line">&lt;bean id=&quot;transactionManager&quot;</span><br><span class="line">      class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"> &lt;!-- 配置事务属性 --&gt;</span><br><span class="line">&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">        &lt;!-- 根据方法名置顶事务的属性 --&gt;</span><br><span class="line">        &lt;tx:method name=&quot;purchase&quot; propagation=&quot;REQUIRES_NEW&quot;&gt;</span><br><span class="line">        &lt;tx:method name=&quot;*&quot;/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置切入点 --&gt;</span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut expression=&quot;execution(* cn.gxk.spring4.xml.service.*.*(...))&quot; id=&quot;txPointCut&quot;/&gt;</span><br><span class="line">    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;Spring是什么&quot;&gt;&lt;a href=&quot;#Spring是什么&quot; class=&quot;headerlink&quot; title=&quot;Spring是
      
    
    </summary>
    
      <category term="Java" scheme="https://gxkord.github.io/categories/Java/"/>
    
    
      <category term="Spring" scheme="https://gxkord.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>2. 面向对象设计原则</title>
    <link href="https://gxkord.github.io/2019/03/23/Java/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2.%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <id>https://gxkord.github.io/2019/03/23/Java/Java设计模式/2. 面向对象设计原则/</id>
    <published>2019-03-23T08:13:00.000Z</published>
    <updated>2019-04-19T09:39:49.971Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>软件的<strong>可维护性（Maintainability）</strong>和<strong>可复用性（Reusability）</strong>是两个非常重要的用于衡量软件质量的属性。</p><ul><li><p>软件的可维护性：软件能够被理解、改正、适应及扩展的难易程度。</p></li><li><p>软件的可复用性：软件能够被重复使用的难易程度。</p></li></ul><p>面向对象设计的目标之一在于支持可维护性复用，也是后续设计模式学习的基础。</p><p>常见的面向对象原则有7种。</p><h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>使用频率：★★★★☆</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><p> 单一职责原则是最简单的面向对象设计原则，它<strong>用于控制类的粒度大小</strong>。</p></blockquote><ul><li><p><strong>单一职责原则</strong>：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</p></li><li><p><strong>Single Responsibility Rrincipe(SRP)</strong>: Every object should have a single responsibility, and that responsibility should be entirely encapsulated by the class.</p></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><blockquote><p>某软件公司开发人员针对CRM（Customer Relationship Management，客户关系管理）系统中的客户信息图形统计模块提出下图所示的初始设计方案。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="单一职责原则-例子-初始设计方案结构图.jpg" alt="初始设计方案结构图" title>                </div>                <div class="image-caption">初始设计方案结构图</div>            </figure><ul><li><p>getConnection()方法用于连接数据库</p></li><li><p>findCustomers()方法用于查询所有客户信息</p></li><li><p>createChart()方法用于创建图表</p></li><li><p>displayChart()方法用于显示图标</p></li></ul><p>现使用单一职责原则对其进行重构。</p></blockquote><p>在该例中CustomerDataChart类承担了 太多的职责。如果在其他类中也需要连接数据库或查询所有客户信息，则难以实现代码的复用。因此需要对该类进行拆分：</p><ul><li><p>DBUtils：负责连接数据库。</p></li><li><p>CustomerDAO：负责操作数据库中的Customer表。</p></li><li><p>CustomerDataChart：负责图表的生成和显示。</p></li></ul><p>重构后结构如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="单一职责原则-例子-重构后结构图.jpg" alt="重构后结构图" title>                </div>                <div class="image-caption">重构后结构图</div>            </figure><h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>使用频率：★★★★★</p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote><p>开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。</p></blockquote><ul><li><p><strong>开闭原则</strong>：软件实体应当对扩展开放，对修改关闭。</p></li><li><p><strong>Single Responsibility Rrincipe(SRP)</strong>: Software entities should be open for extension, but closed for modification.</p></li></ul><h1 id="里式代换原则"><a href="#里式代换原则" class="headerlink" title="里式代换原则"></a>里式代换原则</h1><p>使用频率：★★★★★</p><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><blockquote><p>里式代换原则是实现开闭原则的重要方式之一。</p></blockquote><p>里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士Barbara Liskov教授和卡内基·梅隆大学Jeannette Wing教授于1994年提出。</p><blockquote><p>其严格表述如下：</p><p><strong>如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。（f for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is uchanged when o1 is substituted for o2 then S is a subtype of T.</strong>）</p><p>但这个定义不太容易理解。</p></blockquote><p>另一个通俗的定义：</p><ul><li><p><strong>里式代换原则</strong>：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p></li><li><p><strong>Liskov Substitution Principle(LSP)</strong>: Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p></li></ul><h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p>我（People类实例）喜欢（like方法）动物（Animal类），那我一定也喜欢狗（Dog类）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">People i = <span class="keyword">new</span> People();</span><br><span class="line">i.like(Animal.class);</span><br><span class="line">System.out.println(i.isLike(Dog.class)); <span class="comment">// 返回结果应为true</span></span><br></pre></td></tr></table></figure><h1 id="依赖倒转规则"><a href="#依赖倒转规则" class="headerlink" title="依赖倒转规则"></a>依赖倒转规则</h1><p>使用频率：★★★★★</p><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><blockquote><p>如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。</p></blockquote><ul><li><p><strong>依赖倒转原则</strong>：高层模块不应该依赖底层模块，他们都用该依赖抽象。抽象不应该依赖于细节，细节应当依赖于抽象。</p></li><li><p><strong>(Dependency Inversion Principle, DIP)</strong>: High level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.</p></li></ul><p>简单来说，依赖倒转原则要求针对接口编程，不要针对实现编程。</p><h2 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h2><blockquote><p>下面通过一个简单实例来加强对开闭原则、里氏代换原则和依赖倒转原则的理解：</p><p>某软件公司开发人员在开发CRM系统时发现该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。在客户数据操作类CustomerDAO中将调用数据格式转换类的方法来实现数据转换，初始设计方案结构如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="依赖倒转原则-例子-初始设计方案结构图.jpg" alt="初始设计方案结构图" title>                </div>                <div class="image-caption">初始设计方案结构图</div>            </figure></blockquote><p>该结构存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要经常更换数据转换类。</p><p>可以通过抽象数据转换类来解决这个问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="依赖倒转原则-例子-重构后结构图.jpg" alt="重构后结构图" title>                </div>                <div class="image-caption">重构后结构图</div>            </figure><h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>使用频率：★★☆☆☆</p><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><ul><li><p><strong>接口隔离原则</strong>：客户端不应该依赖那些它不需要的接口。</p></li><li><p><strong>Interface Segregation Principle(ISP)</strong>: Clients should not be forced to depend upon interfaces that they do not use.</p></li></ul><blockquote><p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。<strong>每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</strong></p><p>这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p><p>(1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。<br>(2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。</p></blockquote><h2 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h2><blockquote><p>某软件公司开发人员针对CRM系统的客户数据显示模块设计了如图所示的CustomerDataDisplay接口。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="接口隔离原则-例子-初始设计方案结构图.jpg" alt="初始设计方案结构图" title>                </div>                <div class="image-caption">初始设计方案结构图</div>            </figure><ul><li><p>readData()方法用于从文件中读取数据</p></li><li><p>transformToXML()方法用于将数据转换成XML格式</p></li><li><p>createChart()方法用来创建图标</p></li><li><p>displayChart()方法用来显示图标</p></li><li><p>createReport()方法用于创建文字报表</p></li><li><p>displayReport()方法用于显示文字报表</p></li></ul><p>在实际使用过程中发现该接口很不灵活，例如：如果一个具体的数据显示类无需进行数据转换（源文件本身就是XML格式），但由于实现了该接口，将不得不实现其中声明的transformToXML()方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需要实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序在编译时将报错。</p><p>现使用接口隔离原则对其进行重构。</p></blockquote><p>该例中，由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责，一方面导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程序上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。因此需要将该接口按照接口隔离原则和单一职责原则进行重构，将其中的一些方法封装在不同的小接口中，确保每一个接口使用起来都较为方便，并都承担某一单一角色，每个接口中只包含一个客户端（如模块或类）所需的方法即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="接口隔离原则-例子-重构后结构图.jpg" alt="重构后结构图" title>                </div>                <div class="image-caption">重构后结构图</div>            </figure><p><strong>在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。</strong>一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p><h1 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h1><p>使用频率：★★★★☆</p><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><blockquote><p>又称为组合/聚合复用原则（Composition/Aggregate Reuse Principle）</p></blockquote><ul><li><p><strong>合成复用原则</strong>：尽量使用对象组合，而不是继承来达到复用的目的。</p></li><li><p><strong>Composite Reuse Principle(CRP)</strong>: Favor composition of objects over inheritance as a reuse mechanism.</p></li></ul><p>复用时要尽量使用组合/聚合关系（关联关系），少用继承。</p><blockquote><p>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。</p><p>由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。</p></blockquote><p>一般而言，<strong>如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。</strong>“Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。</p><h2 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h2><blockquote><p>某软件公司开发人员在初期的CRM系统设计中考虑到客户数量不多，系统采用MySQL作为数据库，与数据库操作有关的类如CustomerDAO类等都需要连接数据库，连接数据库的方法getConnection()封装在DBUtil类中，由于需要重用DBUtil类的getConnection()方法，设计人员将CustomerDAO作为DBUtil类的子类，初始设计方案结构如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="合成复用原则-例子-初始设计方案结构图.jpg" alt="初始设计方案结构图" title>                </div>                <div class="image-caption">初始设计方案结构图</div>            </figure><p> 随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违反开闭原则。（当然也可以修改DBUtil类的源代码，同样会违反开闭原则。）</p><p>现使用合成复用原则对其进行重构。</p></blockquote><p>根据合成复用原则，我们在实现复用时应该多用关联，少用继承。因此在本实例中我们可以使用关联复用来取代继承复用，重构后的结构如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="合成复用原则-例子-重构后结构图.jpg" alt="重构后结构图" title>                </div>                <div class="image-caption">重构后结构图</div>            </figure><p>CustomerDAO和DBUtil之间的关系由继承关系变为关联关系，采用依赖注入的方式将DBUtil对象注入到CustomerDAO中，可以使用构造注入，也可以使用Setter注入。如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如通过子类OracleDBUtil来连接Oracle数据库。由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。例如在CustomerDAO中注入OracleDBUtil对象，即可实现Oracle数据库连接，原有代码无须进行修改，而且还可以很灵活地增加新的数据库连接方式，符合开闭原则</p><h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><p>使用频率：★★★☆☆</p><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><blockquote><p>迪米特法则来自于1987年美国东北大学(Northeastern University)一个名为“Demeter”的研究项目。迪米特法则又称为最少知识原则(LeastKnowledge Principle, LKP)。</p></blockquote><ul><li><p><strong>迪米特法则</strong>：一个软件实体应当尽可能少地与其他实体发生相互作用。</p></li><li><p><strong>Law of Demeter(LoD)</strong>: Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.</p></li></ul><p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。<strong>迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系</strong>。</p><p>迪米特法则还有几种定义形式，包括：<strong>不要和“陌生人”说话</strong>、<strong>只与你的直接朋友通信</strong>等，在迪米特法则中，对于一个对象，其朋友包括以下几类：</p><p>(1) 当前对象本身(this)；</p><p>(2) 以参数形式传入到当前对象方法中的对象；</p><p>(3) 当前对象的成员对象；</p><p>(4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</p><p>(5) 当前对象所创建的对象。</p><p><strong>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。</strong>在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p><p>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是<strong>通过引入一个合理的第三者来降低现有对象之间的耦合度</strong>。</p><p>在将迪米特法则运用到系统设计中时，要注意下面的几点：<strong>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</strong></p><h2 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h2><blockquote><p>某软件公司所开发CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，例如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变，在初始设计方案中，界面控件之间的交互关系可简化为如下图所示结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="迪米特法则-例子-初始设计方案结构图.jpg" alt="初始设计方案结构图" title>                </div>                <div class="image-caption">初始设计方案结构图</div>            </figure><p>在图1中，由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件。</p><p>现使用迪米特对其进行重构。</p></blockquote><p>在本实例中，可以通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码，重构后结构如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="迪米特法则-例子-重构后结构图.jpg" alt="重构后结构图" title>                </div>                <div class="image-caption">重构后结构图</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;软件的&lt;strong&gt;可维护性（Maintainability）&lt;/strong&gt;和&lt;strong&gt;可复用性（Reusability）&lt;/s
      
    
    </summary>
    
      <category term="Java" scheme="https://gxkord.github.io/categories/Java/"/>
    
    
      <category term="《Java设计模式》" scheme="https://gxkord.github.io/tags/%E3%80%8AJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>第4章 存储器</title>
    <link href="https://gxkord.github.io/2019/03/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC4%E7%AB%A0%20%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>https://gxkord.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/</id>
    <published>2019-03-16T07:05:00.000Z</published>
    <updated>2019-04-08T13:41:11.330Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="存储器分类"><a href="#存储器分类" class="headerlink" title="存储器分类"></a>存储器分类</h2><ol><li><p>按存储介质分类</p><ul><li>半导体存储器（TTL、MOS）</li></ul><blockquote><p>按材料不同，可分为TTL（双极型）半导体存储器和MOS半导体存储器。</p></blockquote><ul><li><p>磁表面存储器（磁头、磁载体）</p></li><li><p>磁芯存储器（硬磁材料、环状元件）</p></li><li><p>光盘存储器（激光、磁光材料）</p></li></ul></li><li><p>按存取方式分类</p><ul><li><p>存取时间与物理地址无关（随机访问）</p><ul><li><p>随机存储器：在<strong>程序的执行过程中</strong>可<strong>读</strong>可<strong>写</strong>。</p></li><li><p>只读存储器：在<strong>程序的执行过程中</strong>只<strong>读</strong>。</p></li></ul></li><li><p>存取时间与物理地址有关（串行访问）</p><ul><li><p>顺序存取存储器（磁带）</p></li><li><p>直接存取存储器（磁盘）</p></li></ul></li></ul></li><li><p>按在计算机中的作用分类</p><ul><li><p>主存储器 </p><ul><li><p>RAM（静态RAM、动态RAM）</p></li><li><p>ROM（MROM、PROM、EPROM、EEPROM）</p></li></ul></li><li><p>Flash Memory</p></li><li><p>高速缓冲存储器（Cache）</p></li><li><p>辅助存储器（如：磁盘、磁带、光盘）</p></li></ul></li></ol><h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><ol><li>存储器三个主要特性的关系</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="存储器三个主要特性的关系.jpg" alt="存储器三个主要特性的关系" title>                </div>                <div class="image-caption">存储器三个主要特性的关系</div>            </figure><ol start="2"><li><p>缓存-主存层次和主存-辅存层次</p><ul><li><p>(1) 主存-辅存层次是为了解决主存容量小的问题。</p><p>辅存容量较大，可以将暂时不需要的数据（或指令）保存起来，主存需要时再读取。</p><p><img src="%E4%B8%BB%E5%AD%98-%E8%BE%85%E5%AD%98%E5%B1%82%E6%AC%A1.jpg" alt="主存-辅存层次"></p><blockquote><p>主存和辅存的整体，称为<strong>虚拟存储器</strong>。主存和辅存的地址空间相互独立，所以虚拟存储器中的数据需要<strong>虚地址（逻辑地址）</strong>来存取。</p><p>相对的，主存中的地址称为<strong>实地址（物理地址）</strong>。</p></blockquote></li><li><p>(2) 缓存-主存层次是为了解决主存速度慢的问题。</p><p>缓存中保存了主存中部分常用数据（或指令）的副本，以提高CPU对这些常用信息（或指令）的读取速度。</p><p><img src="%E7%BC%93%E5%AD%98-%E4%B8%BB%E5%AD%98%E5%B1%82%E6%AC%A1.jpg" alt="缓存-主存层次"></p></li></ul></li></ol><h1 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><ol><li><p>主存的基本组成</p><p>实际上，通过MAR中的地址访问某个存储单元时，还需要经过<em>地址译码</em>、<em>驱动</em>等电路，才能找到所需访问的单元。读出时，需经过<em>读出放大器</em>，才能将选中单元的存储字送到MDR。写入时，MDR中的数据也必须经过<em>写入电路</em>才能真正写入到被选中单元中。</p><p><img src="%E4%B8%BB%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.jpg" alt="主存的基本组成"></p></li><li><p>主存和CPU的联系 </p></li></ol><p><img src="%E4%B8%BB%E5%AD%98%E5%92%8CCPU%E7%9A%84%E8%81%94%E7%B3%BB.jpg" alt="主存和CPU的联系"></p><ol start="3"><li><p>主存中存储单元地址的分配</p><p>12345678H这个数据如何在主存储器中进行存储？</p><ul><li><p>(1) <strong>高位字节</strong>地址为字地址（大端、大尾方式）</p><p><img src="%E5%A4%A7%E7%AB%AF%E3%80%81%E5%A4%A7%E5%B0%BE%E6%96%B9%E5%BC%8F.jpg" alt="大端、大尾方式"></p></li><li><p>(2) <strong>低位字节</strong>地址为字地址（小端、小尾方式）</p><p><img src="%E5%B0%8F%E7%AB%AF%E3%80%81%E5%B0%8F%E5%B0%BE%E6%96%B9%E5%BC%8F.jpg" alt="小端、小尾方式"></p><p>设地址线<strong>24</strong>根——按<strong>字节</strong>寻址——<strong>2^24 = 16MB</strong></p><p>若字长为<strong>16</strong>位——按 <strong>字</strong> 寻址——<strong>8MW</strong></p><p>若字节为<strong>32</strong>位——按 <strong>字</strong> 寻址——<strong>4MW</strong></p></li></ul></li><li><p>主存的技术指标</p><p>(1) 存储容量：主存存放二进制代码的总位数。</p><p>(2) 存储速度 </p><ul><li><p>存取时间：存储器的<strong>访问时间</strong>（读出时间或写入时间）。</p></li><li><p>存取周期：<strong>连续两次独立的存储器操作</strong>（读或写）所需的<strong>最小间隔时间</strong>。（读周期或写周期）</p></li></ul><p>(3) 存储器带宽</p><p>表示单位时间内存储器存取的信息量，单位可用字/秒或字节/秒或位/秒来表示。</p><blockquote><p>计算：若存周期为500ns，每个存储周期可访问16位（数据总线宽度），求它的带宽？</p><p>解：</p><p>$\frac{16位}{50ns} = \frac{16位×10^9}{50秒} = 32M位/秒$</p></blockquote></li></ol><h2 id="半导体存储芯片简介"><a href="#半导体存储芯片简介" class="headerlink" title="半导体存储芯片简介"></a>半导体存储芯片简介</h2><ol><li><p>半导体存储芯片的基本结构</p><p><em>译码驱动</em>能把地址总线送过来的地址信号翻译成对应存储单元的选择信号，该信号在<em>读/写电路</em>的配合下完成对选中单元的读/写操作。</p><p>读/写电路包括读出<em>放大器</em>和<em>写入电路</em>，用来完成读/写操作。</p><p>存储芯片通过地址总线、数据总线和控制总线与外部连接。</p><p><img src="%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg" alt="半导体存储芯片的基本结构"></p><p><img src="%E8%8A%AF%E7%89%87%E5%AE%B9%E9%87%8F%E8%AE%A1%E7%AE%97.jpg" alt="芯片容量计算.jpg"></p><p>片选线：$\overline{CS}$、$\overline{CE}$</p><p>读/写控制线：$\overline{WE}$（低电平写 高电平读）</p><p>  $\overline{OE}$（允许读）、$\overline{WE}$（允许写）</p><p><strong>存储芯片片选线的作用</strong>：</p><p>用16K × 1位的存储芯片组成64K × 8位的存储器：</p><p>![32片存储芯片组成64K × 8位的存储器](用16K × 1位的存储芯片组成64K × 8位的存储器.jpg)</p><p>当地址为65535时，</p><p>由于$64K = 64 × 2^{10} = 65536$，显然，65535保存在最后一组（右）。</p><p>可以在最后一组的芯片的同一位置各存放一位数据组成一个字符（共8位）。</p></li><li><p>半导体存储芯片的译码驱动方式</p><p>(1) 线选法</p><blockquote><p><strong>译码器</strong>：</p><p>以<strong>二次译码器</strong>为例，2个输入，4个输出。若输入00，则<em>输出线0</em>有效，其他输出线无效；若输入01，则<em>输出线1</em>有效，其他输出线无效。</p></blockquote><p>下图的<strong>地址译码器</strong>与之类似。输入有四个(A1,A2,A3,A4)，输出有16个（2^4，与输入相对应）。</p><p><strong>读/写控制电路</strong>用来表示位，位线的数量与位数相等。</p><p><img src="%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F-%E7%BA%BF%E9%80%89%E6%B3%95.jpg" alt="线选法"></p><p>而对于容量大(m × n)的半导体存储芯片，若使用线选法，则需要大量的数据线(logm + n条)。这<strong>严重增加了集成芯片的难度</strong>。</p><p>(2) 重合法</p><p>下图有两根MOS管，用来控制电流的流向，从而切换译码器。</p><p>对于m × n的半导体存储芯片，若使用重合法，则需要log(m+n)条数据线。</p><p><img src="%E5%8D%8A%E5%AF%BC%E4%BD%93%E5%AD%98%E5%82%A8%E8%8A%AF%E7%89%87%E7%9A%84%E8%AF%91%E7%A0%81%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F-%E9%87%8D%E5%90%88%E6%B3%95.jpg" alt="重合法"></p></li></ol><h2 id="随机存取存储器"><a href="#随机存取存储器" class="headerlink" title="随机存取存储器"></a>随机存取存储器</h2><ol><li><p><strong>静态RAM（SRAM）</strong></p><blockquote><p>Q：</p><ul><li><p>保存0和1的原理是什么？</p></li><li><p>基本单元电路的构成是什么？</p></li><li><p>对单元电路如何读出和写入？</p></li><li><p>典型芯片的结构是什么样子的？</p></li><li><p>静态RAM芯片如何进行读出和写入操作？</p></li></ul></blockquote><p>(1) 静态RAM基本电路</p><blockquote><p>有哪些保存0和1的方式？</p><ul><li><p>开关（开：1；关：0）</p></li><li><p>熔丝（连通：1；断开：0）- 难以更改</p></li><li><p><strong>触发器</strong></p></li></ul></blockquote><p>T1~T4：由MOS管组成的触发器（用来存放0和1）</p><p>T5、T6：行开关</p><p>T7、T8：列开关</p><p>A：触发器原端</p><p>A’：触发器非端</p><p><img src="%E9%9D%99%E6%80%81RAM.jpg" alt="静态RAM"></p><p>① 静态RAM基本电路的<strong>读</strong>操作</p><p>行选 → T5、T6开</p><p>列选 → T7、T8开</p><p>读操作有效</p><p>VA → T6 → T8 → 读放 → Dout</p><p><img src="%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF%E7%9A%84%E8%AF%BB%E6%93%8D%E4%BD%9C.jpg" alt="静态RAM基本电路的读操作"></p><p>② 静态RAM基本电路的<strong>写</strong>操作</p><p>行选 → T5、T6开</p><p>列选 → T7、T8开</p><p>写操作有效</p><p>DIN → 两个写放</p><p> DIN(左) → 反相 → T7 → T5 → A‘</p><p> DIN(右) → T8 → T6 → A</p><p><img src="%E9%9D%99%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E7%94%B5%E8%B7%AF%E7%9A%84%E5%86%99%E6%93%8D%E4%BD%9C.jpg" alt="静态RAM基本电路的写操作"></p><p>(2) 静态RAM芯片举例（简单了解）</p><p>①  Intel2114外特性 </p><p><img src="Intel2114%E5%A4%96%E7%89%B9%E6%80%A7.jpg" alt="Intel2114外特性"></p><p>② Intel2114 RAM矩阵(64 × 64) - 读</p><p><img src="Intel2114-RAM%E7%9F%A9%E9%98%B564%C3%9764-%E8%AF%BB.jpg" alt="Intel2114 RAM矩阵(64 × 64) - 读"></p><p>③ Intel2114 RAM矩阵(64 × 64) -写</p><p><img src="Intel2114-RAM%E7%9F%A9%E9%98%B564%C3%9764-%E5%86%99.jpg" alt="Intel2114 RAM矩阵(64 × 64)-写"></p></li><li><p>动态RAM（DRAM）</p><blockquote><p>Q：</p><ul><li><p>保存0和1的原理是什么？</p></li><li><p>基本单元电路的构成是什么？</p></li><li><p>对单元电路如何读出和写入？</p></li><li><p>典型芯片的结构是什么样子的？</p></li><li><p>动态RAM芯片如何进行读出和写入操作？</p></li><li><p>动态RAM为什么要刷新，刷新方法？</p></li></ul></blockquote><p>(1) 动态RAM基本单元电路</p><p>靠电容存储电荷的原理来寄存信息。若电容上存在足够多的电荷表示存“1”，电容上无电荷表示存“0”。</p><ul><li><p>三管式</p><blockquote><ul><li><p><strong>读出</strong>时，先对<em>预充电管T4</em>置一<em>预充电信号</em>，使读数据线达到高电平VDD。然后由读选择线打开T2，若<em>T1的极间电容Cg</em>存有足够电荷（被认为原存“1”），使T1导通，则因T2、T1接地，使读数据线降为零电平，读出“0”信息；若Cg没有足够电荷（原存“0”），则T1截止，读数据线为高电平不变，读出“1”信息。可见，读出线的高低电平可以区分“1”和“0”，且<strong>读出与原存信息相反</strong>。</p></li><li><p>写入时，将写信号加到写数据线上，然后由写数据线打开T3，这样，Cg便能随输入信息充电（写“1”）或放电（写“2”），且<strong>写入与输入信息相同</strong>。</p></li></ul></blockquote><p><img src="%E5%8A%A8%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF-%E4%B8%89%E7%AE%A1%E5%BC%8F.jpg" alt="三管MOS动态RAM基本单元电路"></p></li><li><p>单管式</p><blockquote><p>为了提高集成度，将三管电路简化为单管。</p><ul><li><p>去掉T1，将信息保存到电容 Cs中。</p></li><li><p>将T2、T3合并为一个管子T。</p></li><li><p><strong>读出</strong>时，字线上的高电平使T接通，若Cs有电荷，视为“1”；若Cs无电荷，视为“0”。（读出结束时，Cs中电荷释放完毕，所以为破坏性读出，必须再生。）</p></li><li><p><strong>写入</strong>时，字线上的高电平使T接通，若数据线为高电平，经过T对Cs充电，使其存“1”；若数据线为低电平，Cs经T放电，使其存“0”。</p></li></ul></blockquote><p><img src="%E5%8A%A8%E6%80%81RAM%E5%9F%BA%E6%9C%AC%E5%8D%95%E5%85%83%E7%94%B5%E8%B7%AF-%E5%8D%95%E7%AE%A1%E5%BC%8F.jpg" alt="单管MOS动态RAM基本单元电路"></p></li></ul><p>(2) 动态RAM芯片举例</p><p>① 三管动态RAM芯片(Intel 1103) - 读</p><p><img src="%E4%B8%89%E7%AE%A1%E5%8A%A8%E6%80%81RAM%E8%8A%AF%E7%89%87-Intel1103-%E8%AF%BB.jpg" alt="三管动态RAM芯片(Intel 1103) - 读"></p><p>② 三管动态RAM芯片(Intel 1103) - 写</p><p><img src="%E4%B8%89%E7%AE%A1%E5%8A%A8%E6%80%81RAM%E8%8A%AF%E7%89%87-Intel1103-%E5%86%99.jpg" alt="三管动态RAM芯片(Intel 1103) - 写"></p><p>③ 单管动态RAM 4116 (16K × 1位)外特性</p><p><img src="%E5%8D%95%E7%AE%A1%E5%8A%A8%E6%80%81RAM4116-16K%C3%971%E4%BD%8D-%E5%A4%96%E7%89%B9%E6%80%A7.jpg" alt="单管动态RAM 4116 (16K × 1位)外特性"></p><p>④ 4116(16K × 1位)芯片<strong>读</strong>原理</p><p><img src="%E5%8A%A8%E6%80%81RAM4116-16K%C3%971%E4%BD%8D%E8%8A%AF%E7%89%87-%E8%AF%BB.jpg" alt="4116(16K × 1位)芯片**读**原理"></p><p>⑤ 4116(16K × 1位)芯片<strong>写</strong>原理</p><p><img src="%E5%8A%A8%E6%80%81RAM4116-16K%C3%971%E4%BD%8D%E8%8A%AF%E7%89%87-%E5%86%99.jpg" alt="4116(16K × 1位)芯片**写**原理"></p><p>(4) 动态RAM刷新（刷新与行地址有关）</p><p>① 集中刷新（存取周期为0.5μs）</p><p>以128 × 128为例：</p><p><img src="%E5%8A%A8%E6%80%81RAM%E7%9A%84%E5%88%B7%E6%96%B0-%E9%9B%86%E4%B8%AD%E5%88%B7%E6%96%B0.jpg" alt="集中刷新时间分配示意图"></p><p><strong>“死区”</strong>为 $0.5μs × 128 = 64μs$</p><p><strong>“死时间率”</strong>为 $128/4000 × 100% = 3.2%$</p><p>② 分散刷新（存取周期1μs）</p><p>以128 × 128为例：</p><p><img src="%E5%8A%A8%E6%80%81RAM%E7%9A%84%E5%88%B7%E6%96%B0-%E5%88%86%E6%95%A3%E5%88%B7%E6%96%B0.jpg" alt="分散刷新时间分配示意图"></p><p><strong>无“死区”</strong></p><p>存取周期为$0.5μs + 0.5μs = 1μs$（<strong>周期变长，性能降低</strong>）</p><p>③ 异步刷新（分散刷新与集中刷新相结合）（存储周期为0.5μs）</p><p>对于128×128的存储芯片：</p><p>若每隔<strong>15.6μs</strong>刷新一行</p><p><img src="%E5%8A%A8%E6%80%81RAM%E7%9A%84%E5%88%B7%E6%96%B0-%E5%BC%82%E6%AD%A5%E5%88%B7%E6%96%B0.jpg" alt="异步刷新时间分配示意图"></p><p>每行每隔<strong>2ms</strong>刷新一次</p><p>死区为<strong>0.5μs</strong></p><p><strong>将刷新安排在指令译码阶段，不会出现“死区”问题。</strong></p></li><li><p>动态RAM和静态RAM的比较</p></li></ol><table><thead><tr><th></th><th>DRAM</th><th>SRAM</th></tr></thead><tbody><tr><td>存储原理</td><td>电容</td><td>触发器</td></tr><tr><td>集成度</td><td>高</td><td>低</td></tr><tr><td>芯片引脚</td><td>少</td><td>多</td></tr><tr><td>功耗</td><td>小</td><td>大</td></tr><tr><td>价格</td><td>低</td><td>高</td></tr><tr><td>速度</td><td>慢</td><td>快</td></tr><tr><td>刷新</td><td>有</td><td>无</td></tr></tbody></table><p>   DRAM（动态RAM）常用于做主存；SRAM（静态RAM）常用于做缓存。</p><h2 id="只读存储器（ROM）"><a href="#只读存储器（ROM）" class="headerlink" title="只读存储器（ROM）"></a>只读存储器（ROM）</h2><ul><li><p>早期的只读存储器——由厂家写内容</p></li><li><p>改进1——用户可以自己写（一次性）</p></li><li><p>改进2——可以多次写（要能对信息进行擦除）</p></li><li><p>改进3——电可擦写（特定设备）</p></li><li><p>改进4——电可擦写（直接连接到计算机）</p></li></ul><ol><li><p>掩模ROM（MROM）</p><p>行列选择交叉处有MOS管为“1”</p><p>行列选择交叉处无MOS管为“0”</p></li><li><p>PROM（一次性编程）</p><p><img src="ROM-PROM.jpg" alt="PROM"></p><p>熔丝断：为“0”</p><p>熔丝未断：为“1”</p></li><li><p>EPROM（多次性编程）</p><p>N型沟道浮动栅MOS电路</p><p><img src="ROM-EPROM.jpg" alt="EPROM"></p><p>D端加正电压——形成浮动栅——S与D不导通为“0”</p><p>D端不加正电压——不形成浮动栅——S与D导通为“1”</p><p><strong>使用紫外线驱散浮动栅（擦除过程麻烦）</strong></p></li><li><p>EEPROM（多次编程）</p><p>电可擦写</p><p>局部擦写</p><p>全部擦写</p></li><li><p>Flash Memory（闪速型存储器）</p></li></ol><blockquote><p>EPROM —— 价格便宜 集成度高</p><p>EEPROM —— 电可擦洗重写</p><p>Flash Memory —— 比EEPROM快 具备RAM功能</p></blockquote><h2 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h2><ol><li><p>存储器容量的扩展</p><ul><li><p>(1) 位扩展（增加存储字长）</p><p>用<strong>2片</strong>1K × 4位存储芯片组成1K × 8位的存储器</p><blockquote><p>1K → 10根地址线</p><p>8位 → 8根数据线</p></blockquote><p><img src="%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95-%E4%BD%8D%E6%89%A9%E5%B1%95.jpg" alt="由2片1K×4位的芯片组成1K×8位的存储器"></p></li><li><p>(2) 字扩展</p><p>用<strong>2片</strong>1K × 8位存储芯片组成2K × 8位的存储器</p><blockquote><p>2K → 11根地址线</p><p>8位 → 8根数据线</p></blockquote><p><img src="%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95-%E5%AD%97%E6%89%A9%E5%B1%95.jpg" alt="由2片1K×8位的芯片组成2K×8位的存储器"></p></li><li><p>(3) 字、位同时扩展</p><p>用<strong>8片</strong>1K × 4位存储芯片组成4K × 8位的存储器</p><blockquote><p>4K → 12根地址线</p><p>8位 → 8根数据线</p></blockquote><p><img src="%E5%AD%98%E5%82%A8%E5%99%A8%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95-%E5%AD%97%E4%BD%8D%E5%90%8C%E6%97%B6%E6%89%A9%E5%B1%95.jpg" alt="由8片1K×4位存储芯片组成4K×8位的存储器"></p></li></ul></li><li><p>存储器与CPU的连接</p><p>(1) 地址线的连接 </p><p>(2) 数据线的连接</p><p>(3) 读/写命令线的连接</p><p>(4) 片选线的连接</p><p>(5) 合理选择存储芯片</p><p>(6) 其他（时序、负载）</p><blockquote><p> 例4.1、例4.2。</p></blockquote></li></ol><h2 id="存储器的校验"><a href="#存储器的校验" class="headerlink" title="存储器的校验"></a>存储器的校验</h2><ol><li><p>为什么要对存储器的信息进行校验？</p></li><li><p>为了能够校验出信息是否正确，如何进行编码？</p></li><li><p>检测和纠错能力与什么因素有关？</p></li><li><p>校验出信息出错后是如何进行纠错的？</p></li><li><p>除了教材上讲的校验码，你还知道哪些容错编码？原理是什么？</p></li></ol><blockquote><ul><li><p>合法代码集合</p><ol><li><p>{000, 001, 010, 011, 100, 101, 110, 111}</p><p>若出现错误代码，不会被发现。</p><p><strong>检0位错，纠0位错。</strong></p></li><li><p>{000, 011, 101, 110}（代码中1的个数为偶数。）</p><p>若出现错误代码100，能检测到1位错，但并不能纠错（来源可能是000或101或110）。</p><p><strong>检1位错，纠0位错。</strong></p></li><li><p>{000, 111}（3位表示1位）</p><p>若出现错误代码100，几乎可以认定是第1位出错了（正确代码为000）。</p><p>若出现错误代码110，几乎可以认定是第3位出错了（正确代码为111）。</p><p><strong>检1位错，纠1位错。</strong></p></li><li><p>{0000, 1111}（4位表示1位）</p><p>若出现错误代码1000，几乎可以认定是第1位出错了（正确代码为0000）。</p><p>若出现错误代码1100，几乎可以认定是第1位出错了（正确代码无法确定）。</p><p><strong>检2位错，纠1位错。</strong></p></li><li><p>{00000, 11111}（5位表示1位）</p><p>若出现错误代码11000，几乎可以认定第2、3位出错了（正确代码为00000）。</p><p>若出现错误代码11100，几乎可以认定第4、5位出错了（正确代码为11111）。</p><p><strong>检2位错，纠2位错。</strong></p></li></ol></li></ul></blockquote><ol><li><p>编码的最小距离</p><p>指任意两组合法代码之间<strong>二进制位</strong>的<strong>最少差异数</strong>。</p><p><strong>编码的纠错、检错能力与编码的最小距离有关。</strong></p><p>$L - 1 = D + C (D &gt;= C)$</p><blockquote><p>L —— 编码的最小距离</p><p>D —— 检测错误的位数</p><p>C —— 纠正错误的位数</p></blockquote><p>例如，当L=3时，这种编码可视为最多能检错二位，或能检错一位、纠错一位。</p><p><strong>汉明码是具有一位纠错能力的编码。</strong></p></li><li><p>汉明码的组成</p><ul><li><p>汉明码采用奇偶检验</p></li><li><p>汉明码采用分组检验</p></li></ul><p>若要储存的信息为00100011，增加1位校验位<strong>1</strong>00100011，使‘1’的个数为偶数。若读出的信息中‘1’的个数为奇数，即可检1位错。</p><blockquote><p>一种分组方式（基于划分的分组方式）：可以采用4位一组，得到<strong>1</strong>0010 <strong>0</strong>0011，若前五位中‘1’为奇数，则前五位有1位错，这样就能大大缩短需要检错的范围。</p></blockquote><ul><li><p>汉明码的分组是一种非划分方式。</p><ul><li><p>若有7位数据（1 - 2 - 3 - 4 - 5 - 6 - 7），将其分成3组，每组有1位校验位，共包含4位数据位。如下图所示：</p><p><img src="%E6%B1%89%E6%98%8E%E7%A0%81%E5%88%86%E7%BB%84%E6%96%B9%E5%BC%8F.jpg" alt="汉明码分组方式"></p><p>按上图方式对三组数据进行奇偶校验（异或），得到校验结果$P_3$，$P_2$，$P_1$。（校验结果为1则该组出错）</p><p>结论如下：</p><p><img src="%E6%B1%89%E6%98%8E%E7%A0%81%E5%88%86%E7%BB%84-%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%BB%93%E6%9E%9C.jpg" alt="汉明码分组-奇偶校验结果"></p></li><li><p>如何分组？</p><p>第1组：XXXX1（1）</p><p>第2组：XXX1X（2）</p><p>第3组：XX1XX（4）</p><p>第4组：X1XXX（8）</p><p>以此类推……</p></li></ul></li><li><p>汉明码的组成需要添加多少位检测位？</p><p>$2^k&gt;=n+k+1$</p></li><li><p>检测位的位置？</p><p>$2^i(i=0,1,2,3,…)$</p></li><li><p>检测位的取值？</p><p>与该位所在的检测“小组”所承担的奇偶校验任务有关。</p><blockquote><p>各检测位$C_i$所承担的检测小组为：</p><p><strong>$C_1$</strong>检测的g1小组包含第1, 2, 3, 7, 9, 11, …位（二进制编码为X…XXX1）</p><p><strong>$C_2$</strong>检测的g2小组包含第2, 3, 6, 7, 10, 11, …位（二进制编码为X…XX1X）</p><p><strong>$C_4$</strong>检测的g3小组包含第4, 5, 6, 7, 12, 13, …位（二进制编码为X…X1XX）</p><p><strong>$C_8$</strong>检测的g4小组包含第8, 9, 10, 11, 12, 13, …位（二进制编码为X…1XXX）</p><p>……</p><p>$g_i$小组独占$2^{i-1}$位，二进制编码为0…10…0</p><p>$g_i$和$g_j$小组共同占第$2^{i-1}+2^{j-1}$位，二进制编码为0…010…010…0</p><p>$g_i$、$g_j$和$g_l$小组共同占第$2^{i-1}+2^{j-1}+2^{l-1}$位</p></blockquote></li></ul><blockquote><p><strong>例题</strong>：求0101按“偶校验”配置的汉明码？</p><p><strong>解</strong>：</p><p>$∵n=4$</p><p>根据$2^k&gt;=n+k+1$，得$k=3$</p><p>汉明码排序如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="汉明码-例题.jpg" alt="汉明码排序" title>                </div>                <div class="image-caption">汉明码排序</div>            </figure><p>$C_1=3⊕5⊕7=0$</p><p>$C_2=3⊕6⊕7=1$</p><p>$C_4=5⊕6⊕7=0$</p><p>$∴$ 0101的汉明码为 <strong>0100101</strong></p></blockquote></li><li><p>汉明码的纠错过程</p><p>形成新的检验位$P_i$，其位数与增添的检测位有关，</p><p>如增添3位（k=3），新的检测位$P_4$、$P_2$、$P_1$</p><p>以k=3位例，$P_i$的取值为：</p><p>  $P_1=1⊕3⊕5⊕7$</p><p>  $P_2=2⊕3⊕6⊕7$</p><p>  $P_4=4⊕5⊕6⊕7$</p><p>对于按“偶校验”配置的汉明码：</p><p>不出错时， $P_1=0$，$P_2=0$，$P_4=0$</p><blockquote><p><strong>例题</strong>：已知接收的汉明码为0100111，</p><p>（按配偶原则配置）试问要求传送的信息是什么？</p><p><strong>解</strong>：</p><p>纠错过程如下：</p><p>$P_1=1⊕3⊕5⊕7=0$ 无错</p><p>$P_2=2⊕3⊕6⊕7=1$ 有错</p><p>$P_4=4⊕5⊕6⊕7=1$ 有错</p><p>即第6位出错，可纠正为01001<strong>0</strong>1，</p><p>故要求传送的信息为<strong>0101</strong>。</p></blockquote></li></ol><h2 id="提高访问速度的措施"><a href="#提高访问速度的措施" class="headerlink" title="提高访问速度的措施"></a>提高访问速度的措施</h2><ul><li><p>采用高速器件</p></li><li><p>采用层次结构欧Cache-主存</p></li><li><p><strong>调整主存结构</strong></p></li></ul><ol><li><p>单体多字系统</p><p>由于程序和数据在存储体内是连续存放的，因此CPU访存取出的信息也是连续的，如果可在一个存储周期内，从<strong>同一地址</strong>取出4条指令，然后再逐条送至CPU执行，即每隔1/4存取周期，主存向CPU送一条指令，这样显然<strong>增大了存储器的带宽</strong>，提高了单体存储器的工作速度，如下图所示。</p><p><img src="%E5%8D%95%E4%BD%93%E5%A4%9A%E5%AD%97%E7%B3%BB%E7%BB%9F.jpg" alt="单体多字系统"></p><p>存在的问题：</p><ul><li><p>若只需向存储体写入16位数据（单字长），而数据寄存器却多读出了48位，若想让这48位不存入存储体，会增加寄存器的复杂性。</p></li><li><p>若需要取出的数据（或指令）不是连续的，必然会使数据寄存器取出无用的数据。</p></li></ul><blockquote><p>虽然单体多字系统把数据分开存取，但它们依然是以整体的方式存在的。</p></blockquote></li><li><p>多体并行系统</p><ul><li><p>高位交叉（顺序编址）</p><p><img src="%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F-%E9%AB%98%E4%BD%8D%E4%BA%A4%E5%8F%89.jpg" alt="多体并行系统-高位交叉"></p><p>存在的问题：</p><ul><li><p>某个存储体可能会非常繁忙，其余存储体空闲。</p></li><li><p>这种方式主要适用于存储器容量的扩展，并不适合提高存储器的带宽。</p></li></ul></li><li><p>低位交叉（各个体轮流编址）</p><p><img src="%E5%A4%9A%E4%BD%93%E5%B9%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F-%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89.jpg" alt="多体并行系统-低位交叉"></p><p><strong>低位交叉的特点</strong>：</p><p>在不改变存储周期的前提下，增加存储器的带宽。</p><p><img src="%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89-4%E4%B8%AA%E5%AD%98%E5%82%A8%E4%BD%93%E4%BA%A4%E5%8F%89%E8%AE%BF%E9%97%AE%E7%9A%84%E6%97%B6%E9%97%B4%E5%85%B3%E7%B3%BB.jpg" alt="4个存储体交叉访问的时间关系"></p><p>以四体低位交叉存储器为例，存储周期位$T$，总线传输周期为$τ$，为实现流水线方式存取，应满足$T=4τ$。</p><p><img src="%E5%9B%9B%E4%BD%93%E4%BD%8E%E4%BD%8D%E4%BA%A4%E5%8F%89%E7%BC%96%E5%9D%80%E5%AD%98%E5%82%A8%E5%99%A8%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="四体低位交叉编址存储器流水线工作方式示意图"></p><p>连续读取4个字所需时间位$T+(4-1)τ$</p></li></ul></li><li><p>高性能存储芯片</p><ul><li><p>SDRAM(同步RAM)</p><p>在系统时钟的控制下进行读出和写入。</p><p><strong>CPU无须等待</strong>。</p></li><li><p>RDRAM</p><p>由<strong>Rambus</strong>开发，主要解决<strong>存储器带宽</strong>问题。</p></li><li><p>带Cache的DRAM</p><p>在DRAM的芯片内<strong>集成</strong>了一个由<strong>SRAM</strong>组成的<strong>Cache</strong>，有利于<strong>猝发式读取</strong>。</p></li></ul></li></ol><h1 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><ol><li><p>问题的提出</p><p>避免CPU“空等”现象</p><p>CPU和主存（DRAM）的速度差异</p><p><img src="Cache%E7%9A%84%E6%8F%90%E5%87%BA.jpg" alt="Cache的提出"></p><p><strong>程序访问的局部性原理</strong>：指令和数据在主存的地址分布不是随机的，而是相对的簇聚，使得CPU在执行程序时，访存具有相对的局部性。</p></li><li><p>Cache工作原理</p><ul><li><p>(1) 主存和缓存的编址</p><p><img src="Cache-%E4%B8%BB%E5%AD%98%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.jpg" alt="Cache-主存存储空间的基本结构"> </p><p><strong>主存和缓存按块存储，块的大小相同。</strong></p><blockquote><p>实际上，缓存中块内地址的意义不大。这是因为主存的块内地址和缓存中的块内地址位数是相同的，而且“块”在主存和Cache之间是整体传输的，块内字节顺序不会发生变化。</p><p>缓存中的标记，是用来保存对应主存块号的。若CPU给出一个内存地址，并希望在缓存中访问到这个地址，首先要对比缓存中的标记，确定该块是否已经被读取到了Cache中。</p></blockquote></li><li><p>(2) 命中与未命中</p><p>缓存共有C块，主存共有M块（M&gt;&gt;C）</p><ul><li><p><strong>命中</strong></p><p>主存块<strong>调入</strong>缓存</p><p>主存块与缓冲块<strong>建立</strong>了对应关系</p><p>用<strong>标记</strong>记录与某缓存块建立了对应的<strong>主存块号</strong></p></li><li><p>未命中</p><p>主存块<strong>未调入</strong>缓存</p><p>主存块与缓冲块<strong>未建立</strong>对应关系</p></li></ul></li><li><p>(3) Cache的命中率</p><p>CPU欲访问的信息在Cache中的<strong>比率</strong></p><p><strong>命中率</strong>与Cache的<strong>容量</strong>与<strong>块长</strong>有关</p><p>一般每块可取4~8个字</p><p><strong>块长取一个存取周期内从主存调出的信息长度</strong></p></li><li><p>(4) Cache - 主存系统的效率</p><p>效率<strong>e</strong>与<strong>命中率</strong>有关</p><p>$e=\frac{访问Cache的时间}{平均访问时间}×100%$</p><p>设Cache<strong>命中率</strong>为h，访问<strong>Cache</strong>的时间为$t_c$，访问<strong>主存</strong>的时间为$t_m$，</p><p>则$e=\frac{t_c}{h×t_c+(1-h)×t_m}×100%$</p></li></ul></li><li><p>Cache的基本结构</p><p><img src="Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86%E6%A1%86%E5%9B%BE.jpg" alt="Cache的基本结构原理框图"></p><blockquote><p>CPU（通过<strong>地址总线</strong>）给出地址，这个地址包括<strong>（主存）块号</strong>和<strong>块内地址</strong>。块内地址直接传给Cache，使用块号在<strong>主存Cache地址映像机构</strong>中确认<strong>是否命中</strong>。如果发生命中，得到Cache的块号；如果未命中，查看Cache中<strong>是否有空间可装入主存块</strong>。若有，访问主存装入Cache；若没有，启用<strong>Cache替换机构</strong>，根据替换算法，决定Cache中哪块可以被替换，然后<strong>访问主存替换Cache</strong>即可。</p></blockquote></li><li><p>Cache的<strong>读写</strong>操作</p><ul><li><p><strong>读</strong></p><p><img src="Cache%E7%9A%84%E8%AF%BB%E6%95%B0%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B.jpg" alt="Cache的读数操作流程"></p></li><li><p><strong>写</strong></p><ul><li><p>写直达法（Write-through）</p><p>写操作时数据既写入Cache又写入主存</p><p><strong>写操作时间就是访问主存时间</strong>，Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现</p></li><li><p>写回法（Write-back）</p><p>写操作只把数据写入Cache而不写入主存</p><p>当Cache数据被替换出去时才写回主存</p></li></ul></li></ul></li><li><p>Cache的改进</p><ul><li><p>(1) 增加Cache的级数</p><p>片载（片内）Cache</p><p>片外Cache</p></li><li><p>(2) 统一缓存和分立缓存</p><ul><li><p>统一缓存：指令和数据放在同一缓存内的Cache</p></li><li><p>分立缓存：分成指令Cache、数据Cache</p></li></ul><blockquote><p>两种缓存的选取主要考虑两个因素：</p><ul><li><p>与主存结构有关。如果计算机的主存是统一的（指令和数据存储在统一主存中），则相应的Cache采用统一缓存；如果主存采用指令、数据分开存储的方案，则相应的Cache采用分立缓存。</p></li><li><p>与指令执行的控制方式有关。当采用超前控制或流水线控制方式时，一般采用分立缓存。</p></li></ul></blockquote></li></ul></li></ol><h2 id="Cache-主存地址映射"><a href="#Cache-主存地址映射" class="headerlink" title="Cache-主存地址映射"></a>Cache-主存地址映射</h2><ol><li><p>直接映射</p><p><img src="Cache-%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84-%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84.jpg" alt="直接映射"></p><blockquote><p>根据Cache存储体的大小将主存储体划分成多个区，每个区与Cache存体大小相同。</p></blockquote><p><strong>每个缓存块i</strong>可以和<strong>若干</strong>个<strong>主存块</strong>对应。</p><p><strong>每个主存块j</strong>只能和<strong>一</strong>个<strong>缓存块</strong>对应。</p><p><strong>优点</strong>：实现简单，只需利用主存地址的某些位直接判断，就可确定所需字块是否在缓存中。</p><p><strong>缺点</strong>：不够灵活，因每个内存块只能固定地对应某个缓存块，即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分的利用。此外，如果程序恰好要重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率。</p><blockquote><p><em>例题：设主存容量为1MB，采用直接映射方式的Cache容量为16KB，块长为4，每字32位。试问主存地址位ABCDEH的存储单元在Cache中的什么位置？</em></p><p>解：</p><p>每块容量：$4×\frac{32}{8}=16B=2^4B$，即<strong>字块内地址4位</strong>。</p><p>块数：$\frac{16KB}{16B}=1K=1024$，即<strong>Cache字块地址10位</strong>。</p><p>主存容量$1MB=2^{20}B$，即地址总格式20位，分为$\frac{1MB}{4×\frac{32}{8}B}=2^{16}$块，每块$2^4B$，采用直接映射方式，主存字块标记为$20-14=6$位。</p><p>综上，主存地址格式为：</p><p><strong>主存字块标记（6位）Cache字块地址（10位）字块内地址（4位）</strong></p><p>主存地址$ABCDEH=(1010 1011 1100 1101 1110)_2$，主存字块标记为<strong>101010</strong>，Cache字块地址为<strong>1111001101</strong>，字块内地址为<strong>1110</strong>，<strong>故该主存单元应映射到Cache的101010块的第1110字节，即第42块第14字节位置</strong>。</p></blockquote></li><li><p>全相联映射</p><p>允许主存中每一字块映射到Cache中的任何一块位置上。</p><p><strong>优点</strong>：灵活，命中率高，缩短了块冲突率。</p><p><strong>缺点</strong>：</p><p>(1) 主存字块标记需要与Cache的所有标记进行<strong>同时</strong>比较，电路会非常复杂。</p><p>(2) 主存字块标记从t位增加到t+c位，这就使Cache”标记“的位数增多，比较器的长度就会增长。</p></li><li><p>组相联映射</p><blockquote><p>组相联映射是对直接映射和全相联映射的一种折中。</p></blockquote><p><img src="Cache-%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84-%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84.jpg" alt="组相联映射"></p><p>$i = jmodQ$</p><p><strong>某一主存块j</strong>按模<strong>Q</strong>映射到<strong>缓存</strong>的<strong>第i组</strong>中的<strong>任一块</strong>。</p></li></ol><h2 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h2><ol><li><p>先进先出（FIFO）算法</p></li><li><p>近期最少使用（LRU）算法 </p></li><li><p>随机法</p></li></ol><h1 id="辅助存储器（非重要）"><a href="#辅助存储器（非重要）" class="headerlink" title="辅助存储器（非重要）"></a>辅助存储器（非重要）</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><ol><li><p>特点</p><p>不直接与CPU交换信息。</p></li><li><p>磁表面存储器的技术指标</p><p>(1) 记录密度（道密度$D_t$、位密度$D_b$）</p><p>(2) 存储容量</p><blockquote><p>$C=n×k×s$，n为存放信息的盘面数，k为每个盘面的磁道数，s为每条磁道上记录的二进制代码数。</p></blockquote><p>(3) 平均寻址地址</p><blockquote><p>寻道时间 + 等待时间</p></blockquote><blockquote><p>辅存的速度：寻址时间、磁头读写时间</p></blockquote><p>(4) 数据传输率</p><blockquote><p>$D_r=D_b×V$</p></blockquote><p>(5) 误码率</p><blockquote><p>出错信息位数与读取信息的总位数。 </p></blockquote></li></ol><h2 id="磁记录原理和记录方式"><a href="#磁记录原理和记录方式" class="headerlink" title="磁记录原理和记录方式"></a>磁记录原理和记录方式</h2><ol><li><p>磁记录原理</p><p><strong>写</strong>：</p><p><img src="%E7%A3%81%E8%AE%B0%E5%BD%95%E5%8E%9F%E7%90%86-%E5%86%99.jpg" alt="磁记录原理-写"></p><p><strong>读</strong>：</p><p><img src="%E7%A3%81%E8%AE%B0%E5%BD%95%E5%8E%9F%E7%90%86-%E8%AF%BB.jpg" alt="磁记录原理-读"></p></li></ol><h2 id="硬磁盘存储器"><a href="#硬磁盘存储器" class="headerlink" title="硬磁盘存储器"></a>硬磁盘存储器</h2><ol><li><p>硬磁盘存储器的类型</p><p>(1) 固定磁头和移动磁头</p><p>(2) 可换盘和固定盘</p></li><li><p>硬磁盘存储器结构</p><p><img src="%E7%A1%AC%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%BB%93%E6%9E%84.jpg" alt="硬磁盘存储器结构"></p><p>(1) 磁盘驱动器</p><p><img src="%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8.jpg" alt="磁盘驱动器"></p><p>(2) 磁盘控制器</p><ul><li><p>接收主机发来的命令，转换成磁盘驱动器的控制命令。</p></li><li><p>实现主机和驱动器之间的数据格式转换。</p></li><li><p>控制磁盘驱动器读写。</p><p><strong>磁盘控制器</strong>是主机与磁盘驱动器之间的<strong>接口</strong>。</p></li></ul><p>(3) 盘片</p><p>由硬质铝合金材料制成。</p></li></ol><h2 id="软磁盘存储器"><a href="#软磁盘存储器" class="headerlink" title="软磁盘存储器"></a>软磁盘存储器</h2><ol><li>概述</li></ol><table><thead><tr><th></th><th>硬盘</th><th>软盘</th></tr></thead><tbody><tr><td>速度</td><td>高</td><td>低</td></tr><tr><td>磁头</td><td>固定、活动（浮动）</td><td>活动（接触盘片）</td></tr><tr><td>盘片</td><td>固定盘、盘组大部分不可换</td><td>可换盘片</td></tr><tr><td>价格</td><td>高</td><td>低</td></tr><tr><td>环境</td><td>苛刻</td><td></td></tr></tbody></table><ol start="2"><li><p>软盘片</p><p><img src="%E8%BD%AF%E7%9B%98%E7%89%87.jpg" alt="软盘片"></p></li></ol><h2 id="光盘存储器"><a href="#光盘存储器" class="headerlink" title="光盘存储器"></a>光盘存储器</h2><ol><li><p>概述</p><p>采用光存储技术 —- <strong>利用激光写入和读出</strong></p><p>第一代光存储技术 —- 采用非磁性介质 —- 不可擦写</p><p>第二代光存储技术 —- 采用磁性介质 —- 可擦写</p></li><li><p>光盘的存储原理</p><p>只读型和只写一次型 —- 热作用（物理或化学）</p><p>可擦写光盘 —- 热磁效应</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;存储器分类&quot;&gt;&lt;a href=&quot;#存储器分类&quot; class=&quot;headerlink&quot; title=&quot;存储器分类&quot;&gt;&lt;/a&gt;存储器分
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://gxkord.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成原理" scheme="https://gxkord.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>第3章 系统总线</title>
    <link href="https://gxkord.github.io/2019/03/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%AC%AC3%E7%AB%A0%20%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/"/>
    <id>https://gxkord.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/</id>
    <published>2019-03-15T07:10:12.000Z</published>
    <updated>2019-03-15T16:49:56.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h1><h2 id="为什么要用总线"><a href="#为什么要用总线" class="headerlink" title="为什么要用总线"></a>为什么要用总线</h2><p>计算机系统的五大部件之间有两种互联方式：分散连接、总线连接。</p><blockquote><p>分散连接：各部件之间使用单独的连线。（分散连接会使系统难以扩展，所以引入总线结构。)</p><p>总线连接：将各部件连接到一组公共信息传输线上。</p></blockquote><h2 id="什么是总线"><a href="#什么是总线" class="headerlink" title="什么是总线"></a>什么是总线</h2><p>总线是连接各个部件的信息传输线，是<strong>各个部件共享的传输介质</strong>。</p><h2 id="总线上信息的传输"><a href="#总线上信息的传输" class="headerlink" title="总线上信息的传输"></a>总线上信息的传输</h2><p>串行：信息在总线上按位传输。常用与计算机与计算机之间。</p><p>并行：信息在总线上多位传输。需要多条数据线平行传输，所以，若传输距离过长，数据线之间容易发生干扰。常用于单个计算机内部。</p><h2 id="总线结构的计算机举例"><a href="#总线结构的计算机举例" class="headerlink" title="总线结构的计算机举例"></a>总线结构的计算机举例</h2><ol><li><p>单总线结构框图</p><p><img src="%E5%8D%95%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.jpg" alt="单总线结构框图"></p><p>缺点：设备的利用率低。在同一时刻，只有一对设备能使用总线。</p></li><li><p>面向CPU的双总线结构框图</p><p><img src="%E9%9D%A2%E5%90%91CPU%E7%9A%84%E5%8F%8C%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.jpg" alt="面向CPU的双总线结构框图"></p><p>缺点：主存和外部设备之间无直接通路。若两者之间需要通信，会打断CPU的运行。</p></li><li><p>以存储器为中心的总线结构框图</p><p><img src="%E4%BB%A5%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%BA%E4%B8%AD%E5%BF%83%E7%9A%84%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E6%A1%86%E5%9B%BE.jpg" alt="以存储器为中心的总线结构框图"></p></li></ol><h1 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h1><ol><li><p>按连接部件不同：</p><p>(1) 片内总线：<strong>芯片内部</strong>的总线。</p><p>(2) 系统总线：<strong>计算机各部件之间</strong>的信息传输线。</p><pre><code>① 数据总线：双向，与机器字长、存储字长有关。② 地址总线：单向，与存储地址、I/O地址有关。③ 控制总线：有出（存储器读、写，总线许可，中断确认）有入（中断请求、总线请求）。</code></pre><p>(3) 通信总线：用于<strong>计算机系统之间</strong>或<strong>计算机系统与其他系统</strong>（如控制仪表、移动通信等）之间的通信。</p></li><li><p>按传输方式：并行传输总线、串行传输总线。</p></li></ol><h1 id="总线特性及性能指标"><a href="#总线特性及性能指标" class="headerlink" title="总线特性及性能指标"></a>总线特性及性能指标</h1><h2 id="总线物理实现"><a href="#总线物理实现" class="headerlink" title="总线物理实现"></a>总线物理实现</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="总线物理实现.jpg" alt="总线物理实现" title>                </div>                <div class="image-caption">总线物理实现</div>            </figure><h2 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h2><ol><li><p>机械特性：<strong>尺寸</strong>、形状、<strong>管脚数</strong>及<strong>排列顺序</strong>。</p></li><li><p>电气特性：<strong>传输方向</strong>和有效的<strong>电平</strong>范围。</p></li><li><p>功能特性：每根传输线的<strong>功能</strong>（地址、数据或控制）。</p></li><li><p>时间特性：信号的<strong>时序</strong>关系。</p></li></ol><h2 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a>总线的性能指标</h2><ol><li><p>总线宽度：<strong>数据线</strong>的根数。</p></li><li><p>标准传输率：每秒传输的最大字节数（<strong>MBps</strong>）。</p></li><li><p>时钟同步/异步：<strong>同步</strong>、<strong>不同步</strong>（不等同于异步）。</p></li><li><p>总线复用：<strong>地址线</strong>与<strong>数据线</strong>复用。</p></li><li><p>信号线数：地址线、数据线和控制线的<strong>总和</strong>。</p></li><li><p>总线控制方式：突发、自动、仲裁、逻辑、计数。</p></li><li><p>其他指标：<strong>负载能力</strong>。</p></li></ol><h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="总线标准.jpg" alt="总线标准" title>                </div>                <div class="image-caption">总线标准</div>            </figure><h1 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h1><h2 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="单总线结构框图.jpg" alt="单总线结构" title>                </div>                <div class="image-caption">单总线结构</div>            </figure><h2 id="多总线结构"><a href="#多总线结构" class="headerlink" title="多总线结构"></a>多总线结构</h2><ol><li>双总线结构</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="双总线结构框图.jpg" alt="双总线结构" title>                </div>                <div class="image-caption">双总线结构</div>            </figure><ol start="2"><li>三总线结构</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="三总线结构框图1.jpg" alt="三总线结构1" title>                </div>                <div class="image-caption">三总线结构1</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="三总线结构框图2.jpg" alt="三总线结构2" title>                </div>                <div class="image-caption">三总线结构2</div>            </figure><ol start="3"><li>四总线结构</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="四总线结构框图.jpg" alt="四总线结构" title>                </div>                <div class="image-caption">四总线结构</div>            </figure><h2 id="总线结构举例"><a href="#总线结构举例" class="headerlink" title="总线结构举例"></a>总线结构举例</h2><ol><li><p>传统微型机总线结构</p><p><img src="%E4%BC%A0%E7%BB%9F%E5%BE%AE%E5%9E%8B%E6%9C%BA%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt="传统微型机总线结构"></p></li><li><p>VL-BUS局部总线结构</p><p><img src="VL-BUS%E5%B1%80%E9%83%A8%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt="VL-BUS局部总线结构"></p></li><li><p>PCI总线结构</p><p><img src="PCI%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt="PCI总线结构"></p></li><li><p>多层PCI总线结构</p><p><img src="%E5%A4%9A%E5%B1%82PCI%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84.jpg" alt="多层PCI总线结构"></p></li></ol><h1 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h1><h2 id="总线判优"><a href="#总线判优" class="headerlink" title="总线判优"></a>总线判优</h2><ol><li><p>基本概念</p><ul><li><p>主设备（模块）：对总线有<strong>控制权</strong>。</p></li><li><p>从设备（模块）：<strong>响应</strong>从主设备发来的总线命令。</p></li><li><p>总线判优控制：决定由哪个主设备占用总线。分为集中式、分布式两种。</p></li></ul></li><li><p>总线判优控制（集中式）</p><p>(1) 链式查询方式</p><p><strong>I/0接口n获得总线使用权的过程</strong>：<em>I/0接口n</em>发出<em>BR（总线请求）</em>，然后<em>总线控制部件</em>发出<em>BG（总线统一）</em>，<em>I/0接口n</em>再发送<em>BS（总线忙）</em>。</p><p><img src="%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98%E6%8E%A7%E5%88%B6-%E9%93%BE%E5%BC%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.jpg" alt="链式查询方式"></p><p>(2) 计数器定时查询方式</p><p><strong>I/0接口n获得总线使用权的过程</strong>：I/0接口n发出<em>BR</em>给<em>总线控制部件</em>，若可以给出总线使用权，则启用<strong>计数器</strong>，并初始化为0。总线控制部件通过<em>设备地址（线）</em>访问设备0，检查其是否发出了<em>BR</em>；若否，计数器+1，再访问设备1……若检查至设备n，且设备n发出了<em>BR</em>，则设备n发送<em>BS</em>。</p><p><strong>优点</strong>：设备（接口）的优先级设置非常灵活。</p><p><img src="%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98%E6%8E%A7%E5%88%B6-%E8%AE%A1%E6%95%B0%E5%99%A8%E5%AE%9A%E6%97%B6%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F.jpg" alt="计数器定时查询方式"></p><p>(3) 独立请求方式</p><p><strong>I/O接口n获得总线使用权的过程</strong>：直接向<em>总线控制部件</em>发送<em>BR</em>，比对排队器里的序列，向对应I/O接口发送<em>BG</em>信号即可。</p><p><strong>优点</strong>：每个I/O接口都有独立的BR和BG。优先级的设置更加灵活，只需要管理总线控制部件的排队器即可。</p><p><img src="%E6%80%BB%E7%BA%BF%E5%88%A4%E4%BC%98%E6%8E%A7%E5%88%B6-%E7%8B%AC%E7%AB%8B%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F.jpg" alt="独立请求方式"></p></li></ol><h2 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h2><ol><li><p>目的</p><p>解决通信双方<strong>协调配合</strong>问题。</p></li><li><p>总线传输周期</p><p>(1) 申请分配阶段：<strong>主模块申请</strong>，总线仲裁决定。</p><p>(2) 寻址阶段：主模块向从模块<strong>给出地址</strong>和<strong>命令</strong>。</p><p>(3) 传数阶段：主模块和从模块<strong>交换数据</strong>。</p><p>(4) 结束阶段：主模块<strong>撤销有关信息</strong>。</p></li><li><p>总线通信的四种方式</p><p>(1) 同步通信：由<strong>统一时标</strong>控制数据传送。</p><p>① 同步式数据输入</p><pre><code>T1 - 主模块发地址T2 - 主模块发读命令。T3 - 从模块提供数据。T4 - 主模块撤销读命令，从模块撤销数据。</code></pre><p><img src="%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1-%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.jpg" alt="同步式数据输入"></p><p>② 同步数据输出</p><pre><code>T1 - 主模块发地址。T1.5 - 主模块提供数据。T2 - 从模块发出写命令，从模块接收到命令后，必须在规定时间内将数据总线上的数据写到    地址总线所知名的单元中。T4 - 主模块撤销写命令和数据等信号。</code></pre><p><img src="%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1-%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA.jpg" alt="同步式数据输出"></p><p>(2) 异步通信：采用<strong>应答方式</strong>，没有公共时钟标准。</p><p>① 不互锁方式：请求和回答互不相关。<strong>无法保证通信的可靠性。</strong></p><p>② 半互锁方式：主模块接到从模块发送的回答信号，才撤销请求信号。<strong>可能会造成请求信号一直保持高电平状态</strong>。</p><p>③ 全互锁方式：主模块的请求信号撤销以后，从模块才撤销其回答信号。</p><p><img src="%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1-%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1.jpg" alt="异步通信"></p><p>(3) 半同步通信：<strong>同步、异步结合</strong>。</p><blockquote><p>同步：<strong>发送方</strong>用系统<strong>时钟前沿</strong>发信号；<strong>接收方</strong>用系统<strong>时钟后沿</strong>判断、识别。</p><p>异步：允许不同速度的模块和谐工作。增加一条<strong>“等待”响应信号</strong>。($\overline{WAIT}$)</p></blockquote><p>以输入数据为例：</p><p>T1 - 主模块发出地址信号。</p><p>T2 - 主模块发出命令。</p><p>Tw - 当$\overline{WAIT}$为低电平时，进入等待，Tw的宽度与T的宽度一致。</p><p>. . .</p><p>T3 - 从模块提供数据。</p><p>T4 - 主模块撤销读命令，从模块撤销数据。</p><p><img src="%E6%80%BB%E7%BA%BF%E9%80%9A%E4%BF%A1-%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%BC%8F%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5.jpg" alt="半同步式数据输入"></p><blockquote><p>上述三种通信（同步、异步、半同步）的共同点：</p><ul><li><p>一个总线传输周期（以输入数据为例）</p><ul><li><p>主模块发地址、命令（<strong>占用总线</strong>）</p></li><li><p>从模块准备数据（<strong>不占用总线</strong>，<em>总线空闲</em>）</p></li><li><p>从模块向主模块发数据（<strong>占用总线</strong>）</p></li></ul></li></ul></blockquote><p>(4) 分离式通信：充分<strong>挖掘</strong>系统<strong>总线每个瞬间</strong>的潜力。</p><blockquote><p>原因：上述三种通信从模块准备数据时，总线处于空闲状态！</p></blockquote><p><strong>一个总线传输周期：</strong></p><ul><li><p>子周期1：<strong>主模块</strong>申请<strong>占用总线</strong>，使用完后即<strong>放弃总线</strong>的使用权。</p></li><li><p>子周期2：<strong>从模块</strong>申请<strong>占用总线</strong>，将各种信号送至总线上。</p></li></ul><p><strong>特点：</strong></p><pre><code>① 各模块有权申请占用总线。② 采用同步方式通信，不等对方回答。③  各个模块准备数据时，不占用总线。④ 总线被占用时，无空闲。</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总线的基本概念&quot;&gt;&lt;a href=&quot;#总线的基本概念&quot; class=&quot;headerlink&quot; title=&quot;总线的基本概念&quot;&gt;&lt;/a&gt;总线的基本概念&lt;/h1&gt;&lt;h2 id=&quot;为什么要用总线&quot;&gt;&lt;a href=&quot;#为什么要用总线&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="计算机基础" scheme="https://gxkord.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成原理" scheme="https://gxkord.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>16. 3Sum Closest(Medium)</title>
    <link href="https://gxkord.github.io/2019/03/02/%E7%AE%97%E6%B3%95/LeetCode/16.%203Sum%20Closest(Medium)/"/>
    <id>https://gxkord.github.io/2019/03/02/算法/LeetCode/16. 3Sum Closest(Medium)/</id>
    <published>2019-03-02T12:40:12.000Z</published>
    <updated>2019-04-19T10:17:08.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description</strong>:<br>Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</p><blockquote><p><strong>Example</strong>: </p><blockquote><p>Given array nums = [-1, 2, 1, -4], and target = 1.<br>The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</p></blockquote></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述</strong>:<br>给定一个由n个整数构成的数组nums和一个整数target，在nums中找到三个整数，使它们的总和最接近target。返回这三个整数的总和。您可以假设每个输入都只有一个答案。</p><blockquote><p><strong>例如</strong>: </p><blockquote><p>给定数组 nums = [-1, 2, 1, -4], 和 target = 1.<br>最接近target的整数为2。(-1 + 2 + 1 = 2)</p></blockquote></blockquote></blockquote><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>这道题是第15题的加强版，解法与15题相似。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cha = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> low = i + <span class="number">1</span>, high = nums.length - <span class="number">1</span>, sum = target - nums[i];</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[low] + nums[high] == sum) &#123;</span><br><span class="line">                        <span class="keyword">return</span> target;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[low] + nums[high] &lt; sum) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (sum - nums[low] - nums[high] &lt; cha) &#123;</span><br><span class="line">                            cha = sum - nums[low] - nums[high];</span><br><span class="line">                            result = target - cha;</span><br><span class="line">                        &#125;</span><br><span class="line">                        low++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nums[low] + nums[high] - sum &lt; cha) &#123;</span><br><span class="line">                            cha = nums[low] + nums[high] - sum;</span><br><span class="line">                            result = target + cha;</span><br><span class="line">                        &#125;</span><br><span class="line">                        high--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://gxkord.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://gxkord.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Medium" scheme="https://gxkord.github.io/tags/LeetCode-Medium/"/>
    
  </entry>
  
  <entry>
    <title>15. 3Sum(Medium)</title>
    <link href="https://gxkord.github.io/2019/02/15/%E7%AE%97%E6%B3%95/LeetCode/15.%203Sum(Medium)/"/>
    <id>https://gxkord.github.io/2019/02/15/算法/LeetCode/15. 3Sum(Medium)/</id>
    <published>2019-02-15T11:33:12.000Z</published>
    <updated>2019-04-21T07:16:58.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description</strong>:<br>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0?<br>Find all unique triplets in the array which gives the sum of zero.</p><p><strong>Note</strong>:</p><blockquote><p>The solution set must not contain duplicate triplets.</p><p><strong>Example</strong>: </p><blockquote><p>Given array nums = [-1, 0, 1, 2, -1, -4],<br>A solution set is:<br>[<br> [-1, 0, 1],<br> [-1, -1, 2]<br>]</p></blockquote></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述</strong>:<br>给定一个包含n个实数的数组nums，其中是否存在元素a，b，c，使得a + b + c = 0？<br>找到数组中所有唯一的三元组，它们的总和为零。</p><p><strong>另外</strong>:</p><blockquote><p>结果集中不得包含重复的三元组</p><p><strong>例如</strong>: </p><blockquote><p>Given array nums = [-1, 0, 1, 2, -1, -4],<br>A solution set is:<br>[<br> [-1, 0, 1],<br> [-1, -1, 2]<br>]</p></blockquote></blockquote></blockquote><h1 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>首先，对数组进行排序。</p><p>然后，从0位置开始到倒数第三个位置（num.length-3)，进行遍历，假定num[i]就是3sum中得第一个加数，然后从i+1的位置开始，进行2sum的运算。</p><p>当找到一个3sum==0的情况时，判断是否在结果hashset中出现过，没有则添加。(利用hashset的value唯一性）</p><p>因为结果不唯一，此时不能停止，继续搜索，左右指针同时挪动。</p><blockquote><p>打败了72.57%的答案。 </p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span> || nums == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 对数组排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= nums.length - <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i-<span class="number">1</span>]) &#123; <span class="comment">// 去重</span></span><br><span class="line">                <span class="keyword">int</span> low = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> high = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = nums[i] + nums[low] + nums[high];</span><br><span class="line">                    <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                        List&lt;Integer&gt; unit = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                        unit.add(nums[i]);</span><br><span class="line">                        unit.add(nums[low]);</span><br><span class="line">                        unit.add(nums[high]);</span><br><span class="line">                        res.add(unit);</span><br><span class="line">                        low++;</span><br><span class="line">                        high--;</span><br><span class="line">                        <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[low] == nums[low - <span class="number">1</span>]) <span class="comment">// 去重</span></span><br><span class="line">                            low++;</span><br><span class="line">                        <span class="keyword">while</span> (low &lt; high &amp;&amp; nums[high] == nums[high + <span class="number">1</span>]) <span class="comment">// 去重</span></span><br><span class="line">                            high--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">                        high--;</span><br><span class="line">                     <span class="keyword">else</span></span><br><span class="line">                        low++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://gxkord.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://gxkord.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Medium" scheme="https://gxkord.github.io/tags/LeetCode-Medium/"/>
    
  </entry>
  
  <entry>
    <title>14. Longest Common Prefix(Easy)</title>
    <link href="https://gxkord.github.io/2019/01/23/%E7%AE%97%E6%B3%95/LeetCode/14.%20Longest%20Common%20Prefix(Easy)/"/>
    <id>https://gxkord.github.io/2019/01/23/算法/LeetCode/14. Longest Common Prefix(Easy)/</id>
    <published>2019-01-23T12:08:22.000Z</published>
    <updated>2019-04-19T10:16:16.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description</strong>:<br>Write a function to find the longest common prefix string amongst an array of strings.</p><p>If there is no common prefix, return an empty string “”.</p><blockquote><p><strong>Example 1</strong>: </p><blockquote><p><strong>Input</strong>: [“flower”,”flow”,”flight”]<br><strong>Output</strong>: “fl”</p></blockquote><p><strong>Example 2</strong>: </p><blockquote><p><strong>Input</strong>: [“dog”,”racecar”,”car”]<br><strong>Output</strong>: “”<br><strong>Explanation</strong>: There is no common prefix among the input strings.</p></blockquote><p><strong>Note</strong>:<br>All given inputs are in lowercase letters a-z.</p></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述</strong>:<br>编写一个函数来查找字符串数组中最长的公共前缀字符串。</p><p>如果没有公共前缀，则返回空字符串””。</p><blockquote><p><strong>例1</strong>: </p><blockquote><p><strong>输入</strong>: [“flower”,”flow”,”flight”]<br><strong>输出</strong>: “fl”</p></blockquote><p><strong>例2</strong>: </p><blockquote><p><strong>输入</strong>: [“dog”,”racecar”,”car”]<br><strong>输出</strong>: “”<br><strong>解释</strong>: 输入字符串中没有公共前缀。</p></blockquote><p><strong>注意</strong>:<br>所有给定的输入都是小写字母a-z。</p></blockquote></blockquote><h1 id="解法一-Mine"><a href="#解法一-Mine" class="headerlink" title="解法一(Mine)"></a>解法一(Mine)</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>按每位依次比对字符串数组中的每个字符。<br>注意：若遍历到某个字符串的第i个字符，其为当前字符串的最后一位，后面的字符就无需比对了。</p><blockquote><p>打败了91.80%的答案。 </p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&gt; class Solution &#123;</span><br><span class="line">&gt;     public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">&gt;         if (strs.length == 0)</span><br><span class="line">&gt;             return &quot;&quot;;</span><br><span class="line">&gt;         else if (strs.length == 1)</span><br><span class="line">&gt;             return strs[0];</span><br><span class="line">&gt;         StringBuilder res = new StringBuilder();</span><br><span class="line">&gt;         int index = 0;</span><br><span class="line">&gt;         char temp = &apos; &apos;;</span><br><span class="line">&gt;         boolean flag = true;</span><br><span class="line">&gt;         f1: while (flag) &#123;</span><br><span class="line">&gt;             f2: for (int i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">&gt;                 if (&quot;&quot;.equals(strs[i]))</span><br><span class="line">&gt;                     break f1;</span><br><span class="line">&gt;                 if (i == 0)</span><br><span class="line">&gt;                     temp = strs[i].charAt(index);</span><br><span class="line">&gt;                 else if (temp != strs[i].charAt(index))</span><br><span class="line">&gt;                     break f1;</span><br><span class="line">&gt;                 else if (i == strs.length - 1)</span><br><span class="line">&gt;                     if (temp == strs[i].charAt(index))</span><br><span class="line">&gt;                         res.append(temp);</span><br><span class="line">&gt;                 if (index &gt;= strs[i].length() - 1)</span><br><span class="line">&gt;                     flag = false;</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;             index++;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         return res.toString();</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><p>比较前两个字符串，得到公共前缀，与第三个字符串比较，直至公共前缀为空。</p></blockquote><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">    if (strs.length == 0) </span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    String prefix = strs[0];</span><br><span class="line">    for (int i = 1; i &lt; strs.length; i++)</span><br><span class="line">        while (strs[i].indexOf(prefix) != 0) &#123;</span><br><span class="line">            prefix = prefix.substring(0, prefix.length() - 1);</span><br><span class="line">            if (prefix.isEmpty()) return &quot;&quot;;</span><br><span class="line">        &#125;        </span><br><span class="line">    return prefix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h1><h2 id="主要思想-2"><a href="#主要思想-2" class="headerlink" title="主要思想"></a>主要思想</h2><blockquote><p>与我的解法思想相同。</p></blockquote><p>想象一下，一个非常短的字符串位于数组的末尾。上述方法仍将非常困难。优化此情况的一种方法是进行垂直扫描。在转到下一列之前，我们在同一列（字符串的相同字符索引）上从上到下比较字符。</p><h2 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs[<span class="number">0</span>].length() ; i++)&#123;</span><br><span class="line">        <span class="keyword">char</span> c = strs[<span class="number">0</span>].charAt(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; strs.length; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == strs[j].length() || strs[j].charAt(i) != c)</span><br><span class="line">                <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, i);             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h1><h2 id="主要思想-3"><a href="#主要思想-3" class="headerlink" title="主要思想"></a>主要思想</h2><p>分治。先求左半边，再求右半边，然后合并。</p><h2 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">""</span>;    </span><br><span class="line">        <span class="keyword">return</span> longestCommonPrefix(strs, <span class="number">0</span> , strs.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> strs[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r)/<span class="number">2</span>;</span><br><span class="line">        String lcpLeft =   longestCommonPrefix(strs, l , mid);</span><br><span class="line">        String lcpRight =  longestCommonPrefix(strs, mid + <span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">return</span> commonPrefix(lcpLeft, lcpRight);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">commonPrefix</span><span class="params">(String left,String right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = Math.min(left.length(), right.length());       </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; min; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( left.charAt(i) != right.charAt(i) )</span><br><span class="line">            <span class="keyword">return</span> left.substring(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.substring(<span class="number">0</span>, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法五"><a href="#解法五" class="headerlink" title="解法五"></a>解法五</h1><h2 id="主要思想-4"><a href="#主要思想-4" class="headerlink" title="主要思想"></a>主要思想</h2><p>二分法。把第一个字符串分成两半，判断前一半是不是公共前缀。若是，后一半分成两半；若不是，前一半分成两半。</p><h2 id="源码-4"><a href="#源码-4" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">int</span> minLen = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (String str : strs)</span><br><span class="line">        minLen = Math.min(minLen, str.length());</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> high = minLen;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isCommonPrefix(strs, middle))</span><br><span class="line">            low = middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            high = middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strs[<span class="number">0</span>].substring(<span class="number">0</span>, (low + high) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isCommonPrefix</span><span class="params">(String[] strs, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    String str1 = strs[<span class="number">0</span>].substring(<span class="number">0</span>,len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length; i++)</span><br><span class="line">        <span class="keyword">if</span> (!strs[i].startsWith(str1))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法六"><a href="#解法六" class="headerlink" title="解法六"></a>解法六</h1><h2 id="主要思想-5"><a href="#主要思想-5" class="headerlink" title="主要思想"></a>主要思想</h2><p>利用树结构，把每一个字符串的每个字符从根节点向下插入，最后一次输出没有兄弟节点的节点即可。</p><h2 id="源码-5"><a href="#源码-5" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestCommonPrefix</span><span class="params">(String q, String[] strs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strs == <span class="keyword">null</span> || strs.length == <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">return</span> <span class="string">""</span>;  </span><br><span class="line">    <span class="keyword">if</span> (strs.length == <span class="number">1</span>)</span><br><span class="line">         <span class="keyword">return</span> strs[<span class="number">0</span>];</span><br><span class="line">    Trie trie = <span class="keyword">new</span> Trie();      </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; strs.length ; i++) &#123;</span><br><span class="line">        trie.insert(strs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trie.searchLongestPrefix(q);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span>&#123;</span><br><span class="line">    <span class="comment">// R links to node children</span></span><br><span class="line">    <span class="keyword">private</span> TrieNode[] links;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> R = <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// number of children non null links</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">char</span> ch, TrieNode node)</span> </span>&#123;</span><br><span class="line">        links[ch -<span class="string">'a'</span>] = node;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLinks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Trie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        root = <span class="keyword">new</span> TrieNode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">searchLongestPrefix</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        TrieNode node = root;</span><br><span class="line">        StringBuilder prefix = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> curLetter = word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.containsKey(curLetter) &amp;&amp; (node.getLinks() == <span class="number">1</span>) &amp;&amp; (!node.isEnd())) &#123;</span><br><span class="line">                prefix.append(curLetter);</span><br><span class="line">                node = node.get(curLetter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> prefix.toString();</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> prefix.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://gxkord.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://gxkord.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Easy" scheme="https://gxkord.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>13. Roman to Integer(Easy)</title>
    <link href="https://gxkord.github.io/2019/01/16/%E7%AE%97%E6%B3%95/LeetCode/13.%20Roman%20to%20Integer(Easy)/"/>
    <id>https://gxkord.github.io/2019/01/16/算法/LeetCode/13. Roman to Integer(Easy)/</id>
    <published>2019-01-16T11:33:21.000Z</published>
    <updated>2019-04-19T10:15:31.998Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description</strong>:<br>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><table><thead><tr><th>Symbol</th><th>Value</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9. <blockquote><ul><li>X can be placed before L (50) and C (100) to make 40 and 90. </li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul></blockquote></li></ul><p>Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</p><blockquote><p><strong>Example 1</strong>: </p><blockquote><p><strong>Input</strong>: “III”<br><strong>Output</strong>: 3</p></blockquote><p><strong>Example 2</strong>: </p><blockquote><p><strong>Input</strong>: “IV”<br><strong>Output</strong>: 4</p></blockquote><p><strong>Example 3</strong>: </p><blockquote><p><strong>Input</strong>: “IX”<br><strong>Output</strong>: 9</p></blockquote><p><strong>Example 4</strong>: </p><blockquote><p><strong>Input</strong>: “LVIII”<br><strong>Output</strong>: 58<br><strong>Explanation</strong>: L = 50, V = 5, III = 3.</p></blockquote><p><strong>Example 5</strong>: </p><blockquote><p><strong>Input</strong>: “MCMXCIV”<br><strong>Output</strong>: 1994<br><strong>Explanation</strong>: M = 1000, CM = 900, XC = 90 and IV = 4.</p></blockquote></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述</strong>:<br>罗马数字由七个不同的符号表示：I，V，X，L，C，D和M。</p><table><thead><tr><th>符号</th><th>值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。十二写为XII，简称为X + II。<br>第二十七号写成XXVII，即XX + V + II。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<blockquote><ul><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul></blockquote></li></ul><p>给定一个罗马数字，将其转换为整数。<br>输入确保在1到3999的范围内。</p><blockquote><p><strong>例1</strong>: </p><blockquote><p><strong>输入</strong>: “III”<br><strong>输出</strong>: 3</p></blockquote><p><strong>例2</strong>: </p><blockquote><p><strong>输入</strong>: “IV”<br><strong>输出</strong>: 4</p></blockquote><p><strong>例3</strong>: </p><blockquote><p><strong>输入</strong>: “IX”<br><strong>输出</strong>: 9</p></blockquote><p><strong>例4</strong>: </p><blockquote><p><strong>输入</strong>: “LVIII”<br><strong>输出</strong>: 58<br><strong>解释</strong>: L = 50, V = 5, III = 3.</p></blockquote><p><strong>例5</strong>: </p><blockquote><p><strong>输入</strong>: “MCMXCIV”<br><strong>输出</strong>: 1994<br><strong>解释</strong>: M = 1000, CM = 900, XC = 90， IV = 4.</p></blockquote></blockquote></blockquote><h1 id="解法一-Mine"><a href="#解法一-Mine" class="headerlink" title="解法一(Mine)"></a>解法一(Mine)</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>result（int类型）保存结果，从右向左遍历字符。<br>若上一个大于当前，则result减当前value；否则，result加当前value。</p><blockquote><p>打败了78.71%的答案。 </p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">&gt;     <span class="keyword">int</span> i = s.length();</span><br><span class="line">&gt;     <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">&gt;     <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">&gt;     <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">&gt;         <span class="keyword">char</span> c = s.charAt(--i);</span><br><span class="line">&gt;         <span class="keyword">switch</span>(c) &#123;</span><br><span class="line">&gt;             <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">&gt;                 now = <span class="number">0</span>;</span><br><span class="line">&gt;                 result = getResult(now, pre, <span class="number">1</span>, result);</span><br><span class="line">&gt;                 pre = <span class="number">0</span>;</span><br><span class="line">&gt;                 <span class="keyword">break</span>;</span><br><span class="line">&gt;             <span class="keyword">case</span> <span class="string">'V'</span>: </span><br><span class="line">&gt;                 now = <span class="number">1</span>;</span><br><span class="line">&gt;                 result = getResult(now, pre, <span class="number">5</span>, result);</span><br><span class="line">&gt;                 pre = <span class="number">1</span>;</span><br><span class="line">&gt;                 <span class="keyword">break</span>;</span><br><span class="line">&gt;             <span class="keyword">case</span> <span class="string">'X'</span>: </span><br><span class="line">&gt;                 now = <span class="number">2</span>;</span><br><span class="line">&gt;                 result = getResult(now, pre, <span class="number">10</span>, result);</span><br><span class="line">&gt;                 pre = <span class="number">2</span>;</span><br><span class="line">&gt;                 <span class="keyword">break</span>;</span><br><span class="line">&gt;             <span class="keyword">case</span> <span class="string">'L'</span>: </span><br><span class="line">&gt;                 now = <span class="number">3</span>;</span><br><span class="line">&gt;                 result = getResult(now, pre, <span class="number">50</span>, result);</span><br><span class="line">&gt;                 pre = <span class="number">3</span>;</span><br><span class="line">&gt;                 <span class="keyword">break</span>;</span><br><span class="line">&gt;             <span class="keyword">case</span> <span class="string">'C'</span>: </span><br><span class="line">&gt;                 now = <span class="number">4</span>;</span><br><span class="line">&gt;                 result = getResult(now, pre, <span class="number">100</span>, result);</span><br><span class="line">&gt;                 pre = <span class="number">4</span>;</span><br><span class="line">&gt;                 <span class="keyword">break</span>;</span><br><span class="line">&gt;             <span class="keyword">case</span> <span class="string">'D'</span>: </span><br><span class="line">&gt;                 now = <span class="number">5</span>;</span><br><span class="line">&gt;                 result = getResult(now, pre, <span class="number">500</span>, result);</span><br><span class="line">&gt;                 pre = <span class="number">5</span>;</span><br><span class="line">&gt;                 <span class="keyword">break</span>;</span><br><span class="line">&gt;             <span class="keyword">case</span> <span class="string">'M'</span>: </span><br><span class="line">&gt;                 now = <span class="number">6</span>;</span><br><span class="line">&gt;                 result = getResult(now, pre, <span class="number">1000</span>, result);</span><br><span class="line">&gt;                 pre = <span class="number">6</span>;</span><br><span class="line">&gt;                 <span class="keyword">break</span>;</span><br><span class="line">&gt;             &#125;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> result;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre, <span class="keyword">int</span> value, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">if</span> (pre &gt; now)</span><br><span class="line">&gt;             result -= value;</span><br><span class="line">&gt;         <span class="keyword">else</span> </span><br><span class="line">&gt;             result += value;</span><br><span class="line">&gt;         <span class="keyword">return</span> result;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><p>第一名的答案，与方法一思想类似。</p></blockquote><p>使用两次for循环。<br>第一次把当前位置是否大于下一位置保存到boolean数组中。<br>第二次根据boolean数组和字符串的同一位置，得到结果。</p><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">romanToInt</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] mem = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; s.length() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (test(s.charAt(i)) &lt; test(s.charAt(i+<span class="number">1</span>))) &#123;</span><br><span class="line">                mem[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mem[i] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mem[s.length() - <span class="number">1</span>] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (mem[i])&#123;</span><br><span class="line">                result = result - test(s.charAt(i));</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result = result + test(s.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (a == <span class="string">'I'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'V'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'X'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'L'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'C'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'D'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">'M'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://gxkord.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://gxkord.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Easy" scheme="https://gxkord.github.io/tags/LeetCode-Easy/"/>
    
  </entry>
  
  <entry>
    <title>1. 设计模式概述</title>
    <link href="https://gxkord.github.io/2019/01/16/Java/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/1.%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/"/>
    <id>https://gxkord.github.io/2019/01/16/Java/Java设计模式/1. 设计模式概述/</id>
    <published>2019-01-16T08:46:13.000Z</published>
    <updated>2019-01-23T07:48:25.742Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>声明：本专题为刘伟老师所著《Java设计模式》的笔记</p></blockquote><h1 id="设计模式的诞生与发展"><a href="#设计模式的诞生与发展" class="headerlink" title="设计模式的诞生与发展"></a>设计模式的诞生与发展</h1><h2 id="模式的诞生与定义"><a href="#模式的诞生与定义" class="headerlink" title="模式的诞生与定义"></a>模式的诞生与定义</h2><p>模式（Pattern）起源于建筑业而非软件业，模式之父——美国加利福尼亚大学环境结构中心研究所所长Christopher Alexander博士用了约20年的时间，对舒适住宅和周边环境进行了大量的调查和资料收集工作，发现人们对舒适住宅和城市环境存在一些共同的认同规律。他在其著作<em>A pattern Language: Towns,Buildings,Construction</em>（中译本名为《建筑模式语言：城镇·建筑·构造》）中把这些认同规律归纳为253个模式，对每一个模式都从Context（模式可适用的前提条件）、Theme或Problem（在特定条件下要解决的目标问题）、Solution（对目标问题求解过程中各种物理关系的记述）3个侧面进行描述，并给出了用户需求分析到建筑环境结构设计直至经典实例的过程模型。</p><p>可以简单地定义：<strong>模式是在特定环境下人们解决某类重复问题的一套成功或有效的解决方案。</strong><br><strong>A pattern is a successful or efficient solution to a recurring problem within a context.</strong></p><h2 id="软件模式概述"><a href="#软件模式概述" class="headerlink" title="软件模式概述"></a>软件模式概述</h2><p>最早将模式的思想引入软件工程方法学的是1991-1992年以“四人组（Gang of Four，GoF，分别是Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides）”自称的4位著名软件工程学者，他们在1994年归纳发表了23中在软件开发中使用频率较高的设计模式，旨在用模式来统一交流沟通面向对象方法在分析、设计和实现间的鸿沟。</p><p>软件模式可以被认为是对软件开发这一特定“问题”的“解法”的某种统一表示，它和Alexander所描述的模式定义完全相同，即软件模式是在一定条件下的软件开发问题及其解法。软件模式的基本结构由4个部分组成，即问题描述、前提条件（环境或约束条件）、解法和效果，如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="软件模式的基本结构.png" alt="软件模式的基本结构" title>                </div>                <div class="image-caption">软件模式的基本结构</div>            </figure><h1 id="设计模式的定义与分类"><a href="#设计模式的定义与分类" class="headerlink" title="设计模式的定义与分类"></a>设计模式的定义与分类</h1><h2 id="设计模式的定义"><a href="#设计模式的定义" class="headerlink" title="设计模式的定义"></a>设计模式的定义</h2><p>设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且保证代码可靠性。设计模式是一种用于对软件系统中不断重现的设计问题的解决方案进行文档化的技术，也是一种共享专家设计经验的技术。</p><p>GoF对设计模式的定义如下：<br><strong>设计模式是在特定环境下为解决某一通用软件问题提供的一套定制的解决方案，该方案描述了对象和类之间的互相作用。</strong><br><strong>Design patterns are descriptions of communicating objects and classes that are customized to solve a general design problem in a particular context.</strong></p><h2 id="设计模式的基本要素"><a href="#设计模式的基本要素" class="headerlink" title="设计模式的基本要素"></a>设计模式的基本要素</h2><p><strong>1. 模式名称（Pattern Name）</strong><br>通过一两个词来描述模式的问题、解决方案和效果，以便更好地理解模式并方便开发人员之间的交流，绝大多数模式都是根据其功能或模式结构来命名的。</p><p><strong>2. 问题（Problem）</strong><br>描述了应该在何时使用模式，它包含了设计中存在的问题以及问题存在的原因。</p><p><strong>3. 解决方案（Solution）</strong><br>描述了一个设计模式的组成成分，以及这些组成成分之间的相互关系，各自的职责和协作方式，通常解决方案通过UML类图和核心代码来进行描述。</p><p><strong>4. 效果（Consequences）</strong><br>描述了模式的优缺点以及在使用模式时应权衡的问题。</p><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><p><strong>1. 根据目的分类</strong><br>设计模式根据目的可分为创建型(Creational)，结构型(Structural)和行为型(Behavioral)三种。<br>（1）创建型模式主要用于描述如何创建对象。<br>（2）结构型模式主要用于描述如何实现类或对象的组合。<br>（3）行为型模式主要用于描述类或对象怎样交互以及怎样分配职责。</p><p><strong>2.根据范围分类</strong><br>设计模式根据范围可分为类模式和对象模式两种。<br>（1）类模式处理类和子类之间的关系。<br>（2）对象模式处理对象间的关系。</p><h1 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h1><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="常用设计模式一览.jpg" alt="常用设计模式一览" title>                </div>                <div class="image-caption">常用设计模式一览</div>            </figure><h1 id="设计模式的优点"><a href="#设计模式的优点" class="headerlink" title="设计模式的优点"></a>设计模式的优点</h1><ol><li><p>设计模式来源众多专家的经验和智慧，它们是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作，也许我们冥思苦想得到的一个“自以为很了不起”的设计方案其实就是某一个设计模式。在时间就是金钱的今天，设计模式无疑会为有助于我们提高开发和设计效率，但它不保证一定会提高。</p></li><li><p>设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。交流通常很耗时，任何有助于提高交流效率的东西都可以为我们节省不少时间。无论你使用哪种编程语言，做什么类型的项目，甚至你处于一个国际化的开发团队，当面对同一个设计模式时，你和别人的理解并无二异，因为设计模式是跨语言、跨平台、跨应用、跨国界的。</p></li><li><p>大部分设计模式都兼顾了系统的可重用性和可扩展性，这使得我们可以更好地重用一些已有的设计方案、功能模块甚至一个完整的软件系统，避免我们经常做一些重复的设计、编写一些重复的代码。此外，随着软件规模的日益增大，软件寿命的日益变长，系统的可维护性和可扩展性也越来越重要，许多设计模式将有助于提高系统的灵活性和可扩展性，让我们在不修改或者少修改现有系统的基础上增加、删除或者替换功能模块。如果一点设计模式都不懂，想要做到这一点恐怕还是很困难的。</p></li><li><p>合理使用设计模式并对设计模式的使用情况进行文档化，将有助于别人更快地理解系统。如果某一天因为升职或跳槽等原因，别人接手了你的项目，只要他也懂设计模式，应该能够很快理解你的设计思路和实现方案，让你升职无后患之忧，跳槽也心安理得，何乐而不为呢？</p></li><li><p>最后一点对初学者很重要，学习设计模式将有助于初学者更加深入地理解面向对象思想，让你知道：如何将代码分散在几个不同的类中？为什么要有“接口”？何谓针对抽象编程？何时不应该使用继承？如果不修改源代码增加新功能？同时还让你能够更好地阅读和理解现有类库（如JDK）与其他系统中的源代码，让你早点脱离面向对象编程的“菜鸟期”。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;声明：本专题为刘伟老师所著《Java设计模式》的笔记&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;设计模式的诞生与发展&quot;&gt;&lt;a href=&quot;#设计模式的诞生与发展&quot; class=&quot;headerlink&quot; title=&quot;设计模式的诞生与发展&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://gxkord.github.io/categories/Java/"/>
    
    
      <category term="《Java设计模式》" scheme="https://gxkord.github.io/tags/%E3%80%8AJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>2018</title>
    <link href="https://gxkord.github.io/2018/12/31/%E4%B8%80%E4%BA%9B%E8%AF%9D/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/2018/"/>
    <id>https://gxkord.github.io/2018/12/31/一些话/年终总结/2018/</id>
    <published>2018-12-31T05:20:00.000Z</published>
    <updated>2019-01-23T07:57:46.342Z</updated>
    
    <content type="html"><![CDATA[<p>2018，可以称得上悠闲，也可以说是惨淡。</p><p>2018，考上了新的学校，有了一个新的身份，也创建了自己的博客。看了不少的电影，学了不多的知识。</p><p>2018，留下了不少遗憾：想刷LeetCode，由于某些原因只做了12道；想学Spring，却也没有每天坚持；想学机器学习，借到的书被一直搁置在书角；想通关的游戏，在Steam里没时间玩；电视剧电影看了一部又一部，反而极少拿出时间安静地读书……</p><p>2019，给自己定了几个小目标：刷完LeetCode前200，搞懂SSM并有个小成果，学完吴恩达的CS229课程，拿到《Iris.Fall》《Slay the Spire》所有奖杯，每天都要学英语、读书……</p><p>最后，放上B站关注了好久的一位UP主（独立菌儿）的视频：<br><a href="http://www.bilibili.com/video/av39426478" target="_blank" rel="noopener">http://www.bilibili.com/video/av39426478</a></p><p>诚如电影《熔炉》的结尾时所说：“我们一路奋斗，不是为了改变世界，而是为了不让这个世界改变我们”。<strong>愿我们在新的一年都能保持独立思考，不卑不亢不怂，长成自己想要到的样子。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="你好，2019.png" alt="你好，2019" title>                </div>                <div class="image-caption">你好，2019</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2018，可以称得上悠闲，也可以说是惨淡。&lt;/p&gt;
&lt;p&gt;2018，考上了新的学校，有了一个新的身份，也创建了自己的博客。看了不少的电影，学了不多的知识。&lt;/p&gt;
&lt;p&gt;2018，留下了不少遗憾：想刷LeetCode，由于某些原因只做了12道；想学Spring，却也没有每天
      
    
    </summary>
    
      <category term="一些话" scheme="https://gxkord.github.io/categories/%E4%B8%80%E4%BA%9B%E8%AF%9D/"/>
    
    
      <category term="年终总结" scheme="https://gxkord.github.io/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>12. Integer to Roman(Medium)</title>
    <link href="https://gxkord.github.io/2018/12/17/%E7%AE%97%E6%B3%95/LeetCode/12.%20Integer%20to%20Roman(Medium)/"/>
    <id>https://gxkord.github.io/2018/12/17/算法/LeetCode/12. Integer to Roman(Medium)/</id>
    <published>2018-12-17T11:12:23.000Z</published>
    <updated>2019-04-19T10:12:59.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description</strong>:<br>Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</p><table><thead><tr><th>Symbol</th><th>Value</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</p><p>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</p><ul><li>I can be placed before V (5) and X (10) to make 4 and 9. <blockquote><ul><li>X can be placed before L (50) and C (100) to make 40 and 90. </li><li>C can be placed before D (500) and M (1000) to make 400 and 900.</li></ul></blockquote></li></ul><p>Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</p><blockquote><p><strong>Example 1</strong>: </p><blockquote><p><strong>Input</strong>: 3<br><strong>Output</strong>: “III”</p></blockquote><p><strong>Example 2</strong>: </p><blockquote><p><strong>Input</strong>: 4<br><strong>Output</strong>: “IV”</p></blockquote><p><strong>Example 3</strong>: </p><blockquote><p><strong>Input</strong>: 9<br><strong>Output</strong>: “IX”</p></blockquote><p><strong>Example 4</strong>: </p><blockquote><p><strong>Input</strong>: 58<br><strong>Output</strong>: “LVIII”<br><strong>Explanation</strong>: L = 50, V = 5, III = 3.</p></blockquote><p><strong>Example 5</strong>: </p><blockquote><p><strong>Input</strong>: 1994<br><strong>Output</strong>: “MCMXCIV”<br><strong>Explanation</strong>: M = 1000, CM = 900, XC = 90 and IV = 4.</p></blockquote></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述</strong>:<br>罗马数字由七个不同的符号表示：I，V，X，L，C，D和M。</p><table><thead><tr><th>符号</th><th>值</th></tr></thead><tbody><tr><td>I</td><td>1</td></tr><tr><td>V</td><td>5</td></tr><tr><td>X</td><td>10</td></tr><tr><td>L</td><td>50</td></tr><tr><td>C</td><td>100</td></tr><tr><td>D</td><td>500</td></tr><tr><td>M</td><td>1000</td></tr></tbody></table><p>例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：</p><ul><li>I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。<blockquote><ul><li>X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </li><li>C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。</li></ul></blockquote></li></ul><p>给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。</p><blockquote><p><strong>例1</strong>: </p><blockquote><p><strong>输入</strong>: 3<br><strong>输出</strong>: “III”</p></blockquote><p><strong>例2</strong>: </p><blockquote><p><strong>输入</strong>: 4<br><strong>输出</strong>: “IV”</p></blockquote><p><strong>例3</strong>: </p><blockquote><p><strong>输入</strong>: 9<br><strong>输出</strong>: “IX”</p></blockquote><p><strong>例4</strong>: </p><blockquote><p><strong>输入</strong>: 58<br><strong>输出</strong>: “LVIII”<br><strong>解释</strong>: L = 50, V = 5, III = 3.</p></blockquote><p><strong>例5</strong>: </p><blockquote><p><strong>输入</strong>: 1994<br><strong>输出</strong>: “MCMXCIV”<br><strong>解释</strong>: M = 1000, CM = 900, XC = 90， IV = 4.</p></blockquote></blockquote></blockquote><h1 id="解法一-Mine"><a href="#解法一-Mine" class="headerlink" title="解法一(Mine)"></a>解法一(Mine)</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>对每一位上的数字分别处理，对个十百位上的4,9进行特殊处理。</p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">intToRoman</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="comment">// 千位</span></span><br><span class="line">        temp = num / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s.append(<span class="string">"M"</span>);</span><br><span class="line">            temp--;</span><br><span class="line">        &#125;</span><br><span class="line">        num %= <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 百位</span></span><br><span class="line">        temp = num / <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">9</span>) &#123;</span><br><span class="line">            s.append(<span class="string">"CM"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">4</span>) &#123;</span><br><span class="line">            s.append(<span class="string">"CD"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">                s.append(<span class="string">"D"</span>);</span><br><span class="line">                temp -= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                s.append(<span class="string">"C"</span>);</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num %= <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 十位</span></span><br><span class="line">        temp = num / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">9</span>) &#123;</span><br><span class="line">            s.append(<span class="string">"XC"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">4</span>) &#123;</span><br><span class="line">            s.append(<span class="string">"XL"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">                s.append(<span class="string">"L"</span>);</span><br><span class="line">                temp -= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                s.append(<span class="string">"X"</span>);</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num %= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 个位</span></span><br><span class="line">        temp = num;</span><br><span class="line">        <span class="keyword">if</span>(temp == <span class="number">9</span>) &#123;</span><br><span class="line">            s.append(<span class="string">"IX"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="number">4</span>) &#123;</span><br><span class="line">            s.append(<span class="string">"IV"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">                s.append(<span class="string">"V"</span>);</span><br><span class="line">                temp -= <span class="number">5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                s.append(<span class="string">"I"</span>);</span><br><span class="line">                temp--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://gxkord.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://gxkord.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Medium" scheme="https://gxkord.github.io/tags/LeetCode-Medium/"/>
    
  </entry>
  
  <entry>
    <title>11. Container With Most Water(Medium)</title>
    <link href="https://gxkord.github.io/2018/12/16/%E7%AE%97%E6%B3%95/LeetCode/11.%20Container%20With%20Most%20Water(Medium)/"/>
    <id>https://gxkord.github.io/2018/12/16/算法/LeetCode/11. Container With Most Water(Medium)/</id>
    <published>2018-12-16T10:03:22.000Z</published>
    <updated>2019-04-19T10:12:39.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="原题"><a href="#原题" class="headerlink" title="原题"></a>原题</h2><blockquote><p><strong>Description</strong>:<br>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai).<br>n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).<br>Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p><p><strong>Note</strong>:<br>You may not slant the container and n is at least 2.</p><blockquote><p><strong>Example</strong>: </p><blockquote><p><strong>Input</strong>: [1,8,6,2,5,4,8,3,7]<br><strong>Output</strong>: 49<br><strong>Explanation</strong>:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="例子解释.jpg" alt="Example_Explanation" title>                </div>                <div class="image-caption">Example_Explanation</div>            </figure></blockquote></blockquote></blockquote><h2 id="原题翻译"><a href="#原题翻译" class="headerlink" title="原题翻译"></a>原题翻译</h2><blockquote><p><strong>描述</strong>:<br>给定n个非负整数a1，a2，…，an，其中每个表示坐标（i，ai）处的点。<br>绘制n条垂直线，使得线i的两个端点位于（i，ai）和（i，0）。<br>找到两条线，它们与x轴一起形成一个容器，这样容器就含有最多的水。</p></blockquote><blockquote></blockquote><blockquote><p><strong>另外</strong>:<br>不要倾斜容器，n至少为2。</p><blockquote><p><strong>例如</strong>: </p><blockquote><p><strong>输如</strong>: [1,8,6,2,5,4,8,3,7]<br><strong>输出</strong>: 49<br><strong>解释</strong>:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="例子解释.jpg" alt="例子解释" title>                </div>                <div class="image-caption">例子解释</div>            </figure></blockquote></blockquote></blockquote><h1 id="解法一-Mine"><a href="#解法一-Mine" class="headerlink" title="解法一(Mine)"></a>解法一(Mine)</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>得到可能出现的面积，求最大值。</p><blockquote><p>时间复杂度：O(n^2)。<br>打败了22.44%的答案。</p></blockquote><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; height.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; height.length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = Math.min(height[i], height[j]);</span><br><span class="line">            <span class="keyword">int</span> r = temp * (j - i);</span><br><span class="line">            <span class="keyword">if</span>(r &gt; result)</span><br><span class="line">                result = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><p>仔细想想，解法一有什么问题？<br>在本题的例子中，第一条线高度为1，如果按照第一种解法运行，右边界需要从左往右遍历，依次求面积进行比较。但事实上，容器的高是由最短的线决定的，容器的面积毫无疑问地随右边界的增加而增加。我们真的有必要求出每块面积进行比较吗？<br>没错，这道题可以由一个标准的<strong>首尾指针法</strong>来解。</p><blockquote><p>时间复杂度：O(n)。</p><h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">&gt;         <span class="keyword">int</span> maxarea = <span class="number">0</span>, l = <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">&gt;         <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">&gt;             maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l));</span><br><span class="line">&gt;             <span class="keyword">if</span> (height[l] &lt; height[r])</span><br><span class="line">&gt;                 l++;</span><br><span class="line">&gt;             <span class="keyword">else</span></span><br><span class="line">&gt;                 r--;</span><br><span class="line">&gt;         &#125;</span><br><span class="line">&gt;         <span class="keyword">return</span> maxarea;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;h2 id=&quot;原题&quot;&gt;&lt;a href=&quot;#原题&quot; class=&quot;headerlink&quot; title=&quot;原题&quot;&gt;&lt;/a&gt;原题&lt;/h
      
    
    </summary>
    
      <category term="算法" scheme="https://gxkord.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LeetCode" scheme="https://gxkord.github.io/tags/LeetCode/"/>
    
      <category term="LeetCode - Medium" scheme="https://gxkord.github.io/tags/LeetCode-Medium/"/>
    
  </entry>
  
  <entry>
    <title>3. 垃圾收集器与内存分配策略</title>
    <link href="https://gxkord.github.io/2018/12/14/Java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA/3.%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>https://gxkord.github.io/2018/12/14/Java/深入理解java虚拟机/3. 垃圾收集器与内存分配策略/</id>
    <published>2018-12-14T12:22:12.000Z</published>
    <updated>2019-04-19T09:50:07.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>垃圾收集</strong>（Garbage Collection, GC）的历史比Java久远。1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。</p><p>目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”时代，那为什么我们还要去了解GC和内存分配？</p><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就需要对这些“自动化”的技术实施必要的监控和调节。</p><p>在Java内存区域中，程序计数器、虚拟机栈、本地方法栈3个区域是线程私有的；栈中的栈帧随方法的进入和退出执行出栈和入栈。这几个区域内不需要过多考虑回收的问题，方法和线程结束后，内存自然就跟随回收了。需要考虑如何回收内存的区域是Java堆和方法区。</p><h1 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h1><p>堆中存放着Java世界中几乎所有的对象实例，垃圾处理器在对堆进行回收前，第一件事就是确定这些对象有没有“死去”？</p><blockquote><p>不能再被任何途径使用的对象，就成为了“<strong>死去</strong>”的对象。</p></blockquote><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>很多教科书上判断对象是否存活的算法是这样的：<strong>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。</strong></p><p>客观来说，引用计数算法（Reference Counting）实现简单，判定效率也很高，但是，主流的Java虚拟机都没用采用它。主要原因是<strong><em>它无法解决对象之间的相互循环引用的问题</em></strong>。</p><p>如下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceCountingGC &#123;</span><br><span class="line">    public Object instance = null;</span><br><span class="line">    private static final int _1MB = 1024*1024;</span><br><span class="line"></span><br><span class="line">    // 这个成员变量唯一意义就是让对象占更大的内存方便在GC日志里观察</span><br><span class="line">    private byte[] bigSize = new byte[2 * _1MB];    </span><br><span class="line"></span><br><span class="line">    public static void testGC() &#123;</span><br><span class="line">        ReferenceCountingGC objA = new ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = new ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = null;</span><br><span class="line">        objB = null;</span><br><span class="line"></span><br><span class="line">        // 假设这里发生GC，objA和objB是否能被回收</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显然，上述代码中，objA和objB互相引用，如果使用引用计数算法，这两个对象将无法被回收。</strong></p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>在主流的商用程序语言的主流实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。<br>这个算法的基本思路：<strong>通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连的时，则证明此对象是不可用的。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="可达性分析.png" alt="可达性分析" title>                </div>                <div class="image-caption">可达性分析</div>            </figure><p>在Java语言中，可作为GC Roots的对象包括以下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul><h2 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h2><p>无论通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判断对象是否存活都与“引用”有关。</p><p>在<strong>JDK1.2以前</strong>，Java中引用的定义很传统：<strong>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表一个引用。</strong></p><p>在<strong>JDK1.2之后</strong>，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度逐渐减弱。</p><ol><li><strong>强引用</strong>：在代码中普遍存在，比如：“Object obj = new Object();”。<strong>只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</strong></li><li><strong>软引用</strong>：用来描述还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK1.2之后，提供了<strong>SoftReference</strong>类来实现软引用。</li><li><strong>弱引用</strong>：也是用来描述非必需对象，但强度比软引用更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。JDK1.2之后，提供了<strong>WeakReference</strong>类来实现软引用。</li><li><strong>虚引用</strong>：最弱的一种引用关系。设置虚引用的唯一目的是能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后，提供了<strong>PhantomReference</strong>类来实现软引用。</li></ol><h2 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h2><blockquote><p>“生存还是死亡这是个问题。”</p><p>既然如此，可达性分析算法中不可达的对象是不是“非死不可”？<br>并不是！</p></blockquote><p>如果一个对象在进行可达性分析后发现没有与GC Roots相连的引用链，那它将会被第一次标记并且进行一次筛选。</p><p><strong>筛选条件</strong>：是否有必要执行finalize()方法。当没有对象没有重写finalize()方法或者finalize()方法已经被虚拟机调用过，将被视为“没有必要执行”。</p><p>如果对象被判定为有必要执行finalize()方法，那么这个对象会被放置在一个叫做F-Queue的队列中，并稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行。</p><blockquote><p>这里的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。<br>如果一个的对象在finalize()方法中执行缓慢，或者进入了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永远处于等待，甚至导致整个内存回收系统崩溃。</p></blockquote><p><strong>finalize()方法是对象死亡前的最后“自救”机会。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此代码演示了两点：</span></span><br><span class="line"><span class="comment"> *   1. 对象可以在被GC时自我拯救。</span></span><br><span class="line"><span class="comment"> *   2. 这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(“yes, I am still alive”);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(“finalize method executed!”);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象第一次成功自救</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 由于finalize方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printn(“no, I am dead”);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面这段代码与上面的完全相同，但是这次自救却失败了</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 由于finalize方法优先级很低，所以暂停0.5秒以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.printn(“no, I am dead”);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，有两段完全一样的代码片段，这行结果却是一次逃脱成功，一次失败，这是因为<strong>任何一个对象的finalize()方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救失败了。</p><p>需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，但是本书作者建议<strong>尽量避免使用它</strong>。因为这是Java刚诞生时为了使C/C++程序员更容易接受它所做出的的妥协。<strong>它的运行代价极高，不确定性极大，无法保证各个对象的调用顺序。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时。</strong></p><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低。</p><p><strong>永久代的垃圾回收主要回收两部分内容：废弃常量和无用的类。</strong></p><p><strong>回收废弃常量</strong>与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String叫做“abc”，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这是发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要满足下面3个条件才能算是“<strong>无用的类</strong>”：</p><ul><li>该类所有的实例都已经被回收。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述条件的无用类进行回收，但这仅仅是“可以”，是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product班的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。</p><p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁定义ClassLoader的场景中都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记 - 清除算法"></a>标记 - 清除算法</h2><p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，正如它的名字一样，算法分为“标记”和“清除”两个阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</strong></p><p>它的不足有两个：一是效率不高，二是清除后会产生大量不连续的内存碎片。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="标记-清除算法.png" alt="标记-清除算法" title>                </div>                <div class="image-caption">标记-清除算法</div>            </figure><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>为了解决效率问题，“复制”（Copying）算法出现了。</p><p><strong>它将可用内存按容量分为大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将还存活的对象复制到另一块上面，然后将已使用过的内存空间一次清理掉。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="复制算法1.png" alt="复制算法1" title>                </div>                <div class="image-caption">复制算法1</div>            </figure><p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司专门的研究表明，新生代中对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例划分内存空间。而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。</p><p>当然，我们并没有办法保证每次回收都有不多于10%的对象存活，当Survior空间不够用时，需要依赖其他内存（这里指老年代）进行<strong>分配担保 （Handle Promotion）</strong>。</p><blockquote><p>暂时利用做担保的内存来存放多余的对象。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="复制算法2.png" alt="复制算法2" title>                </div>                <div class="image-caption">复制算法2</div>            </figure><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>复制算法在对象存活率高时就要进行较多的复制，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所有老年代一般不能直接采用这种算法。</p><p>“标记-整理”（Mark-Compact）算法，<strong>其标记过程与“标记-清除”算法一样，后续则是让存活下来的对象都向一端移动，然后直接清除掉边界以外的内存</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="标记-整理算法.png" alt="标记-整理算法" title>                </div>                <div class="image-caption">标记-整理算法</div>            </figure><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法。一般把Java堆分成新生代和老年代。</p><p><strong>在新生代中，每次垃圾收集时都会有大量对象死去，采用复制算法。</strong></p><p><strong>在老年代中，对象的存活率高，就必须使用“标记-清除”或者“标记-整理”算法。</strong></p><h1 id="HotSpot的算法实现"><a href="#HotSpot的算法实现" class="headerlink" title="HotSpot的算法实现"></a>HotSpot的算法实现</h1><p>上面两小节分别在理论上介绍了对象存活判定算法和垃圾收集算法，而在HotSpot虚拟机上实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。</p><h2 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h2><p>从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots节点主要在全局性的引用（例如常量表或类静态属性）与执行上下文（栈帧中的本地变量表）中，如果逐个检查java堆和方法区的引用，必将消耗很多时间。</p><p>另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保<strong>一致性</strong>的快照中进行。</p><blockquote><p>这里的“一致性”是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况。Sun将这个快照称为“Stop The World”。</p></blockquote><p>这点不满足的话，分析结果准确性就无法保证。这也是导致GC进行时必须停顿所有线程的重要原因之一。</p><p>目前的主流Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文对象和全局引用位置，虚拟机应当有办法直接得知那些地方存放着对象引用。在HotSpot的实现中，是使用一组OopMap的数据结构来达成的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中也会在特定位置记录下栈和寄存器中哪些位置是引用。</p><h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>在OopMap的帮助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：<strong>可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每条指令都生成相应的OopMap，将需要大量额外空间，这样GC的空间成本就会非常高。</strong></p><p>实际上，HotSpot也没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置称为<strong>安全点（Safepoint）</strong>。</p><p>安全点的选定基本上以程序“是否具有让程序长时间执行的特征”为标准来选定的。“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p><p>对于Safepoint，另一个需要考虑的问题是<strong>如何在GC发生时让所有线程（不包括执行JNI的线程）都“跑”到最近的安全点上再停顿下来</strong>。有两个解决方案：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。</p><p><strong>抢先式中断</strong>不需要代码主动配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。</p><p><strong>主动式中断</strong>的思想是当GC需要中断线程时，不直接对线程操作，仅仅设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p><h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却不一定。<strong>Safepoint机制保证了程序执行时，在不长的时间内就会遇到GC的Safepoint。而程序“不执行”的时候，就需要安全区域（Safe Region）来解决。</strong></p><blockquote><p>所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求。</p></blockquote><p><strong>安全区域是指在一段代码片段中，引用关系不会发生变化</strong>。在这个区域内的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。</p><p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。<br><strong>没有最好的收集器，我们选择的只是具体应用最合适的收集器。</strong></p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>这是一个“单线程 ”的收集器。</p><blockquote><p>“单线程”的意义并不仅仅说明它只会使用一个CPU或一个收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束</p></blockquote><p>它优于其他收集器的地方：<strong>简单而高效（与其他收集器的单线程比）</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Serial收集器.png" alt="Serial收集器" title>                </div>                <div class="image-caption">Serial收集器</div>            </figure><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="ParNew收集器.png" alt="ParNew收集器" title>                </div>                <div class="image-caption">ParNew收集器</div>            </figure><p>除了Serial收集器之外，只有它能与CMS收集器配合工作。</p><blockquote><p>CMS收集器（Concurrent Mark Sweep），这是第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户现场（基本上）同时工作。</p></blockquote><p>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百保证可以超越Serial收集器。</p><blockquote><p>从ParNew开始，会接触几款并发和并行的收集器。在这里先解释一下这两个概念：</p><p><strong>并行</strong>（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p><p><strong>并发</strong>（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行在另一个CPU上。</p></blockquote><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><p><strong>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Parallel收集器.png" alt="Parallel Scavenge收集器" title>                </div>                <div class="image-caption">Parallel Scavenge收集器</div>            </figure><p>Parallel Scavenge收集器的目标则是<strong>达到一个可控制的吞吐量（Throughput）</strong>。Parallel Scavenge收集器中提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的 –XX:MaxGCPauseMills 参数以及直接设置吞吐量大小的 –XX:GCTimeRatio 参数。</p><p>MaxGCPauseMills参数允许的值是一个大于0的毫秒数，收集器则尽可能保证内存回收花费的时间不超过设定值。不过，并不是将这个参数设置的越小越好，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的。</p><p>GCTimeRatio参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。</p><p>Parallel Scavenge还有一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。自适应调节也是Parallel Scabenge收集器与ParNew收集器的一个重要区别。</p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial Old收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于<strong>给Client模式下的虚拟机使用</strong>。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurret Mode Failure时使用。<br><strong>它的工作过程与Serial收集器相同。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Serial收集器.png" alt="Serial Old收集器" title>                </div>                <div class="image-caption">Serial Old收集器</div>            </figure><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel Old 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。<br>这个收集器在JDK1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于“比较尴尬”的状态。</p><blockquote><p>原因：如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？）。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。</p></blockquote><p><strong>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合。</strong></p><p><strong>它的工作过程与Parallel Scavenge收集器相同。</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="Parallel收集器.png" alt="Parallel Old收集器" title>                </div>                <div class="image-caption">Parallel Old收集器</div>            </figure><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，它的运行过程较为复杂，整个过程分为4个步骤：</p><ul><li><strong>初始标记</strong>（CMS initial mark）</li><li><strong>并发标记</strong>（CMS concurrent mark）</li><li><strong>重新标记</strong>（CMS mark）</li><li><strong>并发清除</strong>（CMS concurrent sweep）</li></ul><p>其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体来说，CMS收集器的回收过程是与用户线程一起并发执行的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="CMS收集器.png" alt="CMS收集器" title>                </div>                <div class="image-caption">CMS收集器</div>            </figure><p>但是CMS还远达不到完美的程度，它有以下3个明显的<strong>缺点</strong>：</p><ul><li><strong>对CPU资源非常敏感。</strong></li><li><strong>无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Failure”失败而导致另一次Full GC的产生。</strong>由于CMS并发清理阶段用户线程运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记之后，CMS无法在当次收集中处理它们，只好留待下一次GC时再清理掉。这部分垃圾就称为“浮动垃圾”。</li><li><strong>“标记-清除”算法收集结束时会产生大量空间碎片。</strong>当空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认开启），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程。内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。还有另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认为0，表示每次进入Full GC时都进行碎片整理）。</li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一。G1是面向服务器端应用的垃圾收集器。<br>与其他GC收集器相比，G1具备如下特点：</p><ul><li><strong>并行与并发</strong>：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li><li><strong>空间整合</strong>：G1从整体上来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）来看是基于“复制”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li><li><strong>可预测的停顿</strong>：G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</li></ul><p>在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老生代的概念，但新生代和老生代不再是物理隔离了，它们都是一部分Region（不需要连续）的集合。</p><p>G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值问题（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以获得尽可能高的收集效率。</p><p>G1把内存“化整为零”的思路，理解起来似乎很容易，但其中的实现细节并不简单。以其中一个细节为例：把Java堆分成多个Region后，垃圾收集是否就真的能以Region为单位进行了？听起来顺理成章，但仔细想想：<strong>Region不可能是孤立的。一个对象分配在某个Region中，它并非只能被本Region中的其他对象引用，而是可以与整个Java堆任意的对象发生引用关系。那在做可达性判定确认对象是否存活的时候，岂不是还得扫描整个Java堆才能保证准确性？</strong>这个问题并非在G1中才有，只是在G1中更为突出。</p><p><strong>在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老生代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。</strong>G1中每个Region都有一个与之对应的Rememered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remebered Set即可保证不对全堆扫描也不会有遗漏。</p><p>如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤： </p><ul><li><strong>初始标记</strong>（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。</li><li><strong>并发标记</strong>（Concurrent Marking）：从GC Root开始对堆内对象进行可达性分析，找出存活对象，这阶段耗时较长，但可与用户程序并发执行。</li><li><strong>最终标记</strong>（Final Marking）：为了修正在并发标记时期因用户程序继续运行而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。</li><li><strong>筛选回收</strong>（Live Data Counting and Evacuation）：首先对各个Region回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。</li></ul><h2 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h2><p>以下为两段典型的GC日志：</p><blockquote><p>33.125: [GC [DefNew: 3324K-&gt;152K(3712K), 0.0025925 secs] 3324K-&gt;152K(11904K), 0.0031680 secs]</p><p>100.667: [Full GC [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(10456K), [Parm : 2999K-&gt;2999K(21248K)], 0.0150007 secs] [Times : user=0.01 sys=0.00, real=0.02 secs]</p></blockquote><p>最前面的数字“33.125”和“100.667”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p><p>GC日志开头的“[GC”和“[Full GC”说明了这次垃圾回收的停顿类型，而不是用来区分新生代GC还是老生代GC的。如果有“Full”，说明这次GC是发生Stop-The-World的，如果调用System.GC()方法所触发的收集，那么在这里将会显示“[Full GC(System)”。</p><p>接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名与使用的GC收集器是密切相关的，例如上面样例使用的Serial收集器中的新生代名，为“Default New Generation” ，所以显示的是“[DefNew”。如果是ParNew收集器，新生代名称就会变成“[ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。</p><p>方括号内部的“3324K-&gt;152K(3712K)”含义是“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-&gt;152K(11904K)”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）”。</p><p>“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。</p><h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><p>内存的分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象分配的规则不是百分百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。</p><p>以下是几条最普遍的内存分配规则。</p><h2 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h2><p>大多数情况下，对象会在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><blockquote><p><strong>Minor GC和Full GC有什么不一样？</strong></p><ol><li>新生代GC(Minor GC）：指发生在新生代中的垃圾回收动作，因为Java对象大多具备朝生夕灭的特性，所以Minor GC分成频繁，一般回收速度也比较快。<blockquote><ol start="2"><li>老生代GC(Major GC/Full GC)：指发生在老生代中的GC，出现了Major GC经常伴随至少一次的Minor GC(并非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。</li></ol></blockquote></li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc  –Xms20M  –Xmx20M  –Xmn10M</span></span><br><span class="line"><span class="comment"> *        –XX:+PrintGCDetails  –XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//出现一次MinorGC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br>[GC [DefNew: <strong>6487K-&gt;194K(9216K)</strong>, 0.0042856 secs] 6487K-&gt;6338K(19456K), 0.0043281 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>Heap<br> def new generation   total 9216K, used 4326K [0x029d0000, 0x033d0000, 0x033d0000)<br>  <strong>eden space 8192K</strong>,  51% used [0x029d0000, 0x02de4828, 0x031d0000)<br>  <strong>from space 1024K</strong>,  14% used [0x032d0000, 0x032f5370, 0x033d0000)<br>  <strong>to   space 1024K</strong>,   0% used [0x031d0000, 0x031d0000, 0x032d0000)<br> tenured generation   total 10240K, used 6144K [0x033d0000, 0x03dd0000, 0x03dd0000)<br>   <strong>the space 10240K</strong>,  60% used [0x033d0000, 0x039d0030, 0x039d0200, 0x03dd0000)<br> compacting perm gen  total 21248K, used 2982K [0x03dd0000, 0x049d0000, 0x07dd0000)<br>   the space 12288K,  17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000)<br>No shared spaces configured.</p><blockquote><p>虚拟机提供了–XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。</p></blockquote><p>上述代码的testAllocation()中分配allocation4对象的语句时，会发生一次Minor GC，这次GC的结果是新生代6652KB变为148KB，而总内存占用量几乎不变（因为allocation1-3均存活，虚拟机几乎没有找到可回收的对象）。这次GC发生的原因是给allocation4分配内存的时候，发现Eden已经被占用6MB，剩余空间已不足以分配allocation4所需的4MB。GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。</p><h2 id="大对象直接进入老生代"><a href="#大对象直接进入老生代" class="headerlink" title="大对象直接进入老生代"></a>大对象直接进入老生代</h2><p>所谓大对象是指，需要大量连续内存空间的Java对象，最经典的大对象就是那种很长的字符串以及数组。大对象对于虚拟机内存分配来说是个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><blockquote><p>对于虚拟机来说，比遇到大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序使请尽量避免。</p></blockquote><p>虚拟机提供了-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接进入老生代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc  –Xms20M  -Xmx20M  -Xmn10M </span></span><br><span class="line"><span class="comment"> *     -XX:+PrintGCDetails  –XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment"> *     -XX:PretenureSizeThreshold=3145728</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testPretenureSizeThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation;</span><br><span class="line">    allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; <span class="comment">//直接分配在老生代</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br>Heap<br> def new generation   total 9216K, used 671K [0x029d0000, 0x023d0000, 0x033d0000)<br>  eden space 8192K,   8% used [0x029d0000, 0x02a77e98, 0x031d0000)<br>  from space 1024K,   0% used [0x031d0000, 0x031d0000, 0x032d0000)<br>  to   space 1024K,   0% used [0x032d0000, 0x032d0000, 0x033d0000)<br> tenured generation   total 10240K, used 4096K [0x033d0000, 0x03dd0000, 0x03dd0000)<br>   <strong>the space 10240K,  40% used</strong> [0x033d0000, 0x037d0010, 0x037d0200, 0x03dd0000)<br> compacting perm gen  total 12288K, used 2107K [0x03dd0000, 0x049d0000, 0x07dd0000)<br>   the space 12288K,  17% used [0x03dd0000, 0x03fdefd0, 0x03fdf000, 0x049d0000)<br>No shared spaces configured.</p><p>因为allocation对象超过了3MB，直接在老分代中分配。</p><h2 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h2><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Servivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升老年代的年龄阙值，可以通过参数-XX:MaxTenuringThreshold设置。</p><p>你可以尝试分别以-XX:MaxTenuringThreshold=1 和 -XX:MaxTenuringThreshold=15两种设置来执行testTenuringThreshold()方法，此方法中的allocation1对象需要256KB内存，Survivor空间可以容纳。当MaxTenuringThreshold=1时，allocation1对象在第二次GC发生时进入老年代，新生代已使用的内存GC后非常干净地变成0KB。而MaxTenuringThreshold=15时，第二次GC发生后，allocation1对象则还留在新生代Survivor空间，这时新生代仍然有404KB占用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc  -Xms20M  -Xmx20M  -Xmn10M  -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> *     -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    <span class="comment">// 什么时候进入老年代取决于 XX:MaxTenuringThreshold设置</span></span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><dl><dt><strong>以MaxTenuringThreshold=1参数来运行的结果：</strong><br>[GC (Allocation Failure) [DefNew<br>Desired survivor size 524288 bytes, new threshold 1 (max 1)<br>-age   1:     414664 bytes,     414664 total<br>: 4859K-&gt;404K(9216K), 0.0065012 secs] 4859K-&gt;4500K(19456K), 0.0065283 secs] [Times: user=0.00 sys=0.00, real=0.02 secs]<br>[GC (Allocation Failure) [DefNew<br>Desired survivor size 524288 bytes, new threshold 1 (max 1)</dt><dd>4500K-&gt;0K(9216K), 0.0009253 secs] 8596K-&gt;4500K(19456K), 0.0009458 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>Heap<br> def new generation   total 9216K, used 4178K [0x029d0000, 0x033d0000, 0x033d0000)<br>  eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)<br>  <strong>from space 1024K,   0% used</strong> [0x031d0000, 0x031d0000, 0x032d0000)<br>  to   space 1024K,   0% used [0x032d0000, 0x032d0000, 0x033d0000)<br> tenured generation   total 10240K, used 4500K [0x033d0000, 0x03dd0000, 0x07dd0000)<br>   <strong>the space 10240K,  43% used</strong> [0x033d0000, 0x03835348, 0x03835400, 0x03dd0000)<br> compacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)<br>   the space 12288K,  17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000]<br>No shared spaces configured.</dd></dl><dl><dt><strong>以MaxTenuringThreshold=15参数来运行的结果：</strong><br>[GC (Allocation Failure) [DefNew<br>Desired survivor size 524288 bytes, new threshold 15 (max 15)<br>-age   1:     414664 bytes,     414664 total<br>: 4859K-&gt;404K(9216K), 0.0049637 secs] 4859K-&gt;4500K(19456K), 0.0049932 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[GC (Allocation Failure) [DefNew<br>Desired survivor size 524288 bytes, new threshold 15 (max 15)<br>-age   2:     414520 bytes,     414520 total</dt><dd>4500K-&gt;404K(9216K), 0.0008091 secs] 8596K-&gt;4500K(19456K), 0.0008305 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>Heap<br> def new generation   total 9216K, used 4582K [0x029d0000, 0x033d0000, 0x033d0000)<br>  eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)<br>  <strong>from space 1024K,   39% used</strong> [0x031d0000, 0x032335338, 0x032d0000)<br>  to   space 1024K,   0% used [0x032d0000, 0x032d0000, 0x033d0000)<br> tenured generation   total 10240K, used 4096K [0x033d0000, 0x03dd0000, 0x03dd0000)<br>   <strong>the space 10240K,  40% used</strong> [0x033d0000, 0x037d0010, 0x037d0200, 0x03dd0000)<br> compacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)<br>   the space 12288K,  17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000]<br>No shared spaces configured.</dd></dl><h2 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h2><p>为了更好地适应不同程序的内存情况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15</span></span><br><span class="line"><span class="comment"> *     -XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testTenuringThreshold2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    <span class="comment">// allocation1 + allocation2大于Survivor空间一半</span></span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[_1MB / <span class="number">4</span>];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">null</span>;</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><dl><dt><strong>运行结果：</strong><br>[GC [DefNew<br>Desired Survivor size 524288 bytes, new threshold 1 (max 15)<br>-age   1:     676824 bytes,     676824 total<br>: 5115K-&gt;660K(9216K), 0.0050136 secs] 5115K-&gt;4756K(19456K), 0.0050443 secs] [Times: user=0.00 sys=0.01, real=0.01 secs]<br>[GC [DefNew<br>Desired Survivor size 524288 bytes, new threshold 15 (max 15)</dt><dd>4756K-&gt;0K(9216K), 0.0010571 secs] 8852K-&gt;4756K(19456K), 0.0011009 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>Heap<br> def new generation   total 9216K, used 4178K [0x029d0000, 0x033d0000, 0x033d0000)<br>  eden space 8192K,  51% used [0x029d0000, 0x02de4828, 0x031d0000)<br>  from space 1024K,   0% used [0x031d0000, 0x031d0000, 0x032d0000)<br>  to   space 1024K,   0% used [0x032d0000, 0x032d0000, 0x033d0000)<br> tenured generation   total 10240K, used 4756K [0x033d0000, 0x03dd0000, 0x03dd0000)<br>   the space 10240K,  46% used [0x033d0000, 0x038753e8, 0x03875400, 0x03dd0000)<br> compacting perm gen  total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000)<br>   the space 12288K,  17% used [0x03dd0000, 0x03fe09a0, 0x03fe0a00, 0x049d0000)<br>No shared spaces configured.</dd></dl><p>在testTenuringThreshold2()方法中，设置-XX:MaxTenuringThreshold=15，会发现运行结果中Survivor的空间仍然为0%，而老年代比预期增加60%，也就是说，allocation1、allocation2对象都直接进入了老年代，而没有等到15岁的临界年龄。因为这两个对象加起来已经到达了512KB，并且它们是同年的，满足同年对象达到Survivor空间的一半规则。我们只要注释掉其中一个对象new操作，就会发现另外一个就不会晋升到老年代中去了。</p><h2 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h2><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许<strong>冒险</strong>，那这时也要改为进行一次Full GC。</p><blockquote><p><strong>“冒险”是冒了什么风险？</strong><br>前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。而老年代进行这样的担保，前期是老年代本身还有容纳这些对象的剩余空间，一个有多少对象会存活下来在实际完成内存回收之前是无法明确知道的，所有只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p></blockquote><p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致<strong>担保失败（Handle Promotion Failure）</strong>。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。（参见以下代码，请在JDK6 Update24之前的版本中运行测试。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM参数：-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:-HandlePromotionFailure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testHandlePromotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6, allocation7;</span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation1 = <span class="keyword">null</span>;</span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation6 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">    allocation4 = <span class="keyword">null</span>;</span><br><span class="line">    allocation5 = <span class="keyword">null</span>;</span><br><span class="line">    allocation6 = <span class="keyword">null</span>;</span><br><span class="line">    allocation7 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以HandlePromotionFailure=false参数来运行的结果：</strong><br>[GC [DefNew: 6651K-&gt;148K(9216K), 0.0078936 secs] 6651K-&gt;4244K(19456K), 0.0079192 secs] [Times: user=0.00 sys=0.02, real=0.02 secs]<br>[GC [DefNew: 6378K-&gt;6378K(9216K), 0.0000206 secs][Tenured: 4096K-&gt;4244K(10240K), 0.0042901 secs] 10474K-&gt;4244K(19456K), [Perm : 2104K-&gt;2104K(12288K)], 0.0043613 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</p><p><strong>以HandlePromotionFailure = true参数来运行的结果：</strong><br>[GC [DefNew: 6651K-&gt;148K(9216K), 0.0054913 secs] 6651K-&gt;4244K(19456K), 0.0055327 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>[GC [DefNew: 6378K-&gt;148K(9216K), 0.0006584 secs] 10474K-&gt;4244K(19456K), 0.0006857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</p><p><strong>在JDK 6 Update 24之后，这个测试结果会有差异，HandlePromotionFailure不会影响到虚拟机空间分配担保策略，观察OpenJDK中的源码变化：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool TenuredGeneration::promotion_attempt_is_safe(size_t</span><br><span class="line">max_promotion_in_bytes) <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 老年代最大可用的连续空间</span></span><br><span class="line">    size_t available = max_contiguous_available();</span><br><span class="line">    <span class="comment">// 每次晋升到老年代的平均大小</span></span><br><span class="line">    size_t av_promo = (size_t) gc_stats()-&gt;avg_promoted()-&gt;padded_average();</span><br><span class="line">    <span class="comment">// 老年代可用空间是否大于平均晋升大小，或者老年代可用空间是否大于当此GC时新生代所有对象容量</span></span><br><span class="line">    bool res = (available &gt;= av_promo) || (available &gt;= max_promotion_in_bytes);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK 6 Update 24之后的规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;垃圾收集&lt;/strong&gt;（Garbage Collection, GC）的历史比Java久远。1960年诞生于MIT的Li
      
    
    </summary>
    
      <category term="Java" scheme="https://gxkord.github.io/categories/Java/"/>
    
    
      <category term="《深入理解Java虚拟机》" scheme="https://gxkord.github.io/tags/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E3%80%8B/"/>
    
      <category term="第二部分 自动内存管理机制" scheme="https://gxkord.github.io/tags/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
      <category term="JVM" scheme="https://gxkord.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
