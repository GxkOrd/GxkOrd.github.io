<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>2. 面向对象设计原则 | MyBlog - GxkOrd</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="《Java设计模式》">
    <meta name="description" content="概述软件的可维护性（Maintainability）和可复用性（Reusability）是两个非常重要的用于衡量软件质量的属性。  软件的可维护性：软件能够被理解、改正、适应及扩展的难易程度。  软件的可复用性：软件能够被重复使用的难易程度。   面向对象设计的目标之一在于支持可维护性复用，也是后续设计模式学习的基础。 常见的面向对象原则有7种。 单一职责原则使用频率：★★★★☆ 定义  单一职责">
<meta name="keywords" content="《Java设计模式》">
<meta property="og:type" content="article">
<meta property="og:title" content="2. 面向对象设计原则">
<meta property="og:url" content="https://gxkord.github.io/2019/03/23/Java/Java设计模式/2. 面向对象设计原则/index.html">
<meta property="og:site_name" content="MyBlog - GxkOrd">
<meta property="og:description" content="概述软件的可维护性（Maintainability）和可复用性（Reusability）是两个非常重要的用于衡量软件质量的属性。  软件的可维护性：软件能够被理解、改正、适应及扩展的难易程度。  软件的可复用性：软件能够被重复使用的难易程度。   面向对象设计的目标之一在于支持可维护性复用，也是后续设计模式学习的基础。 常见的面向对象原则有7种。 单一职责原则使用频率：★★★★☆ 定义  单一职责">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://gxkord.github.io/2019/03/23/Java/Java设计模式/2/单一职责原则-例子-初始设计方案结构图.jpg">
<meta property="og:image" content="https://gxkord.github.io/2019/03/23/Java/Java设计模式/2/单一职责原则-例子-重构后结构图.jpg">
<meta property="og:image" content="https://gxkord.github.io/2019/03/23/Java/Java设计模式/2/依赖倒转原则-例子-初始设计方案结构图.jpg">
<meta property="og:image" content="https://gxkord.github.io/2019/03/23/Java/Java设计模式/2/依赖倒转原则-例子-重构后结构图.jpg">
<meta property="og:image" content="https://gxkord.github.io/2019/03/23/Java/Java设计模式/2/接口隔离原则-例子-初始设计方案结构图.jpg">
<meta property="og:image" content="https://gxkord.github.io/2019/03/23/Java/Java设计模式/2/接口隔离原则-例子-重构后结构图.jpg">
<meta property="og:image" content="https://gxkord.github.io/2019/03/23/Java/Java设计模式/2/合成复用原则-例子-初始设计方案结构图.jpg">
<meta property="og:image" content="https://gxkord.github.io/2019/03/23/Java/Java设计模式/2/合成复用原则-例子-重构后结构图.jpg">
<meta property="og:image" content="https://gxkord.github.io/2019/03/23/Java/Java设计模式/2/迪米特法则-例子-初始设计方案结构图.jpg">
<meta property="og:image" content="https://gxkord.github.io/2019/03/23/Java/Java设计模式/2/迪米特法则-例子-重构后结构图.jpg">
<meta property="og:updated_time" content="2019-04-19T09:39:49.971Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2. 面向对象设计原则">
<meta name="twitter:description" content="概述软件的可维护性（Maintainability）和可复用性（Reusability）是两个非常重要的用于衡量软件质量的属性。  软件的可维护性：软件能够被理解、改正、适应及扩展的难易程度。  软件的可复用性：软件能够被重复使用的难易程度。   面向对象设计的目标之一在于支持可维护性复用，也是后续设计模式学习的基础。 常见的面向对象原则有7种。 单一职责原则使用频率：★★★★☆ 定义  单一职责">
<meta name="twitter:image" content="https://gxkord.github.io/2019/03/23/Java/Java设计模式/2/单一职责原则-例子-初始设计方案结构图.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="MyBlog - GxkOrd" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">GxkOrd</h5>
          <a href="mailto:gxk295238892@gmail.com" title="gxk295238892@gmail.com" class="mail">gxk295238892@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/GxkOrd" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">2. 面向对象设计原则</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">2. 面向对象设计原则</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-03-23T08:13:00.000Z" itemprop="datePublished" class="page-time">
  2019-03-23
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#概述"><span class="post-toc-number">1.</span> <span class="post-toc-text">概述</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#单一职责原则"><span class="post-toc-number">2.</span> <span class="post-toc-text">单一职责原则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#定义"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#举例"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">举例</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#开闭原则"><span class="post-toc-number">3.</span> <span class="post-toc-text">开闭原则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#定义-1"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">定义</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#里式代换原则"><span class="post-toc-number">4.</span> <span class="post-toc-text">里式代换原则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#定义-2"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#举例-1"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">举例</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#依赖倒转规则"><span class="post-toc-number">5.</span> <span class="post-toc-text">依赖倒转规则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#定义-3"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#举例-2"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">举例</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#接口隔离原则"><span class="post-toc-number">6.</span> <span class="post-toc-text">接口隔离原则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#定义-4"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#举例-3"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">举例</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#合成复用原则"><span class="post-toc-number">7.</span> <span class="post-toc-text">合成复用原则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#定义-5"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#举例-4"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">举例</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#迪米特法则"><span class="post-toc-number">8.</span> <span class="post-toc-text">迪米特法则</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#定义-6"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">定义</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#举例-5"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">举例</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-Java/Java设计模式/2. 面向对象设计原则"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">2. 面向对象设计原则</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-03-23 16:13:00" datetime="2019-03-23T08:13:00.000Z"  itemprop="datePublished">2019-03-23</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Java/">Java</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>软件的<strong>可维护性（Maintainability）</strong>和<strong>可复用性（Reusability）</strong>是两个非常重要的用于衡量软件质量的属性。</p>
<ul>
<li><p>软件的可维护性：软件能够被理解、改正、适应及扩展的难易程度。</p>
</li>
<li><p>软件的可复用性：软件能够被重复使用的难易程度。</p>
</li>
</ul>
<p>面向对象设计的目标之一在于支持可维护性复用，也是后续设计模式学习的基础。</p>
<p>常见的面向对象原则有7种。</p>
<h1 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h1><p>使用频率：★★★★☆</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p> 单一职责原则是最简单的面向对象设计原则，它<strong>用于控制类的粒度大小</strong>。</p>
</blockquote>
<ul>
<li><p><strong>单一职责原则</strong>：一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。</p>
</li>
<li><p><strong>Single Responsibility Rrincipe(SRP)</strong>: Every object should have a single responsibility, and that responsibility should be entirely encapsulated by the class.</p>
</li>
</ul>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><blockquote>
<p>某软件公司开发人员针对CRM（Customer Relationship Management，客户关系管理）系统中的客户信息图形统计模块提出下图所示的初始设计方案。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/23/Java/Java设计模式/2/单一职责原则-例子-初始设计方案结构图.jpg" alt="初始设计方案结构图" title>
                </div>
                <div class="image-caption">初始设计方案结构图</div>
            </figure>

<ul>
<li><p>getConnection()方法用于连接数据库</p>
</li>
<li><p>findCustomers()方法用于查询所有客户信息</p>
</li>
<li><p>createChart()方法用于创建图表</p>
</li>
<li><p>displayChart()方法用于显示图标</p>
</li>
</ul>
<p>现使用单一职责原则对其进行重构。</p>
</blockquote>
<p>在该例中CustomerDataChart类承担了 太多的职责。如果在其他类中也需要连接数据库或查询所有客户信息，则难以实现代码的复用。因此需要对该类进行拆分：</p>
<ul>
<li><p>DBUtils：负责连接数据库。</p>
</li>
<li><p>CustomerDAO：负责操作数据库中的Customer表。</p>
</li>
<li><p>CustomerDataChart：负责图表的生成和显示。</p>
</li>
</ul>
<p>重构后结构如下图所示：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/23/Java/Java设计模式/2/单一职责原则-例子-重构后结构图.jpg" alt="重构后结构图" title>
                </div>
                <div class="image-caption">重构后结构图</div>
            </figure>

<h1 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h1><p>使用频率：★★★★★</p>
<h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>开闭原则是面向对象的可复用设计的第一块基石，它是最重要的面向对象设计原则。</p>
</blockquote>
<ul>
<li><p><strong>开闭原则</strong>：软件实体应当对扩展开放，对修改关闭。</p>
</li>
<li><p><strong>Single Responsibility Rrincipe(SRP)</strong>: Software entities should be open for extension, but closed for modification.</p>
</li>
</ul>
<h1 id="里式代换原则"><a href="#里式代换原则" class="headerlink" title="里式代换原则"></a>里式代换原则</h1><p>使用频率：★★★★★</p>
<h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>里式代换原则是实现开闭原则的重要方式之一。</p>
</blockquote>
<p>里氏代换原则由2008年图灵奖得主、美国第一位计算机科学女博士Barbara Liskov教授和卡内基·梅隆大学Jeannette Wing教授于1994年提出。</p>
<blockquote>
<p>其严格表述如下：</p>
<p><strong>如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。（f for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is uchanged when o1 is substituted for o2 then S is a subtype of T.</strong>）</p>
<p>但这个定义不太容易理解。</p>
</blockquote>
<p>另一个通俗的定义：</p>
<ul>
<li><p><strong>里式代换原则</strong>：所有引用基类（父类）的地方必须能透明地使用其子类的对象。</p>
</li>
<li><p><strong>Liskov Substitution Principle(LSP)</strong>: Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>
</li>
</ul>
<h2 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h2><p>我（People类实例）喜欢（like方法）动物（Animal类），那我一定也喜欢狗（Dog类）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">People i = <span class="keyword">new</span> People();</span><br><span class="line">i.like(Animal.class);</span><br><span class="line">System.out.println(i.isLike(Dog.class)); <span class="comment">// 返回结果应为true</span></span><br></pre></td></tr></table></figure>

<h1 id="依赖倒转规则"><a href="#依赖倒转规则" class="headerlink" title="依赖倒转规则"></a>依赖倒转规则</h1><p>使用频率：★★★★★</p>
<h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>如果说开闭原则是面向对象设计的目标的话，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。</p>
</blockquote>
<ul>
<li><p><strong>依赖倒转原则</strong>：高层模块不应该依赖底层模块，他们都用该依赖抽象。抽象不应该依赖于细节，细节应当依赖于抽象。</p>
</li>
<li><p><strong>(Dependency Inversion Principle, DIP)</strong>: High level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions.</p>
</li>
</ul>
<p>简单来说，依赖倒转原则要求针对接口编程，不要针对实现编程。</p>
<h2 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h2><blockquote>
<p>下面通过一个简单实例来加强对开闭原则、里氏代换原则和依赖倒转原则的理解：</p>
<p>某软件公司开发人员在开发CRM系统时发现该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。在客户数据操作类CustomerDAO中将调用数据格式转换类的方法来实现数据转换，初始设计方案结构如下图所示。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/23/Java/Java设计模式/2/依赖倒转原则-例子-初始设计方案结构图.jpg" alt="初始设计方案结构图" title>
                </div>
                <div class="image-caption">初始设计方案结构图</div>
            </figure>
</blockquote>
<p>该结构存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要经常更换数据转换类。</p>
<p>可以通过抽象数据转换类来解决这个问题。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/23/Java/Java设计模式/2/依赖倒转原则-例子-重构后结构图.jpg" alt="重构后结构图" title>
                </div>
                <div class="image-caption">重构后结构图</div>
            </figure>

<h1 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h1><p>使用频率：★★☆☆☆</p>
<h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><ul>
<li><p><strong>接口隔离原则</strong>：客户端不应该依赖那些它不需要的接口。</p>
</li>
<li><p><strong>Interface Segregation Principle(ISP)</strong>: Clients should not be forced to depend upon interfaces that they do not use.</p>
</li>
</ul>
<blockquote>
<p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。<strong>每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。</strong></p>
<p>这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p>
<p>(1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。<br>(2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。</p>
</blockquote>
<h2 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h2><blockquote>
<p>某软件公司开发人员针对CRM系统的客户数据显示模块设计了如图所示的CustomerDataDisplay接口。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/23/Java/Java设计模式/2/接口隔离原则-例子-初始设计方案结构图.jpg" alt="初始设计方案结构图" title>
                </div>
                <div class="image-caption">初始设计方案结构图</div>
            </figure>

<ul>
<li><p>readData()方法用于从文件中读取数据</p>
</li>
<li><p>transformToXML()方法用于将数据转换成XML格式</p>
</li>
<li><p>createChart()方法用来创建图标</p>
</li>
<li><p>displayChart()方法用来显示图标</p>
</li>
<li><p>createReport()方法用于创建文字报表</p>
</li>
<li><p>displayReport()方法用于显示文字报表</p>
</li>
</ul>
<p>在实际使用过程中发现该接口很不灵活，例如：如果一个具体的数据显示类无需进行数据转换（源文件本身就是XML格式），但由于实现了该接口，将不得不实现其中声明的transformToXML()方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需要实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序在编译时将报错。</p>
<p>现使用接口隔离原则对其进行重构。</p>
</blockquote>
<p>该例中，由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责，一方面导致该接口的实现类很庞大，在不同的实现类中都不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程序上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。因此需要将该接口按照接口隔离原则和单一职责原则进行重构，将其中的一些方法封装在不同的小接口中，确保每一个接口使用起来都较为方便，并都承担某一单一角色，每个接口中只包含一个客户端（如模块或类）所需的方法即可。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/23/Java/Java设计模式/2/接口隔离原则-例子-重构后结构图.jpg" alt="重构后结构图" title>
                </div>
                <div class="image-caption">重构后结构图</div>
            </figure>

<p><strong>在使用接口隔离原则时，我们需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。</strong>一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些它们不用的方法。</p>
<h1 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h1><p>使用频率：★★★★☆</p>
<h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>又称为组合/聚合复用原则（Composition/Aggregate Reuse Principle）</p>
</blockquote>
<ul>
<li><p><strong>合成复用原则</strong>：尽量使用对象组合，而不是继承来达到复用的目的。</p>
</li>
<li><p><strong>Composite Reuse Principle(CRP)</strong>: Favor composition of objects over inheritance as a reuse mechanism.</p>
</li>
</ul>
<p>复用时要尽量使用组合/聚合关系（关联关系），少用继承。</p>
<blockquote>
<p>通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的内部细节通常对子类来说是可见的，所以这种复用又称“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来的实现是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。</p>
<p>由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。</p>
</blockquote>
<p>一般而言，<strong>如果两个类之间是“Has-A”的关系应使用组合或聚合，如果是“Is-A”关系可使用继承。</strong>“Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的”一种”；而”Has-A”则不同，它表示某一个角色具有某一项责任。</p>
<h2 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h2><blockquote>
<p>某软件公司开发人员在初期的CRM系统设计中考虑到客户数量不多，系统采用MySQL作为数据库，与数据库操作有关的类如CustomerDAO类等都需要连接数据库，连接数据库的方法getConnection()封装在DBUtil类中，由于需要重用DBUtil类的getConnection()方法，设计人员将CustomerDAO作为DBUtil类的子类，初始设计方案结构如下图所示。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/23/Java/Java设计模式/2/合成复用原则-例子-初始设计方案结构图.jpg" alt="初始设计方案结构图" title>
                </div>
                <div class="image-caption">初始设计方案结构图</div>
            </figure>

<p> 随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违反开闭原则。（当然也可以修改DBUtil类的源代码，同样会违反开闭原则。）</p>
<p>现使用合成复用原则对其进行重构。</p>
</blockquote>
<p>根据合成复用原则，我们在实现复用时应该多用关联，少用继承。因此在本实例中我们可以使用关联复用来取代继承复用，重构后的结构如下图所示：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/23/Java/Java设计模式/2/合成复用原则-例子-重构后结构图.jpg" alt="重构后结构图" title>
                </div>
                <div class="image-caption">重构后结构图</div>
            </figure>

<p>CustomerDAO和DBUtil之间的关系由继承关系变为关联关系，采用依赖注入的方式将DBUtil对象注入到CustomerDAO中，可以使用构造注入，也可以使用Setter注入。如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，如通过子类OracleDBUtil来连接Oracle数据库。由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。例如在CustomerDAO中注入OracleDBUtil对象，即可实现Oracle数据库连接，原有代码无须进行修改，而且还可以很灵活地增加新的数据库连接方式，符合开闭原则</p>
<h1 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h1><p>使用频率：★★★☆☆</p>
<h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><blockquote>
<p>迪米特法则来自于1987年美国东北大学(Northeastern University)一个名为“Demeter”的研究项目。迪米特法则又称为最少知识原则(LeastKnowledge Principle, LKP)。</p>
</blockquote>
<ul>
<li><p><strong>迪米特法则</strong>：一个软件实体应当尽可能少地与其他实体发生相互作用。</p>
</li>
<li><p><strong>Law of Demeter(LoD)</strong>: Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.</p>
</li>
</ul>
<p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。<strong>迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系</strong>。</p>
<p>迪米特法则还有几种定义形式，包括：<strong>不要和“陌生人”说话</strong>、<strong>只与你的直接朋友通信</strong>等，在迪米特法则中，对于一个对象，其朋友包括以下几类：</p>
<p>(1) 当前对象本身(this)；</p>
<p>(2) 以参数形式传入到当前对象方法中的对象；</p>
<p>(3) 当前对象的成员对象；</p>
<p>(4) 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友；</p>
<p>(5) 当前对象所创建的对象。</p>
<p><strong>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。</strong>在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p>
<p>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是<strong>通过引入一个合理的第三者来降低现有对象之间的耦合度</strong>。</p>
<p>在将迪米特法则运用到系统设计中时，要注意下面的几点：<strong>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</strong></p>
<h2 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h2><blockquote>
<p>某软件公司所开发CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应，例如，当一个按钮(Button)被单击时，对应的列表框(List)、组合框(ComboBox)、文本框(TextBox)、文本标签(Label)等都将发生改变，在初始设计方案中，界面控件之间的交互关系可简化为如下图所示结构：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/23/Java/Java设计模式/2/迪米特法则-例子-初始设计方案结构图.jpg" alt="初始设计方案结构图" title>
                </div>
                <div class="image-caption">初始设计方案结构图</div>
            </figure>

<p>在图1中，由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除新控件。</p>
<p>现使用迪米特对其进行重构。</p>
</blockquote>
<p>在本实例中，可以通过引入一个专门用于控制界面控件交互的中间类(Mediator)来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码，重构后结构如下图所示：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/2019/03/23/Java/Java设计模式/2/迪米特法则-例子-重构后结构图.jpg" alt="重构后结构图" title>
                </div>
                <div class="image-caption">重构后结构图</div>
            </figure>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        欢迎您的到来~
        
    </div>
    
    <footer>
        <a href="https://gxkord.github.io">
            <img src="/img/avatar.jpg" alt="GxkOrd">
            GxkOrd
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/《Java设计模式》/">《Java设计模式》</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://gxkord.github.io/2019/03/23/Java/Java设计模式/2. 面向对象设计原则/&title=《2. 面向对象设计原则》 — MyBlog - GxkOrd&pic=https://gxkord.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://gxkord.github.io/2019/03/23/Java/Java设计模式/2. 面向对象设计原则/&title=《2. 面向对象设计原则》 — MyBlog - GxkOrd&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://gxkord.github.io/2019/03/23/Java/Java设计模式/2. 面向对象设计原则/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《2. 面向对象设计原则》 — MyBlog - GxkOrd&url=https://gxkord.github.io/2019/03/23/Java/Java设计模式/2. 面向对象设计原则/&via=https://gxkord.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://gxkord.github.io/2019/03/23/Java/Java设计模式/2. 面向对象设计原则/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2019/03/27/Java/Spring/1. Spring入门/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">1. Spring入门</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">第4章 存储器</h4>
      </a>
    </div>
  
</nav>



    





<section class="comments" id="comments">
    <!-- UY BEGIN -->
    <div id="uyan_frame"></div>
    <script src="http://v2.uyan.cc/code/uyan.js?uid=true"></script>
    <!-- UY END -->
</section>







    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'false' == 'true',
            verify: 'false' == 'true',
            appId: "SLoeTBUGITrQ5mLkNx8CuFaP-gzGzoHsz",
            appKey: "BioO7cbA1cY0CknBdMVVcPao",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
<!--
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
   -->
    <div class="bottom">
        <p><span>GxkOrd &copy; 2015 - 2019</span>
	    <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://gxkord.github.io/2019/03/23/Java/Java设计模式/2. 面向对象设计原则/&title=《2. 面向对象设计原则》 — MyBlog - GxkOrd&pic=https://gxkord.github.io/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://gxkord.github.io/2019/03/23/Java/Java设计模式/2. 面向对象设计原则/&title=《2. 面向对象设计原则》 — MyBlog - GxkOrd&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://gxkord.github.io/2019/03/23/Java/Java设计模式/2. 面向对象设计原则/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《2. 面向对象设计原则》 — MyBlog - GxkOrd&url=https://gxkord.github.io/2019/03/23/Java/Java设计模式/2. 面向对象设计原则/&via=https://gxkord.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://gxkord.github.io/2019/03/23/Java/Java设计模式/2. 面向对象设计原则/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPYAAAD2CAAAAADAeSUUAAADJ0lEQVR42u3aS27jQAwFwNz/0pnNLAYIIr9Hyhi7XVoZiGyxWguGn6+v+Pr+57q+5+fn5J7r+39ev/3mzRc2Njb2m7C/L68k3OtDyQPd/1piwcbGxj6V3Sak344mDyI54uTpbeLExsbGxs7DmqWrJFluSiBsbGzsT2Zvio2kgElSYJJEsbGxsT+TnZQHbUB3sXPqU3pp2NjY2C/Pzqeir//5KfNtbGxs7Bdmb9r3eXGSFBLtUGEW/9/vYmNjYx/Evndl57pgaJtBsyWhovmFjY2NfQS7DS7/D382Bt6MnJMW1fCdYGNjY78we1M8zNJMm3LakXNeLGFjY2Ofwb63JdSOYK9/p317RbGEjY2NfSh79uBZ474tUfIjKKYi2NjY2Eew252W2YrPZgWzxbe/g42Njf3u7Jy3CbFtP7WJsB45Y2NjYx/KzptKeVj7ptVdo4t6Io2NjY39JuxZtzwpPPJB7GzhJh85/xoVNjY29tHsTSM+Sh4lbNbYirI3NjY29hHsPAHk6equ4iRPmbN7sLGxsd+dPVt5yVvzm4PeRPKgFYWNjY19EPsZCzf7BtCs9X9DJsfGxsY+iH2dSO66P29FzVLdLH5sbGzs89h5O6ld9Pm/g2FsbGzs89iz8qNNHu3weFaiFMeKjY2NfRB7dhD5MeV/3ZcT9WAAGxsb+23ZbVh5TbNZ1mnb/W3LCRsbG/tz2LM2fT42yFPdfmAwnEtgY2Njvzy7beU8Y+1y85RN8sPGxsY+id12Wtqg8yfuR8v168HGxsY+gr1p2e8HBvlz21fyIEJsbGzsg9htWdK2h2ZpqW055StB2NjY2Oex8yBmI+FNmtkc4oODwMbGxv4Y9mxwO0tLSQxt02o4o8DGxsZ+E/Z3ebWNoc3AoF3ZLEYX2NjY2Aex2yWbfMiaN6f2/bC8QMLGxsY+ld0mrba1lKSidkB723wbGxsb+yB2u2ozG/QmSSuJ5Gt/YWNjY2OPRrZJ6sqHE7MyCRsbGxt7P3CNVmpuuoqVHWxsbOw3Z7dNpeT+TfLbfCsqcrCxsbEPYt/VgWnHsXlYs+/ekCCxsbGxX539B8NpxHBmtsuhAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '给我回来！';
            clearTimeout(titleTime);
        } else {
            document.title = 'MyBlog - GxkOrd';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
