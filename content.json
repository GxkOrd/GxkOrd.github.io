{"meta":{"title":"MyBlog - GxkOrd","subtitle":null,"description":null,"author":"GxkOrd","url":"https://gxkord.github.io","root":"/"},"pages":[{"title":"categories","date":"2019-08-20T07:30:54.000Z","updated":"2019-08-20T07:33:20.841Z","comments":false,"path":"categories/index.html","permalink":"https://gxkord.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-08-20T07:29:19.000Z","updated":"2019-08-20T07:33:04.968Z","comments":false,"path":"tags/index.html","permalink":"https://gxkord.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"1. Java BIO编程","slug":"Java/Netty/1. Java BIO编程","date":"2020-02-02T04:57:00.000Z","updated":"2020-02-02T06:27:03.442Z","comments":true,"path":"2020/02/02/Java/Netty/1. Java BIO编程/","link":"","permalink":"https://gxkord.github.io/2020/02/02/Java/Netty/1. Java BIO编程/","excerpt":"","text":"I/O模型 I/O 模型的简单理解：用什么样的通道进行数据的发送和接收。它很大程度上决定了程序通信的性能。 Java共支持3种网络编程模型（I/O模式）：BIO、NIO、AIO Java BIO ：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。 Java NIO ：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理。 Java AIO(NIO.2) ：异步非阻塞，AIO 引入异步通道的概念，采用了 Proactor 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。 BIO、NIO、AIO适用场景分析 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。 NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。 AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。 Java BIO基本介绍 Java BIO 就是传统的java io 编程，其相关的类和接口在 java.io。 BIO（blocking I/O）： 同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。 【后面有应用实例】 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，程序简单易理解。 BIO工作原理图 BIO编程简单流程： 服务器端启动一个ServerSocket。 客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户 建立一个线程与之通讯。 客户端发出请求后, 先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。 如果有响应，客户端线程会等待请求结束后，在继续执行。 Java BIO应用实例 编写服务器端：BIOServer，并运行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class BIOServer &#123; public static void main(String[] args) throws Exception &#123; // 线程池机制 // 1.创建一个线程池 // 2.如果有客户端连接，就创建一个线程，与之通讯 ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); ServerSocket serverSocket = new ServerSocket(6666); System.out.println(\"服务器启动了\"); while (true) &#123; System.out.println(\"线程信息 id=\" + Thread.currentThread().getId() + \"，name=\" + Thread.currentThread().getName()); // 等待客户端连接 final Socket socket = serverSocket.accept(); System.out.println(\"连接到一个客户端\"); // 创建一个线程，与之通信 newCachedThreadPool.execute(() -&gt; &#123; handler(socket); &#125;); &#125; &#125; private static void handler(Socket socket) &#123; try &#123; System.out.println(\"线程信息 id=\" + Thread.currentThread().getId() + \"，name=\" + Thread.currentThread().getName()); byte[] bytes = new byte[1024]; // 通过socket获取输入流 InputStream inputStream = socket.getInputStream(); // 循环读取客户端发送的数据 while (true) &#123; int read = inputStream.read(bytes); if (read != -1) &#123; System.out.println(new String(bytes, 0, read)); &#125; else &#123; break; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(\"关闭和client的连接\"); try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 启动服务器端 在cmd命令行中输入： 1telnet 127.0.0.1 6666 Java BIO问题分析 每个请求都需要创建独立的线程，与对应的客户端进行数据 Read，业务处理，数据 Write 。 当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。 连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 Read 操作上，造成线程资源浪费。","categories":[{"name":"Java","slug":"Java","permalink":"https://gxkord.github.io/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://gxkord.github.io/tags/Netty/"}]},{"title":"0. Netty介绍","slug":"Java/Netty/0. Netty介绍","date":"2020-01-31T05:05:00.000Z","updated":"2020-01-31T07:35:25.726Z","comments":true,"path":"2020/01/31/Java/Netty/0. Netty介绍/","link":"","permalink":"https://gxkord.github.io/2020/01/31/Java/Netty/0. Netty介绍/","excerpt":"","text":"学习要求 学习Netty要求已经掌握了 Java 基础编程， 如：Java OOP、Java 多线程、Java IO、Java 网络编程、常用的Java设计模式（观察者模式 ，命令模式，职责链模式等）、常用的数据结构（链表等）。 最好有开发项目和阅读源码的经历。 Netty介绍 Netty 是由 JBOSS 开源的 Java 框架，现为 Github上的独立项目。 官方介绍： Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients. Netty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。 Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。 Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景。 要透彻理解Netty，需要先学习NIO，这样才能阅读 Netty 的源码。 Netty的应用场景互联网行业 在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。 典型的应用：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。 游戏行业 无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用。 Netty 作为高性能的基础通信组件，提供了 TCP/UDP 和 HTTP 协议栈，方便定制和开发私有协议栈，账号登录服务器。 地图服务器之间可以方便的通过 Netty 进行高性能的通信。 大数据领域 经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨界点通信。 它的 Netty Service 基于 Netty 框架二次封装实现。 其他开源项目https://netty.io/wiki/related-projects.html 推荐书籍Norman Maurer/Marvin Allen Wolfthal.《Netty In Action》.","categories":[{"name":"Java","slug":"Java","permalink":"https://gxkord.github.io/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"https://gxkord.github.io/tags/Netty/"}]},{"title":"21. Merge Two Sorted Lists(Easy)","slug":"算法/LeetCode/21. Merge Two Sorted Lists(Easy)","date":"2019-10-16T07:28:00.000Z","updated":"2019-10-16T07:36:45.937Z","comments":true,"path":"2019/10/16/算法/LeetCode/21. Merge Two Sorted Lists(Easy)/","link":"","permalink":"https://gxkord.github.io/2019/10/16/算法/LeetCode/21. Merge Two Sorted Lists(Easy)/","excerpt":"","text":"题目描述原题 Description: Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 原题翻译 描述： 合并两个排序好的链表，并将其作为新链表返回。新链表应该由原链表的节点拼接在一起来创建。 例如： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解法一（mine）主要思想双指针同时遍历两链表。 运行速度：超过了100%的解答。 内存使用：超过了16.16%的解答。 源码123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; ListNode temp = null; if (l1.val &gt; l2.val) &#123; temp = l2; l2 = l2.next; &#125; else &#123; temp = l1; l1 = l1.next; &#125; ListNode head = temp; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &gt; l2.val) &#123; temp.next = l2; l2 = l2.next; &#125; else &#123; temp.next = l1; l1 = l1.next; &#125; temp = temp.next; &#125; if (l1 != null) &#123; temp.next = l1; &#125; else if (l2 != null) &#123; temp.next = l2; &#125; return head; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Easy","slug":"LeetCode-Easy","permalink":"https://gxkord.github.io/tags/LeetCode-Easy/"}]},{"title":"20. Valid Parentheses(Easy)","slug":"算法/LeetCode/20. Valid Parentheses(Easy)","date":"2019-10-15T08:45:00.000Z","updated":"2019-10-16T07:33:30.427Z","comments":true,"path":"2019/10/15/算法/LeetCode/20. Valid Parentheses(Easy)/","link":"","permalink":"https://gxkord.github.io/2019/10/15/算法/LeetCode/20. Valid Parentheses(Easy)/","excerpt":"","text":"题目描述原题 Description: Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: “()” Output: true Example 2: Input: “()[]{}” Output: true Example 3: Input: “(]” Output: false Example 4: Input: “([)]” Output: false Example 5: Input: “{[]}” Output: true 原题翻译 描述： 给定一个String字符串，其只包含以下字符：&#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;，判断该字符串是否有效. 若一个字符串有效，则: 开括号必须用相同类型的括号封闭。 开括号必须以正确的顺序关闭。 请注意，空字符串也被视为有效。 例1： 输入： “()” 输出： true 例2： 输入： “()[]{}” 输出： true 例3： 输入： “(]” 输出： false 例4： 输入： “([)]” 输出： false 例5： 输入： “{[]}” 输出： true 解法一（mine）主要思想 定义一个栈，遍历s对应的char数组放入栈中. 遇到右括号，弹出栈顶元素，若不是对应的左括号，返回false。 运行速度：超过了98.71%的解答。 内存使用：超过了100%的解答。 源码1234567891011121314151617181920class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (char c : s.toCharArray()) &#123; if (c == ')') &#123; if(stack.empty() || stack.pop() != '(') return false; &#125; else if (c == '&#125;') &#123; if(stack.empty() || stack.pop() != '&#123;') return false; &#125; else if (c == ']') &#123; if(stack.empty() || stack.pop() != '[') return false; &#125; else &#123; stack.add(c); &#125; &#125; return stack.empty(); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Easy","slug":"LeetCode-Easy","permalink":"https://gxkord.github.io/tags/LeetCode-Easy/"}]},{"title":"19. Remove Nth Node From End of List(Medium)","slug":"算法/LeetCode/19. Remove Nth Node From End of List(Medium)","date":"2019-10-13T09:06:00.000Z","updated":"2019-10-16T07:33:58.060Z","comments":true,"path":"2019/10/13/算法/LeetCode/19. Remove Nth Node From End of List(Medium)/","link":"","permalink":"https://gxkord.github.io/2019/10/13/算法/LeetCode/19. Remove Nth Node From End of List(Medium)/","excerpt":"","text":"题目描述原题 Description: Given a linked list, remove the n-th node from the end of list and return its head. Example: Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2. After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5. Note: Given n will always be valid. Follow up: Could you do this in one pass? 原题翻译 描述： 给定一个链表，请删除链表尾部起第n个节点，然后返回其头部。 例如： 给定链表：1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2。 删除尾部第二个节点后，链表变成 1-&gt;2-&gt;3-&gt;5。 另外： 给定n将始终有效。 提高： 你能否一次通过？ 解法一（mine）主要思想 创建一个队列，先进先出，长度固定为n+1。 遍历链表，将元素放入队列。 遍历完成后，队列中第二个元素即为要删除的元素。 运行速度：超过了10.92%的解答。 内存使用：超过了100%的解答。 源码12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; LinkedList&lt;ListNode&gt; queue = new LinkedList&lt;ListNode&gt;(); ListNode temp = head; while (temp != null) &#123; queue.add(temp); if (queue.size() &gt; n + 1) &#123; queue.remove(); &#125; temp = temp.next; &#125; // if (queue.size() &lt; n) &#123; // 若队列长度小于n，则原链表长度小于n，不存在倒数第n个元素 // return head; // &#125; if (queue.size() == n) &#123; // 若队列长度等于n，则需删除原链表第一个元素 return head.next; &#125; // 若队列长度等于n+1，则需删除队列中第二个元素 temp = queue.getFirst(); temp.next = temp.next.next; return head; &#125;&#125; 解法二主要思想使用快慢指针 先使用快指针遍历链表。 当快指针指向要删除的目标元素时，开始使用慢指针遍历链表。 当快指针结束时，慢指针刚好指向要删除的元素的前一个。 修改慢指针所指向元素的next即可。 运行速度：超过了100%的解答。 内存使用：超过了100%的解答。 源码123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode fast = head, slow = head; while (fast != null) &#123; if (n-- &lt; 0) &#123; // 当fast指向要删除的目标元素时，开始移动slow。 slow = slow.next; &#125; fast = fast.next; &#125; if (n &lt; 0) slow.next = slow.next.next; else head = head.next; return head; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Medium","slug":"LeetCode-Medium","permalink":"https://gxkord.github.io/tags/LeetCode-Medium/"}]},{"title":"18. 4Sum(Medium)","slug":"算法/LeetCode/18. 4Sum(Medium)","date":"2019-09-29T11:03:12.000Z","updated":"2019-10-16T07:34:29.073Z","comments":true,"path":"2019/09/29/算法/LeetCode/18. 4Sum(Medium)/","link":"","permalink":"https://gxkord.github.io/2019/09/29/算法/LeetCode/18. 4Sum(Medium)/","excerpt":"","text":"题目描述原题 Description: Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. Example: Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 原题翻译 描述： 给定一个包含n个实数的数组nums和一个实数target，nums中是否存在元素a，b，c，d，使得a + b + c + d = target？ 找到数组中所有唯一的四元组，它们的总和为target。 另外： 结果集中不得包含重复的四元组。 例如： 给定一个数组nums = [1, 0, -1, 0, -2, 2] 和 target = 0. 一个解决方案集合为：[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 解法一主要思想在3sum的基础上，外层多嵌套一层for循环。 运行速度：超过了89.97%的解答。 内存使用：超过了52.17%的解答。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (nums == null || nums.length &lt; 4) &#123; return res; &#125; Arrays.sort(nums); if (4 * nums[0] &gt; target || 4 * nums[nums.length - 1] &lt; target) &#123; return res; &#125; for (int i = 0; i &lt;= nums.length - 4; i++) &#123; if (nums[i] * 4 &gt; target) &#123; break; &#125; if (nums[i] * 4 == target) &#123; if (nums[i] == nums[i + 1] &amp;&amp; nums[i] == nums[i + 2] &amp;&amp; nums[i] == nums[i+3]) &#123; List&lt;Integer&gt; unit = new ArrayList&lt;Integer&gt;(); unit.add(nums[i]); unit.add(nums[i]); unit.add(nums[i]); unit.add(nums[i]); res.add(unit); &#125; break; &#125; if (i == 0 || nums[i] != nums[i - 1]) &#123; // 避免重复遍历 int target2 = target - nums[i]; for (int j = i + 1; j &lt;= nums.length - 3; j++) &#123; // 与3sum相同 if (nums[j] * 3 &gt; target2) &#123; break; &#125; if (nums[j] * 3 == target2) &#123; if (nums[j] == nums[j + 1] &amp;&amp; nums[j] == nums[j + 2]) &#123; List&lt;Integer&gt; unit = new ArrayList&lt;Integer&gt;(); unit.add(nums[i]); unit.add(nums[j]); unit.add(nums[j]); unit.add(nums[j]); res.add(unit); &#125; break; &#125; if (j == i + 1 || nums[j] != nums[j - 1]) &#123; int low = j + 1; int high = nums.length - 1; while (low &lt; high) &#123; int sum = nums[j] + nums[low] + nums[high]; if (sum == target2) &#123; List&lt;Integer&gt; unit = new ArrayList&lt;&gt;(); unit.add(nums[i]); unit.add(nums[j]); unit.add(nums[low]); unit.add(nums[high]); res.add(unit); low++; high--; while (low &lt; high &amp;&amp; nums[low] == nums[low - 1]) &#123; // 避免重复 low++; &#125; while (low &lt; high &amp;&amp; nums[high] == nums[high + 1]) &#123; // 避免重复 high--; &#125; &#125; else if (sum &gt; target2)&#123; high--; &#125; else &#123; low++; &#125; &#125; &#125; &#125; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Medium","slug":"LeetCode-Medium","permalink":"https://gxkord.github.io/tags/LeetCode-Medium/"}]},{"title":"第2章 创建和销毁对象","slug":"Java/Java基础/《Effiective Java》第3版/第2章 创建和销毁对象","date":"2019-08-24T02:20:00.000Z","updated":"2019-09-13T11:41:43.073Z","comments":true,"path":"2019/08/24/Java/Java基础/《Effiective Java》第3版/第2章 创建和销毁对象/","link":"","permalink":"https://gxkord.github.io/2019/08/24/Java/Java基础/《Effiective Java》第3版/第2章 创建和销毁对象/","excerpt":"","text":"声明：本专题为Joshua Bloch所著《Effiective Java》的笔记。 James Gosling（Java之父）：“我很希望10年前就拥有这本书。可能有人认为我不需要任何Java方面的书籍，但是我需要这本书。” 这本书完全称得上是编程神作，无关编程语言。 它唯一的缺点就是中文翻译有些瑕疵，但如果发现了这些瑕疵，就说明你的技术又深入了一步。 这本书是在我刚接触编程时获得的，但那时读起来确实不知所云。 在我独自做过javase，javaee的项目后，再来读仍觉得它难以读懂。 直到我学过了数据结构、设计模式、spring、springboot等等，有了更多的项目经验，再来了解它，才发现原来自己曾经在编程上遇到的多数疑问，它早已有解答。幸得阅之于学生时代，少走些弯路。 第2章 创建和销毁对象 本章的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何能够保证它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清理动作。 第1条：考虑使用静态工厂方法替代构造方法什么是静态工厂方法某个类允许客户端获得其实例的传统方式是提供一个公共的（public）构造方法。 除此之外，还有一种方法是必须要考虑的，即类可以提供一个公共的（public）静态工厂方法（static factory method），它是一个返回类的实例的静态方法。 下面是一个来自Boolean（基本类型boolean的包装类）的简单例子。 123456/** * 作用：将boolean基本类型值转化成一个Boolean对象引用 */public static Boolean valueOf(boolean b) &#123; return b ? Boolean.TRUE : Boolean.FALSE;&#125; 静态工厂方法的优点 静态工厂方法与构造方法不同的第一大优点在于，它们有名称。如果构造方法的参数无法确切地描述被返回的对象，那么具有适当名称的静态工厂方法会更容易使用，并且生成的客户端代码也将更易于阅读。 例如，BigInteger的构造方法BigInteger(int. int. Random)返回的是一个可能为素数的值，如果使用一个名为BigInteger.probablePrime的静态方法来表示，显然更为清楚。（1.4的发行版本中增加了这个方法。） 一个类只能有一个给定签名（方法名和参数列表）的构造方法，编程人员都知道如何避免这个限制：提供两个不同参数列表顺序的构造方法。实际上这是一个非常糟糕的主意。这样的API，使用者永远记不清该用哪个构造方法。阅读和使用这些构造方法的人只有在有参考文档时才知道这些代码的作用。 由于静态方法有名称，所以它们不受上述的限制。当一个类需要多个相同签名的构造方法时，用静态工厂方法代替构造方法，并且慎重地选择方法名称以突出它们之间的区别。 静态工厂方法与构造方法不同的第二大优点在于，不必在每次调用时都创建一个新对象。 这允许不可变类（详见第17条）可以使用预先构建的实例，或者将构造好的实例缓存起来，并反复分配它们以避免创建不必要对象。Boolean.valueOf(boolean)很好地说明了这种技术。这种技术类似于Flyweight模式。如果程序经常创建相同对象，并且创建对象的代价很高，则这项技术可以极大地提升性能。 静态工厂方法能够为重复地调用返回同一对象，这样有助于类总能严格控制在某个时刻哪些实例存在。这种类被称为实例受控的（instance-controlled）。编写实例受控类有以下原因： 确保这个类是单例的（Singleton）（见第3条）或者不可实例化的（详见第4条）。 它还可确保不可变的类（详见第17条）不会存在两个相同的实例，即当且仅当a==b时，e.equals(b)，我们可以使用==替代equals(Object)，从而提升程序运行速度而不影响正确性。Enum类型正使用了这一点。 静态工厂方法与构造方法不同的第三大优点在于，它们可以返回其返回类型的任一子类的对象。这样，我们在选择返回的对象时就有了更大的灵活性。 这种灵活性的一个应用是，API可以返回对象，而不必把对象的类变成公共的，以这种方式隐藏实现类会使API更加简洁。这种技术适用于基于接口的框架（详见第20条），其中的接口为静态工厂方法提供了自然返回类型。 这里的”自然“（原文为natural），并非一种专用术语，而是指在定义接口时，所希望的返回类型。 在Java 8之前，接口不能有静态方法。按照惯例，一个名为Type的接口的静态工厂方法放在名为Types的不可实例化的伴随类（companion class）（详见第4条）中。 例如，java集合框架（Java Collections Framework）的接口有45个实现类，分别提供了不可修改的集合、同步集合等等。几乎所有的实现类都是通过在一个不可实例化的类（java.util.Collections）中的静态工厂方法导出的。所有静态工厂方法返回对象的类都是非公共（nonpublic）的。 Collections Framework API 的规模要比单独导出45 个公共类要小得多，一个API方便了所有实现类。不仅是 API 的数量的减少，还包括概念重量（conceptual weight）：编程者使用API所必须掌握的概念的数量和难度​​。编程者知道了要返回的对象恰好有接口指定的API，就不再需要阅读实现类的文档。此外，这种静态工厂方法要求编程者通过一个该接口类的变量来引用返回的对象，而不是实现类，这是一种良好的习惯（详见第 64 条）。 从 Java 8 开始，取消了接口不能包含静态方法的限制，所以不必再提供一个不可实例化的伴随类。很多公共的静态成员应该放在这个接口之中。但是，请注意，将这些静态方法的大部分实现代码放在单独的包私有类中仍然是必要的，这是因为 Java 8 要求所有接口的静态成员都是公共的。Java 9 允许私有静态方法，但静态属性和静态成员类仍然需要设为公共。 静态工厂方法与构造方法不同的第四大优点在于，返回对象的类可以根据输入参数的不同而不同。声明的返回类型的任何子类都是允许的。为了提升软件的可维护性和性能，返回对象的类也可能随每次发行版本而不同。 例如，EnumSet类（详见第 36 条），它没有公共构造方法，只有静态工厂方法。在OpenJDK 的实现中，是根据底层枚举类型的大小返回两个子类中的一个的实例：如果大多数枚举类型具有 64 个或更少的元素，静态工厂方法将返回一个RegularEnumSet实例，返回一个long类型；如果枚举类型具有六十五个或更多元素，则将返回一个JumboEnumSet实例，返回一个long类型的数组。 这两个实现类的存在对于客户是不可见的。 如果RegularEnumSet不再为小枚举类型提供性能优势，则可以在未来版本中将其淘汰，而不会产生任何不良影响。同样，未来的版本可能会为了提高性能而添加EnumSet的第三个或第四个实现。 编程者既不知道也不需要关心他们从工厂返回的对象的类别；他们只关心它是EnumSet的一些子类。 静态工厂方法与构造方法不同的第五大优点在于，在编写包含该方法的类时，返回的对象的类不需要存在。这种灵活的静态工厂方法构成了服务提供者框架（Service Provider Framework）的基础，例如 JDBC（Java 数据库连接，Java Database Connectivity）API。服务提供者框架，是提供者实现服务的系统，使实现对于编程者可用，将编程者与实现进行分离。 服务提供者框架中有三个基本组：服务接口（Service Interface），提供者注册 API（Provider Registration API），服务访问 API（Service Access API）。以及一个可选的第四个组件：服务提供者接口（Service Provider API）。 服务接口：定义了需要实现的服务。 提供者注册 API：提供者实现服务后，向管理者注册的API。 服务访问 API：编程者获得服务的API。 服务提供者接口：它描述了一个生成服务接口实例的工厂对象。在没有服务提供者接口的情况下，实现必须通过反射进行实例化（详见第 65 条）。 以下为一个完整服务提供者框架的简单实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 服务接口public interface UserService &#123; void login(); void register();&#125;// 服务接口具体实现类public class UserServiceImpl implements UserService &#123; @Override public void login() &#123; System.out.println(\"登陆成功\"); &#125; @Override public void register() &#123; System.out.println(\"注册成功\"); &#125;&#125;// 服务提供者接口public interface ServiceProvider &#123; UserService getUserService();&#125;// 服务提供者接口具体实现类public class ServiceProviderImpl implements ServiceProvider &#123; static &#123; ServiceManager.registerProvider(\"GxkOrd\", new ServiceProviderImpl()); &#125; @Override public UserService getUserService() &#123; return new UserServiceImpl(); &#125;&#125;// 服务管理类public class ServiceManager &#123; private ServiceManager() &#123; &#125; private static final Map&lt;String, ServiceProvider&gt; SERVICE_PROVIDER_MAP = new ConcurrentHashMap&lt;&gt;(); public static void registerProvider(String name, ServiceProvider provider) &#123; SERVICE_PROVIDER_MAP.put(name, provider); &#125; public static UserService getUserService(String providerName) &#123; ServiceProvider provider = SERVICE_PROVIDER_MAP.get(providerName); if (provider == null) &#123; throw new IllegalArgumentException(\"No provider registered with name = \" + providerName); &#125; return provider.getUserService(); &#125;&#125;// 测试public class Test &#123; public static void main(String[] args) &#123; try &#123; Class.forName(\"包名.ServiceProviderImpl\"); UserService userService = ServiceManager.getUserService(\"登陆注册\"); userService.register(); userService.login(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 服务提供者框架模式有许多变种。 例如，服务访问 API 可以向客户端返回比提供者提供的更丰富的服务接口，这是桥接（Bridge）模式。 依赖注入框架（详见第 5 条）可以被看作强大的服务提供者。 从 Java 6 开始，jdk包含一个通用的服务提供者框架java.util.ServiceLoader，所以你不需要，一般也不应该自己编写（详见59条）。JDBC没有使用ServiceLoader，因为前者早于后者。 静态工厂方法的缺点 静态工厂方法的主要缺点在于，类如果不含公共的或者受保护的构造器，就不能被实例化。对于公共的静态工厂方法所返回的非公共类，也同样如此。 例如，不可能将Collections Framework中任何方便的实现类子类化。但这也许因祸得福，因为它鼓励了程序员使用复合（composition）而不是继承（详见第 18 条），而且它是不可变的（详见第 17 条）。 静态工厂方法的第二个缺点是，程序员很难找到它们。它们不像构造方法那样在 API 文档中突出，因此很难实例化一个提供了静态工厂方法而没有构造方法的类。可能有一天，Javadoc 工具会注意到静态工厂方法。同时，你可以通过将注意力吸引到类或接口文档中的静态工厂以及遵守通用的命名约定来减轻这个问题。下面是一些静态工厂方法的常用名称： from —— 一个类型转换方法，它接受单个参数并返回此类型的相应实例，例如：Date d = Date.from(instant); of —— 一个聚合方法，接受多个参数并返回该类型的实例，并把他们合并在一起，例如：Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING); valueOf —— from 和 to 更为详细的替代方式，例如：BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE); instance 或 getInstance —— 返回一个由其参数 (如果有的话) 描述的实例，但不能说它具有相同的值，例如：StackWalker luke = StackWalker.getInstance(options); create 或 newInstance —— 与 instance 或 getInstance 类似，但该方法保证每个调用返回一个新的实例，例如：Object newArray = Array.newInstance(classObject, arrayLen); getType —— 与 getInstance 类似，但是如果在工厂方法中不同的类中使用。Type 是工厂方法返回的对象类型，例如：FileStore fs = Files.getFileStore(path); newType —— 与 newInstance 类似，但是如果在工厂方法中不同的类中使用。Type 是工厂方法返回的对象类型，例如：BufferedReader br = Files.newBufferedReader(path); type —— getType 和 newType 简洁的替代方式，例如：List&lt;Complaint&gt; litany = Collections.list(legacyLitany); 总之，静态工厂方法和公共构造方法都有它们的用途，并且了解它们的相对优点是值得的。但通常，静态工厂更可取，因此避免在没有考虑静态工厂方法的情况下使用公共构造方法。 第2条：当构造方法参数过多时使用builder模式静态工厂方法和构造方法都有一个局限性：它们不能很好地扩展很多可选参数。请考虑一个表示包装食品外面显示营养成分的标签类，这些标签有几个必需的属性（每份的含量，每罐的含量以及每份的卡路里等），还有20多个可选的属性（总脂肪、饱和脂肪、反式脂肪等）。大多数产品的几个可选属性都为非零值。 对于这样的类，我们该选用什么样的构造方法或者静态工厂方法？ 方法1：重叠构造方法模式多数编程者习惯采用重叠构造方法（telescoping constructor）模式：先提供一个必要参数的构造方法，然后第二个构造方法有一个可选参数，第三个构造方法有两个可选参数，依此类推。最后一个构造方法中包含所有可选参数。 以下有一个示例，为了简单起见，它只显示了四个可选属性。 12345678910111213141516171819202122232425262728293031323334353637public class NutritionFacts &#123; private final int servingSize; // (mL) 必选 private final int servings; // (per container) 必选 private final int calories; // (per serving) 可选 private final int fat; // (g/serving) 可选 private final int sodium; // (mg/serving) 可选 private final int carbohydrate; // (g/serving) 可选 public NutritionFacts(int servingSize, int servings) &#123; this(servingSize, servings, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories) &#123; this(servingSize, servings, calories, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat) &#123; this(servingSize, servings, calories, fat, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) &#123; this(servingSize, servings, calories, fat, sodium, 0); &#125; public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate &#123; this.servingSize = servingSize; this.servings = servings; this.calories = calories; this.fat = fat; this.sodium = sodium; this.carbohydrate = carbohydrate; &#125;&#125; 当想要创建一个实例时，可以使用包含所有要设置的参数的最短参数列表的构造方法： 12NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27); 调用这个构造方法通常要设置许多你本不想设置的参数，在上述情况下，我们就为 fat 属性设置了 0 值。在只有六个参数的情况下，看起来可能也不算太糟糕，但随着参数数量的增加，它很快就会失控。 简而言之，虽然重叠构造方法模式是有效的，但当有很多参数时，就会变得很难用，而且不易读。 方法2：JavaBeans模式当在构造方法中遇到许多可选参数时，另一种选择是 JavaBeans 模式：调用一个无参数的构造方法来创建对象，然后调用 setter 方法来设置每个必需的参数和可选参数。 1234567891011121314151617181920public class NutritionFacts &#123; // Parameters initialized to default values (if any) private int servingSize = -1; // 必填; 无默认值 private int servings = -1; // 必填; 无默认值 private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public NutritionFacts() &#123; &#125; // Setters public void setServingSize(int val) &#123; servingSize = val; &#125; public void setServings(int val) &#123; servings = val; &#125; public void setCalories(int val) &#123; calories = val; &#125; public void setFat(int val) &#123; fat = val; &#125; public void setSodium(int val) &#123; sodium = val; &#125; public void setCarbohydrate(int val) &#123; carbohydrate = val; &#125;&#125; 这种模式没有重叠构造方法模式的缺点，虽然有点冗长，但创建实例很容易，并且编写的代码也易于阅读： 123456NutritionFacts cocaCola = new NutritionFacts();cocaCola.setServingSize(240);cocaCola.setServings(8);cocaCola.setCalories(100);cocaCola.setSodium(35);cocaCola.setCarbohydrate(27); 不幸的是，JavaBeans 模式本身有着严重的缺陷。 首先，多个setter方法的调用，分割了对象的构造过程，在这个构造过程中 JavaBean 很可能处于不一致的状态。类也失去了通过检查构造参数的有效性来保证一致性的能力。在不一致的状态下尝试使用对象，可能会导致错误（这并非一种代码上的bug，因此很难调试）。 另一个与此相关的缺点是，JavaBeans 模式排除了让类不可变的可能性（见第17条），这就需要编程者花费额外精力来确保线程安全。 通过在对象构建完成时手动”冻结“对象，并且不允许它在”解冻“之前使用，可以弥补这些缺点，但这种方法十分笨拙，在实践中很少使用。 而且由于编译器无法确保编程者在使用对象之前调用了freeze()方法（冻结对象），在运行时会很容易报错。 方法3：Builder模式幸运的是，还有第三种选择，它既保证了像重叠构造方法模式一样的安全性又具有 JavaBean 模式一般的可读性。这就是Builder模式： 不直接获得所需的对象，而是先使用所有必需的参数调用构造方法 (或静态工厂)获得一个 builder 对象。然后调用 builder 对象的一种类似于setter的方法来设置每个可选参数。最后，客户端调用一个无参的 build 方法来生成对象，该对象通常是不可变的。Builder 通常是它所构建的类的一个静态成员类 (详见第24条)。以下是它在实践中的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class NutritionFacts &#123; private final int servingSize; private final int servings; private final int calories; private final int fat; private final int sodium; private final int carbohydrate; public static class Builder &#123; // 必选参数 private final int servingSize; private final int servings; // 可选参数，初始化默认值 private int calories = 0; private int fat = 0; private int sodium = 0; private int carbohydrate = 0; public Builder(int servingSize, int servings) &#123; this.servingSize = servingSize; this.servings = servings; &#125; public Builder calories(int val) &#123; calories = val; return this; &#125; public Builder fat(int val) &#123; fat = val; return this; &#125; public Builder sodium(int val) &#123; sodium = val; return this; &#125; public Builder carbohydrate(int val) &#123; carbohydrate = val; return this; &#125; public NutritionFacts build() &#123; return new NutritionFacts(this); &#125; &#125; private NutritionFacts(Builder builder) &#123; this.servingSize = builder.servingSize; this.servings = builder.servings; this.calories = builder.calories; this.fat = builder.fat; this.sodium = builder.sodium; this.carbohydrate = builder.carbohydrate; &#125;&#125; NutritionFacts类是不可变的，所有的参数默认值都在一个地方。builder 的 setter 方法返回 builder 本身，这样调用就被链接了起来，从而生成一个流畅的 API。下面是构造代码的示例： 12NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8) .calories(100).sodium(35).carbohydrate(27).build(); 这样，构造代码很容易编写，且更易于阅读。 Builder 模式模拟 Python 和 Scala 中的具名的可选参数。为了简洁起见，省略了有效性检查。可在builder的构造函数和其他方法中检查参数有效性，以快速检测出无效参数。 可在build方法调用的构造方法中检查包含多个参数的不变性。为了确保这些不变性不受攻击，从 builder 复制参数后要对对象属性进行检查（见第50条）。如果检查失败，则抛出 IllegalArgumentException 异常（见第 72条），异常信息指示哪些参数无效（见第75条）。Builder模式非常适合类层次结构。 使用平行层次的 builder，每个嵌套在相应的类中。抽象类有抽象的builder，具体的类有具体的 builder。例如，代表各种比萨饼的根层次结构的抽象类： 1234567891011121314151617181920212223public abstract class Pizza &#123; public enum Topping &#123;HAM, MUSHROOM, ONION, PEPPER, SAUSAGE&#125; final Set&lt;Topping&gt; toppings; abstract static class Builder&lt;T extends Builder&lt;T&gt;&gt; &#123; EnumSet&lt;Topping&gt; toppings = EnumSet.noneOf(Topping.class); public T addTopping(Topping topping) &#123; toppings.add(Objects.requireNonNull(topping)); return self(); &#125; abstract Pizza build(); // 子类必须覆盖此方法才能返回“this” protected abstract T self(); &#125; Pizza(Builder&lt;?&gt; builder) &#123; toppings = builder.toppings.clone(); // 见第50条 &#125;&#125; 请注意，Pizza.Builder是一个带有递归型参数（ recursive type parameter）（见第30条）的泛型类型。它与抽象的self方法一起，允许方法链在子类中也能正常使用，而不需要强制类型转换。由于Java缺少自我类型，习惯上称这种变通的方法为模拟自我类型（simulated self-type）。 这里有两个具体的 Pizza 的子类，其中一个代表纯正纽约风格的披萨，另一个是半圆形烤乳酪披萨。前者有一个所需的尺寸参数，而后者则需要指定酱汁在里面还是在外面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class NyPizza extends Pizza &#123; public enum Size &#123; SMALL, MEDIUM, LARGE &#125; private final Size size; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private final Size size; public Builder(Size size) &#123; this.size = Objects.requireNonNull(size); &#125; @Override public NyPizza build() &#123; return new NyPizza(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125; private NyPizza(Builder builder) &#123; super(builder); size = builder.size; &#125;&#125;public class Calzone extends Pizza &#123; private final boolean sauceInside; public static class Builder extends Pizza.Builder&lt;Builder&gt; &#123; private boolean sauceInside = false; // 默认 public Builder sauceInside() &#123; sauceInside = true; return this; &#125; @Override public Calzone build() &#123; return new Calzone(this); &#125; @Override protected Builder self() &#123; return this; &#125; &#125; private Calzone(Builder builder) &#123; super(builder); sauceInside = builder.sauceInside; &#125;&#125; 注意，每个子类 builder 中的build方法被声明为返回正确的子类：NyPizza.Builder的build方法返回NyPizza，而Calzone.Builder中的build方法返回Calzone。子类中的方法被声明为返回的类型，是在父类中声明的返回类型的子类型，这种技术称为协变返回类型（covariant return typing）。它允许创建时使用这些builder，而不需要强制转换。 以下为创建对象的代码示例（为了简洁起见，假设枚举常量已静态导入）： 12345NyPizza pizza = new NyPizza.Builder(SMALL) .addTopping(SAUSAGE).addTopping(ONION).build();Calzone calzone = new Calzone.Builder() .addTopping(HAM).sauceInside().build(); 相对于构造方法，builder还有一个微小的优势：builder 可以有多个可变参数，因为参数都是在它自己的方法中指定的。另外，builder 可以将多个方法的参数聚合到单个属性中，正如前面的addTopping方法那样。 Builder 模式非常灵活。单个 builder 可以重复使用来构建多个对象。builder 的参数可以在构建方法的调用之前进行调整，以改变创建的对象。builder 可以在创建对象时自动填充一些属性，例如每次创建对象时增加的序列号。 Builder 模式也有缺点。 为了创建对象，首先必须创建它的 builder。虽然创建这个 builder 的成本在实践中不太可能被注意到，但在性能很关键的情况下可能会出现问题。 而且，builder 模式比重叠构造方法模式更冗长，因此只有在有足够的参数时才值得使用它，比如四个或更多。但请记住，务必未雨绸缪。如果在将来会添加更多的参数，请尽快将构造方法（或静态工厂）切换到 builder，当类演化到参数数量失控的时候，过时的构造方法或静态工厂会处于很鸡肋的处境。因此，最好从一开始就创建一个 builder。 总而言之，当发现类的构造方法或静态工厂的参数已经足够多时，特别是在许多参数是可选的或相同类型的情况下，Builder 模式是一个不错的选择。因为Builder的创建代码比重叠构造方法更容易读写，而且比 JavaBeans 更安全。 第3条：使用私有构造方法或枚类实现 Singleton属性单例是指一个仅实例化一次的类。单例对象通常表示无状态对象，如函数（见第24条） 或一个本质上唯一的系统组件。让一个类成为单例会使测试变得十分困难，因为除非它实现了一个充当其类型的接口，否则不可能模拟实现它。 有以下两种常见的方法来实现单例。两者都是通过私有化构造方法和导出公共静态成员来来提供对这个唯一实例的访问。 第一种方法，使用final修饰的公共成员变量： 12345public class Elvis &#123; public static final Elvis INSTANCE = new Elvis(); private Elvis() &#123; ... &#125; public void leaveTheBuilding() &#123; ... &#125;&#125; 私有构造方法只调用一次，来初始化 INSTANCE对象的属性。没有公共的或受保护的构造方法，保证了全局的唯一性：一旦 Elvis 类被初始化，就永远只存在一个实例。客户端的任何行为都不能改变这一点，但需要注意的是：有特权的客户端，可以使用AccessibleObject.setAccessible方法，以反射方式调用私有构造方法（详见第 65 条）。如果需要防止此攻击，可以修改构造方法，使其在被请求创建第二个实例时抛出异常。 第二种方法，使用静态工厂方法： 1234567public class Elvis &#123; private static final Elvis INSTANCE = new Elvis(); private Elvis() &#123; ... &#125; public static Elvis getInstance() &#123; return INSTANCE; &#125; public void leaveTheBuilding() &#123; ... &#125;&#125; 所有对getInstance的调用都会返回相同的对象引用，而且不会创建其他的 Elvis 实例（当然，上一种方法需要注意的点依然存在）。第一种方法（公共成员变量）的主要优点是，API 可以明确表示该类是一个单例：公共成员变量是 final 的，所以它总是包含相同的对象引用。 第二个好处是它更简单。 第二种方法（静态工厂）的一个优点是，它可以随着你的想法灵活地改变，无论该类是否为单例的，都不必修改其 API。静态工厂方法返回唯一的实例，但是可以修改，比如，修改为返回调用它的每个线程的单独实例。 第二个好处是，如果你的应用程序需要它，可以编写一个泛型单例工厂（generic singleton factory ）（详见第30 条）。使用静态工厂的最后一个优点是方法引用可以用supplier（java 1.8的新特性），例如 Elvis::instance 等同于 Supplier 。除了要借助以上优点，公共属性方法更可取。 创建一个使用这两种方法的单例类（第 12 章），仅仅实现Serializable接口是不够的。为了维护单例的保证，声明所有的实例属性为transient，并提供一个readResolve方法（详见第 89条）。否则，每当序列化实例被反序列化时，就会创建一个新的实例（在上述例子中，会出现新的 Elvis 实例）。为了防止这种情况发生，将这个readResolve方法添加到 Elvis 类： 123private Object readResolve() &#123; return INSTANCE;&#125; 实现单例的第三种方法是，声明单一元素的枚举类： 1234public enum Elvis &#123; INSTANCE; public void leaveTheBuilding() &#123; ... &#125;&#125; 这种方式跟公共成员变量方法很类似，但更简洁。枚举也无偿地提供了序列化机制，而且即使是在面对复杂的序列化或反射攻击的时候，也不用担心它会被多次实例化。单一元素的枚举让人感觉有点不自然，但不可否认，它是实现单例的最佳方式。注意，如果单例必须继承Enum以外的父类，那么就不能使用这种方法。（当然，Enum可以实现接口） 第4条：使用私有构造方法实现非实例化有时候，你可能需要编写一个只包含静态方法和静态属性的类。 这种类的名声很不好，因为有些人会在面向对象语言中滥用这样的类来编写过程化的程序。 尽管如此，它们确实有着特有的用途。 比如像java.lang.Math或java.util.Arrays，它们可以用来把基本类型的值或数组类型上的相关方法组织起来。 也可以像java.util.Collections的方式，把实现特定接口的对象使用静态方法（包括工厂方法，详见第 1 条）进行分组。（从 Java 8 开始，你也可以将这些方法放在接口中，如果是你编写了接口并可以进行修改。） 最后，还可以利用这种类把 final 类上的方法进行分组，因为final类不存在子类。 通过将它声明为抽象类，来强制其实现非实例化显然是行不通的。因为该类可以被子类化，子类依然可以被实例化。而且，它会误导使用者以为该类是为继承而设计的（详见第 19 条）。不过，有一个简单的方法来确保非实例化：当类不包含显式构造方法时，会生成一个默认构造方法，因此可以通过包含一个私有构造方法来实现类的非实例化： 1234567public class UtilityClass &#123; // 禁止默认构造函数以实现非实例化 private UtilityClass() &#123; throw new AssertionError(); &#125; ...&#125; 由于显式构造方法是私有的，所以在类之外不可访问到。AssertionError异常不是严格要求的，但它提供了一种保证，以防在类中意外地调用构造方法。它保证类在任何情况下都不会被实例化。这个用法有点违合，好像构造方法就是设计成不能调用的一样。因此，像上述代码一样，添加注释是种非常明智的做法。 这种习惯有一个副作用，阻止了类的子类化。因为所有的构造方法都必须显式或隐式地调用父类构造方法，而子类没有可访问的父类构造方法来调用。 第5条：依赖注入优于硬连接资源（hardwiring resources）许多类依赖于一个或多个底层资源。例如，拼写检查器依赖于字典。常见的一种方式，是将此类声明为静态成员变量（详见第 4 条）: 123456789// 静态成员变量使用不当，不灵活、不可测试！public class SpellChecker &#123; private static final Lexicon dictionary = ...; private SpellChecker() &#123;&#125; // Noninstantiable public static boolean isValid(String word) &#123; ... &#125; public static List&lt;String&gt; suggestions(String typo) &#123; ... &#125;&#125; 另一种常见方式，是将它们实现为单例（详见第 3 条）： 12345678910// 单例使用不当，不灵活、不可测试！public class SpellChecker &#123; private final Lexicon dictionary = ...; private SpellChecker(...) &#123;&#125; public static INSTANCE = new SpellChecker(...); public boolean isValid(String word) &#123; ... &#125; public List&lt;String&gt; suggestions(String typo) &#123; ... &#125;&#125; 这两种方法都不令人满意，因为它们只为对象提供了一本字典。在实际中，每种语言都有自己的字典，特殊的字典被用于特殊的词汇表。另外，使用专门的字典来进行测试也是可取的。想当然地认为一本字典就足够了，这是十分不可取的。 可以通过使dictionary属性设置为非final，并添加一个方法来更改现有拼写检查器中的字典，从而让拼写检查器支持多个字典，但是在并发环境中，这很笨拙且容易出错，不可行。静态成员变量和单例不适用于那些行为被底层资源参数化的类。 若类支持创建多个实例的 （如上述例子中的SpellChecker），每个实例都需要使用者指定资源（如上述例子中的dictionary）。满足这一需求的简单模式是在创建新实例时将资源传递到构造方法中。这是依赖注入（dependency injection）的一种形式：字典是拼写检查器的一个依赖项，当它创建时被注入到拼写检查器中。 1234567891011// 依赖注入提供了灵活性和可测试性public class SpellChecker &#123; private final Lexicon dictionary; public SpellChecker(Lexicon dictionary) &#123; this.dictionary = Objects.requireNonNull(dictionary); &#125; public boolean isValid(String word) &#123; ... &#125; public List&lt;String&gt; suggestions(String typo) &#123; ... &#125;&#125; 依赖注入模式非常简单，许多编程者用了很多年，却不知道它有一个名字。 虽然拼写检查器的例子中只有一个资源（字典），但其实依赖项注入可以使用任意数量的资源和任意依赖图。 它保持了不变性（详见第17条），因此多个客户端可以共享依赖对象（假设客户需要相同的底层资源）。 依赖注入同样适用于构造方法，静态工厂（详见第1条）和 builder 模式（详见第2条）。 该模式的一个非常有用的变型是将资源工厂传递给构造方法。 工厂是可以重复调用以创建类型实例的对象。 这种工厂体现了工厂方法模式（Factory Method pattern）。 Java 8 中引入的Supplier&lt;T&gt;接口非常适合代表工厂。 在输入上采用Supplier&lt;T&gt;的方法通常应该使用有界通配符类型（bounded wildcard type）（详见第31条）来约束工厂的类型参数，以允许使用者传入工厂，创建指定类型的任何子类型。 例如，下面是一个使用者提供的工厂生成 tile 的方法： 1Mosaic create(Supplier&lt;? extends Tile&gt; tileFactory) &#123; ... &#125; 尽管依赖注入极大地提高了灵活性和可测试性，但它可能使大型项目变得混乱，这些项目通常包含数千个依赖项。使用依赖注入框架（如：Dagger、Guice或Spring）可以消除这些混乱（这些框架的使用超出了本书的内容）。但请注意，为手动依赖注入而设计的 API 非常适合使用这些框架。 总之，不要使用单例或静态成员变量来实现依赖于其行为影响类的一个或多个底层资源的类，并且不要让类直接创建这些资源。而是应该将资源或工厂传递给构造方法（或静态工厂或 builder 模式）。这种称为依赖注入的方法将极大地增强类的灵活性、可重用性和可测试性。 第6条：避免创建不必要的对象一般来说，每次需要时一个对象时，最好考虑重用以前的对象而不是创建一个具有相同功能新对象。重用既快速，又流行。如果对象是不可变的（见第17条），它总是可以被重用。 作为一个极端的反面例子，请考虑以下语句： 1String s = new String(\"bikini\"); // DON'T DO THIS! 语句每次被执行时都会创建一个新的String实例，但是这些对象的创建都不是必需的。String 构造方法的参数(&quot;bikini&quot;)本身就是一个String实例，它与构造方法创建的所有对象的功能相同。如果这种用法发生在循环中，或者在频繁调用的方法中，就可以创建很多个毫无必要的String实例。 改进后的版本如下： 1String s = \"bikini\"; 这个版本使用单个String实例，而不是每次执行时创建一个新实例。此外，它可以保证，对于同一虚拟机上中的运行的代码，只要它们包含相同的字符串字面量，对象就能被重用。 通过使用静态工厂方法（见第1条），可以避免创建不需要的对象。例如，工厂方法Boolean.valueOf(String)比构造方法Boolean(String)更可取（后者在 Java 9 中已被弃用）。构造方法每次调用时都必须创建一个新对象，而工厂方法则没有这种要求，实际上也不会这样做。除了重用不可变对象，如果知道它们不会被修改，还可以重用可变对象。 一些对象的创建比其他对象的创建要昂贵得多。如果要重复使用这样一个「昂贵的对象」，建议将其缓存起来以便重复使用。不幸的是，当创建这样一个对象时并不总是很直观明显的。假设你想写一个方法来确定一个字符串是否是一个有效的罗马数字。以下是使用正则表达式完成此操作时最简单方法： 12345// Performance can be greatly improved!static boolean isRomanNumeral(String s) &#123; return s.matches(\"^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)\" + \"(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$\");&#125; 这个实现的问题在于它依赖于String.matches方法。虽然String.matches是检查字符串是否与正则表达式匹配的最简单方法，但它不适合在性能临界的情况下重复使用。其问题是它在内部为正则表达式创建一个Pattern 实例，并且只使用它一次，之后它就被自动GC。创建 Pattern 实例是昂贵的，因为它需要将正则表达式编译成有限状态机（finite state machine）。 为了提高性能，作为类初始化的一部分，将正则表达式显式编译为一个 Pattern 实例（不可变），缓存它，并在isRomanNumeral方法的每个调用中重复使用相同的实例： 12345678910// Reusing expensive object for improved performancepublic class RomanNumerals &#123; private static final Pattern ROMAN = Pattern.compile( \"^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)\" + \"(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$\"); static boolean isRomanNumeral(String s) &#123; return ROMAN.matcher(s).matches(); &#125;&#125; 如果经常调用，isRomanNumeral的改进版本的性能会显著提升。为不可见的 Pattern 实例创建静态 final 修饰的属性，并给它一个名字，这个名字比正则表达式本身更具可读性。 如果包含isRomanNumeral方法的改进版本的类被初始化，但该方法从未被调用，则 ROMAN 属性则没必要初始化。在第一次调用isRomanNumeral方法时，可以通过延迟初始化（ lazily initializing）属性（见第83条）来延迟初始化，但一般不建议这样做。延迟初始化常常会导致实现复杂化，而对性能没有改进（见第67条）。 当一个对象是不可变的时，很明显它可以被安全地重用，但是在其他情况下，它远没有那么明显，甚至是违反直觉的。考虑适配器（adapters）的情况，也称为视图（views）。一个适配器是这样一个对象：它把功能委托一个后备对象（backing object），从而为后备对象提供一个可替代的接口。由于适配器除了后备对象外，没有其他状态信息，因此不需要为某个给定对象创建多个适配器的实例。 例如，Map 接口的keySet方法返回 Map 对象的 Set 视图，包含 Map 中的所有 key。粗看起来，似乎每次调用keySet都必须创建一个新的 Set 实例，但是对给定 Map 对象的keySet的每次调用都返回相同的 Set 实例。 尽管返回的 Set 实例通常是可变的，但是所有返回的对象在功能上都是相同的：当其中一个返回的对象发生变化时，所有其他对象也都变化，因为它们全部是由一个 Map 实例支持的。 虽然创建keySet视图对象的多个实例基本上是无害的，却也是没必要的。 另一种创建不必要的对象的方法是自动装箱（autoboxing），它允许程序员混用基本类型和基本类型的包装类，按需要自动装箱和拆箱。自动装箱虽然使基本类型和基本类型的包装类之间的差别模糊不清，但不会完全消除。它们有微妙的语义区别和不太细微的性能差异（见第61条）。考虑下面的方法，它计算所有正整数的总和。要做到这一点，程序必须使用long类型，因为int类型不足以保存所有正整数的总和： 12345678// Hideously slow! Can you spot the object creation?private static long sum() &#123; Long sum = 0L; for (long i = 0; i &lt;= Integer.MAX_VALUE; i++) sum += i; return sum;&#125; 这个程序的结果是正确的，但由于写错了一个字符，运行的结果要比实际慢很多。变量sum被声明成了Long而不是long，这意味着程序构造了大约 231 不必要的Long实例（大约每次往Long类型的sum变量中增加一个long类型构造的实例），把sum变量的类型由Long改为long，运行时间从 6.3秒降低到了0.59 秒。这个教训很明显：优先使用基本类型而不是装箱的基本类型，要当心无意识的自动装箱。 这一条不应该被误解为暗示对象创建是昂贵的，应该避免创建对象。相反，使用构造方法创建和回收小的对象是非常廉价，构造方法只会做很少的显示工作，尤其是在现代 JVM 实现上。创建额外的对象以增强程序的清晰度、简单性和功能性，这通常是件好事。 相反地，通过维护自己的对象池（object pool）来避免对象创建并不是一个好主意，除非池中的对象非常重量级。对象池的典型例子就是数据库连接池。建立连接的成本非常高，因此重用这些对象是有意义的。但是，一般来说，维护自己的对象池会使代码混乱，增加内存占用，并损害性能。现代 JVM 实现具有高度优化的垃圾收集器，它们的性能远胜于创建轻量级对象池。 这个条目的对应面是第50条的防御性复制（defensive copying）。现在说：「当你应该重用一个现有的对象时，不要创建一个新的对象」，而第50条说：「当你应该创建一个新的对象时，不要重用现有的对象。」请注意，提倡防御性复制时，因重用对象所付出的代价，要远远大于创建重复的对象。未能在需要的情况下实施防御性复制会导致潜在的错误和安全漏洞；而不必要地创建对象只会影响程序的风格和性能。","categories":[{"name":"Java","slug":"Java","permalink":"https://gxkord.github.io/categories/Java/"}],"tags":[{"name":"《Effiective Java》第3版","slug":"《Effiective-Java》第3版","permalink":"https://gxkord.github.io/tags/《Effiective-Java》第3版/"},{"name":"静态工厂方法","slug":"静态工厂方法","permalink":"https://gxkord.github.io/tags/静态工厂方法/"},{"name":"Builder模式","slug":"Builder模式","permalink":"https://gxkord.github.io/tags/Builder模式/"}]},{"title":"17. Letter Combinations of a Phone Number(Medium)","slug":"算法/LeetCode/17. Letter Combinations of a Phone Number(Medium)","date":"2019-08-20T02:28:00.000Z","updated":"2019-10-16T07:35:03.067Z","comments":true,"path":"2019/08/20/算法/LeetCode/17. Letter Combinations of a Phone Number(Medium)/","link":"","permalink":"https://gxkord.github.io/2019/08/20/算法/LeetCode/17. Letter Combinations of a Phone Number(Medium)/","excerpt":"","text":"题目描述原题 Description:Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters. 题目描述 Example: Input: “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. Note: Although the above answer is in lexicographical order, your answer could be in any order you want. 原题翻译 描述：给定包含2-9（包含2和9）的数字的字符串，返回该数字可能表示的所有可能的字母组合。 题目描述 例如： 输入： “23” 输出： [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 另外： 虽然上述例子的输出是按字典顺序排列的，但您的答案可以是任何顺序。 解法一（mine）主要思想 使用String数组保存字符串和数字映射关系（只需数组下标+2，即可获取对应数字）。 获得输入字符串中所有数字对应的字符串，存入集合（letterList）。 取出letterList中第一个元素，分割成字符数组，分别放入集合1（res1）。 取出letterList中第二个元素，分割成字符数组，与集合1中的所有元素进行乘积运算，将结果分别放入集合2（res2）。 res1和res2交换，以保证需要进行乘积运算的集合为res1。 重复步骤3和4，直至遍历完letterList。 最后一步无需再交换res1和res2，直接返回res2即可。 运行速度：超过了65.32%的解答。 内存使用：超过了98.63%的解答。 源码123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public List&lt;String&gt; letterCombinations(String digits) &#123; // 用string数组保存a-z, String[] letters = new String[]&#123;\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; char[] charArray = digits.toCharArray(); // 保存digits每个字符对应的string集合 List&lt;String&gt; letterList = new LinkedList&lt;&gt;(); for (char c : charArray) &#123; // 注意：这里需要char转int，若直接(int)c，会返回ascII码 letterList.add(letters[Integer.parseInt(String.valueOf(c)) - 2]); &#125; List&lt;String&gt; res1 = new LinkedList&lt;&gt;(); List&lt;String&gt; res2 = new LinkedList&lt;&gt;(); List&lt;String&gt; temp; for (String letter : letterList) &#123; char[] chars = letter.toCharArray(); if (res2.size() == 0) &#123; // 若res2为空，直接将letter放入即可 for (char c : chars) &#123; res2.add(String.valueOf(c)); &#125; &#125; else &#123; // 若res2不为空，交换res1和res2 temp = res1; res1 = res2; res2 = temp; // 将遍历letter中每个字符，分别拼接res1中的每一个字符串，并放入res2 for (char c : chars) &#123; for (String s : res1) &#123; res2.add(s + c); &#125; &#125; // 清空res1 res1.clear(); &#125; &#125; return res2; &#125;&#125; 解法二（官方）主要思想 使用map存储（比解法一中的直接数组下标进行存取，更方便维护）。 回溯。 运行速度：超过了65.32%的解答。 内存使用：超过了98.63%的解答。 源码12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; Map&lt;String, String&gt; phone = new HashMap&lt;String, String&gt;() &#123;&#123; put(\"2\", \"abc\"); put(\"3\", \"def\"); put(\"4\", \"ghi\"); put(\"5\", \"jkl\"); put(\"6\", \"mno\"); put(\"7\", \"pqrs\"); put(\"8\", \"tuv\"); put(\"9\", \"wxyz\"); &#125;&#125;; List&lt;String&gt; output = new ArrayList&lt;String&gt;(); public void backtrack(String combination, String next_digits) &#123; // if there is no more digits to check if (next_digits.length() == 0) &#123; // the combination is done output.add(combination); &#125; // if there are still digits to check else &#123; // iterate over all letters which map // the next available digit String digit = next_digits.substring(0, 1); String letters = phone.get(digit); for (int i = 0; i &lt; letters.length(); i++) &#123; String letter = phone.get(digit).substring(i, i + 1); // append the current letter to the combination // and proceed to the next digits backtrack(combination + letter, next_digits.substring(1)); &#125; &#125; &#125; public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits.length() != 0) backtrack(\"\", digits); return output; &#125;&#125; 解法三主要思想 讨论区的答案，与官方答案类似。 注意几点优化的操作： 使用StringBuilder优化String的拼接。 arr[c - &#39;0&#39;]的写法，比解法一中的arr[Integer.parseInt(String.valueOf(c))]更间接有效， LinkedList比ArrayList更快地增删元素。 运行速度：超过了100%的解答。 内存使用：超过了98.63%的解答。 源码1234567891011121314151617181920212223242526class Solution &#123; String arr[] = &#123;\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"&#125;; List&lt;String&gt; res = new LinkedList&lt;String&gt;(); public List&lt;String&gt; letterCombinations(String digits) &#123; if (digits.length() != 0) &#123; recurse(new StringBuilder(), digits, 0); &#125; return res; &#125; private void recurse(StringBuilder sb, String digits, int pos) &#123; char c = digits.charAt(pos); String curr = arr[c - '0']; for (int i = 0; i &lt; curr.length(); i++) &#123; c = curr.charAt(i); sb.append(c); if (pos == digits.length() - 1) &#123; res.add(sb.toString()); &#125; else &#123; recurse(sb, digits, pos + 1); &#125; sb = sb.deleteCharAt(sb.length() - 1); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Medium","slug":"LeetCode-Medium","permalink":"https://gxkord.github.io/tags/LeetCode-Medium/"}]},{"title":"1. SpringBoot入门","slug":"Java/SpringBoot/1. SpringBoot入门","date":"2019-07-20T00:05:00.000Z","updated":"2019-07-25T10:35:57.812Z","comments":true,"path":"2019/07/20/Java/SpringBoot/1. SpringBoot入门/","link":"","permalink":"https://gxkord.github.io/2019/07/20/Java/SpringBoot/1. SpringBoot入门/","excerpt":"","text":"Springboot入门SpringBoot简介 简化Spring应用开发的一个框架 整个Spring技术栈的一个大整合 J2EE开发的一站式解决方案 微服务2014，martin fowler 微服务：架构风格（服务微化） 一个应用应该是一组小型服务，可以通过HTTP的方式进行互通。 单体应用：ALL IN ONE 微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元； 微服务文档 HelloWorld功能：浏览器发送hello请求，服务器接受请求并处理，响应“Hello World!”字符串。 创建maven项目导入依赖123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.gxk&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-01-helloworld&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 编写主程序1234567891011/** * 声明一个SpringBoot主程序类 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // 启动SpringBoot应用 SpringApplication.run(HelloWorldMainApplication.class, args); &#125;&#125; 编写Controller、Service1234567@Controllerpublic class HelloController &#123; @RequestMapping(\"/hello\") public String hello() &#123; return \"Hello World!\"; &#125;&#125; 运行直接右键运行主程序类即可 打包 maven中导入插件 123456789&lt;!-- 可将应用打包成可执行jar包的插件 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 点击idea右侧工具栏中的Maven，运行”项目名-Lifecycle-package“ 将target目录下jar包拷出，使用cmd的”java -jar xxx.jar“运行即可 HelloWorld探究POM文件 父项目 123456789101112131415&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;他的父项目是：&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐dependencies&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring‐boot‐dependencies&lt;/relativePath&gt;&lt;/parent&gt;他来真正管理Spring Boot应用里面的所有依赖版本 Spring Boot的版本仲裁中心。 以后我们导入依赖默认是不需要写版本（没有在dependencies里面管理的依赖自然需要声明版本号） 启动器 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; spring-boot-starter：springboot的场景启动器，帮我们导入了指定模块（如：web）正常运行所依赖的组件。 Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter，相关场景的所有依赖都会导入进来。需要什么功能就导入什么场景启动器 主程序类12345678910/** * 声明一个SpringBoot主程序类 */@SpringBootApplicationpublic class HelloWorldMainApplication &#123; public static void main(String[] args) &#123; // 启动SpringBoot应用 SpringApplication.run(HelloWorldMainApplication.class, args); &#125;&#125; @SpringBootApplication：用来标注SpringBoot的主程序类，SpringBoot应该运行这个类的main方法来启动SpringBoot应用。 12345678910111213141516@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123;...&#125; @SpringBootConfiguration：标注SpringBoot的配置类 @Configuration：标注配置类（Spring） @EnableAutoConfiguration：开启自动配置 123@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123;...&#125; @AutoConfigurationPackage：自动配置包 123@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125; 1234567891011static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; Registrar() &#123; &#125; public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; AutoConfigurationPackages.register(registry, (new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()); &#125; public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.singleton(new AutoConfigurationPackages.PackageImport(metadata)); &#125;&#125; **将主配置类所在包及下面所有子包里面的所有组件扫描到Spring容器。** @Import({AutoConfigurationImportSelector.class}) AutoConfigurationImportSelector：导入哪些组件的选择器。 将所有需要导入的组件以全类名的方式返回，这些组件就会被添加到容器中。 会给容器中导入非常多的自动配置类（xxxAutoConfiguration），就是给容器中导入这个场景需要的所有组件，并配置好这些组件。 Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。以前我们需要自己配置的东西，自动配置类都帮我们。 使用Spring Initializer快速创建SpringBoot项目IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目选择我们需要的模块；向导会联网创建Spring Boot项目默认生成的Spring Boot项目 主程序已经生成好了，我们只需要我们自己的逻辑 resources文件夹中目录结构 static：保存所有的静态资源(js/css/images) templates：保存所有的模板页面(SpringBoot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面，可以使用模板引擎(如：freemarker、thymeleaf)) application.properties：SpringBoot应用的配置文件，可以修改一些默认设置 配置文件配置文件Spring Boot使用全局配置文件，配置文件名是固定的： application.properties application.yml 配置文件作用：修改Spring Boot在底层封装好的默认值。 YAML（YAML AIN’T Markup Language）： 是一个标记语言， 又不是一个标记语言。 以前的配置文件，大多数使用的是 xxx.xml文件。 yaml以数据为中心，比json、xml等更适合做配置文件。 YMAL： 12server: port: 9000 xml： 123&lt;server&gt; &lt;port&gt;9000&lt;/port&gt;&lt;/server&gt; YAML语法基本语法k:(空格)v:表示一堆键值对（空格必须有）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一层级的： 123server: port: 9000 path: /hello 属性和值也是大小写敏感。 值的写法字面量：普通的值（数字，字符串，布尔） k: v:字面量直接来写 字符串默认不用加上单引号或者双引号 “”:双引号 不会转义字符串里的特殊字符；特殊字符会作为本身想要表示的意思如：name:&quot;zhangsan\\n lisi&quot; 输出：zhangsan换行 lisi ‘’:单引号 会转义特殊字符，特殊字符最终只是一个普通的字符串数据 如：name:&#39;zhangsan\\n lisi&#39; 输出：zhangsan\\n lisi 对象、Map（属性和值）键值对： 123frends: lastName: zhangsan age: 20 行内写法： 1friends: &#123;lastName: zhangsan,age: 18&#125; 数组（List、Set）: 用-表示数组中的一个元素 1234pets: ‐ cat ‐ dog ‐ pig 行内写法： 1pets: [cat,dog,pig] 组合变量： 多个组合到一起 配置文件值注入@ConfigurationProperties application.yml 配置文件 123456789101112person: age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: wangwang age: 2 last-name: wanghuahua application.properties 配置文件 12345678person.age=12person.boss=falseperson.last-name=张三person.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=wanghuahuperson.dog.age=15 idea配置文件编码为utf-8，properties文件编码默认GBK，所以中文输出乱码。 解决方法：settings → file encoding → [property → utf-8，勾选转成ascii] javaBean 1234567891011121314151617/*** 将配置文件的配置每个属性的值，映射到组件中* @ConfigurationProperties:告诉SpringBoot将文本的所有属性和配置文件中的相关配置进行绑定* prefix = \"person\" 与配置文件进行一一映射** 只有这个组件是容器中的组件，才能提供到容器中*/@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 导入配置文件处理器，以后编写配置就有提示了 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring‐boot‐configuration‐processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; @Value注解1234567891011121314@Componentpublic class Person &#123; /** * 相当于： * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量/#&#123;spEL&#125;\"&gt;&lt;/property&gt; * &lt;/bean&gt; */ @Value(\"$&#123;person.last-name&#125;\") private String lastName; @Value(\"#&#123;11*2&#125;\") private Integer age; @Value(\"true\") private Boolean boss; @ConfigurationProperties @Value 功能 批量注入配置文件属性 单个指定 松散绑定(语法) 支持 不支持 spEL 不支持 支持 JSR303校验 支持 不支持 复杂类型 支持 不支持 松散语法：javaBean中last-name(或者lastName) → application.properties中的last-name spEL语法：#{11*2} JSR303：@Value会直接忽略，校验规则 JSR303校验： 1234567@Component@ConfigurationProperties(prefix = \"person\")@Validatedpublic class Person &#123; @Email private String lastName;&#125; 复杂类型： 1234567891011121314@Componentpublic class Person &#123; /** * &lt;bean class=\"Person\"&gt; * &lt;property name=\"lastName\" value=\"字面量/$&#123;key&#125;从环境变量/#&#123;spEL&#125;\"&gt;&lt;/property&gt; * &lt;/bean&gt; */ private String lastName; private Integer age; private Boolean boss; @Value(\"$&#123;person.maps&#125;\") // 会报错，@Value不支持复杂类型 private Map&lt;String,Object&gt; maps;&#125; 使用场景分析： 如果我们只是在某个业务逻辑中获取一下配置文件的某一项值，使用@Value 如果专门编写了一个javaBean和配置文件进行映射，我们直接使用@ConfigurationProperties 例如： 编写新的Controller文件 1234567891011@RestControllerpublic class HelloController &#123; @Value(\"$&#123;person.last-name&#125;\") private String name; @RequestMapping(\"/hello\") public String sayHello() &#123; return \"Hello\"+ name; &#125;&#125; 配置文件 12345678person.age=12person.boss=falseperson.last-name=李四person.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=wanghuahuperson.dog.age=15 运行结果 Hello 李四 其他注解 @PropertySource： 作用：加载指定的properties配置文件 举例： 新建一个person.properties文件 12345678person.age=12person.boss=falseperson.last-name=李四person.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=wanghuahuperson.dog.age=15 在javaBean中加入@PropertySource注解 123456@PropertySource(value = &#123;\"classpath:person.properties\"&#125;)@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName;&#125; @ImportResource 作用：导入Spring配置文件，并且让这个配置文件生效 举例： 新建一个Spring的配置文件，bean.xml 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"HelloService\" class=\"com.wdjr.springboot.service.HelloService\"&gt;&lt;/bean&gt;&lt;/beans&gt; 编写测试类，检查容器是否加载Spring配置文件写的bean 12345678@AutowiredApplicationContext ioc;@Testpublic void testHelloService()&#123; boolean b = ioc.containsBean(\"HelloService\"); System.out.println(b);&#125; 运行结果 false 使用@ImportResource注解 将@ImportResource标注在主配置类上 123456789@ImportResource(locations=&#123;\"classpath:beans.xml\"&#125;)@SpringBootApplicationpublic class SpringBoot02ConfigApplication &#123; public static void main(String[] args &#123; SpringApplication.run(SpringBoot02ConfigApplication.class, args); &#125;&#125; 运行结果 true 缺点：每次指定xml文件太麻烦 SpringBoot推荐给容器添加组件的方式（@Configuration + @Bean）： 123456789101112131415/** * @Configuration：指明当前类是一个配置类；就是来代替之前的Spring配置文件 * * 在配置文件中用&lt;bean&gt;&lt;/bean&gt;标签添加组件 */@Configurationpublic class MyAppConfig &#123; // 将方法的返回值添加到容器中,这个组件的id默认为方法名 @Bean public HelloService helloService01() &#123; System.out.println(\"配置类给容器添加了HelloService组件\"); return new HelloService(); &#125;&#125; 12345678@AutowiredApplicationContext ioc;@Testpublic void testHelloService()&#123; boolean b = ioc.containsBean(\"helloService01\"); System.out.println(b);&#125; 配置文件占位符随机数12$&#123;random.value&#125; 、$&#123;random.int&#125;、$&#123;random.long&#125;、$&#123;random.int(10)&#125;、$&#123;random.int[100,200]&#125; 获取配置值12345678person.age=$&#123;random.int&#125;person.boss=falseperson.last-name=张三$&#123;random.uuid&#125;person.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=$&#123;person.last-name&#125;&apos;s wanghuahuperson.dog.age=15 存在以下两种情况： 没有声明person.last-name会报错，新声明的需要加默认值。 12345678person.age=$&#123;random.int&#125;person.boss=falseperson.last-name=张三$&#123;random.uuid&#125;person.maps.k1=v1person.maps.k2=v2person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;&apos;s wanghuahuperson.dog.age=15 输出结果：hello&#39;s wanghuahua Profile多Profile文件我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml application.properties application-dev.properties application-prod.properties 默认使用application.properties application.properties配置文件指定 1spring.profiles.active=dev YAML文档块12345678910111213141516171819server: port: 8081spring: profiles: active: dev---server: port: 9000spring: profiles: dev---server: port: 80spring: profiles: prod 激活指定profile 在配置文件中激活 1spring.profiles.active=dev 命令行 java -jar xxx.jar --spring.profiles.active=dev 虚拟机参数 -Dspring.profiles.active=dev 加载配置文件位置SpringBoot启动扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件 file:./config/ file./ classpath:/config/ classpath:/ 优先级从高到低顺序，高优先级会覆盖低优先级的相同配置，互补配置。 也可以通过spring.config.location来改变默认配置文件位置 。 项目打包好了以后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认的配置文件会共同起作用，互补配置。 java -jar xxx.jar --spring.config.location=E:/work/application.properties 运维比较有用，从外部加载，不用修改别的文件 外部配置的加载顺序SpringBoot也可以从以下位置加载配置，优先级从高到低，高优先级覆盖低优先级，可以互补。 命令行参数 java -jar xxx.jar –server.port=9005 –server.context-path=/abc 来自java:comp/env的JNDI属性 java系统属性（System.getProperties()） 操作系统环境变量 RandomValuePropertySource配置的random.*属性值 jar包外部的application-{profile}.properties 或 application.yml(带Spring.profile)配置文件 jar包内部的application-{profile}.properties 或 application.yml(带Spring.profile)配置文件 jar包外部的application.properties 或 application.yml(带Spring.profile)配置文件 jar包内部的application.properties 或 application.yml(不带spring.profile)配置文件 @Configuration注解类的@PropertySource 通过SpringApplication.setDefaultProperties指定的默认属性 自动配置Spring的所有配置参数 自动配置原理 SpringBoot启动的时候加载主配置类，开启自动配置功能，@EnableAutoConfiguration @EnableAutoConfiguration 作用： 利用AutoConfigurationImportSelector给容器中导入一些组件？ 可以查看selectImports()方法的内容 List configurations = this.getCandidateConfigurations(annotationMetadata, attributes);获取候选的配置 1234SpringFactoriesLoader.loadFactoryNames(）扫描所有jar包类路径下的 MATA-INF/spring.factories把扫描到的这些文件的内容包装成properties对象从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加到容器中 将类路径下 MATE-INF/spring.factories里面配置的所有的EnableAutoConfiguration的值加入到了容器中。 每一个自动配置类进行自动配置功能 以HttpEncodingAutoConfiguration 为例 123456789101112131415161718192021222324252627282930@Configuration //表示是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件@EnableConfigurationProperties(&#123;HttpEncodingProperties.class&#125;)//启动指定类的Configurationproperties功能；将配置文件中的值和HttpEncodingProperties绑定起来了；并把HttpEncodingProperties加入ioc容器中@ConditionalOnWebApplication//根据不同的条件，进行判断，如果满足条件，整个配置类里面的配置就会失效，判断是否为web应用；( type = Type.SERVLET)@ConditionalOnClass(&#123;CharacterEncodingFilter.class&#125;)//判断当前项目有没有这个类，解决乱码的过滤器@ConditionalOnProperty( prefix = \"spring.http.encoding\", value = &#123;\"enabled\"&#125;, matchIfMissing = true)//判断配置文件是否存在某个配置 spring.http.encoding，matchIfMissing = true如果不存在也是成立，即使不配置也生效public class HttpEncodingAutoConfiguration &#123; //给容器添加组件，这个组件的值需要从properties属性中获取 private final HttpEncodingProperties properties; //只有一个有参数构造器情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) &#123; this.properties = properties; &#125; @Bean @ConditionalOnMissingBean public CharacterEncodingFilter characterEncodingFilter() &#123; CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpEncodingProperties.Type.RESPONSE)); return filter; &#125; 所有在配置文件中能配置的属性都是在xxxProperties类中封装着，配置文件能配置什么就可以参照某个功能对应的这个属性类。 123@ConfigurationProperties(prefix = \"spring.http.encoding\") // 从配置文件中的值进行绑定和bean属性进行绑定public class HttpEncodingProperties &#123;...&#125; 根据当前不同条件判断，决定这个配置类是否生效？ 一旦这个配置类生效；这个配置类会给容器添加各种组件；这些组件的属性是从对应的properties中获取的，这些类里面的每个属性又是和配置文件绑定的。 所有自动配置组件每一个xxxAutoConfiguration这样的类都是容器中的一个组件，都加入到容器中。 作用：用它们做自动配置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\\org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityRequestMatcherProviderAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\\org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\\org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration 精髓 SpringBoot启动会加载大量的自动配置类 我们看我们需要的功能有没有SpringBoot默认写好的自动配置类 如果有，再看这个自动配置类中配置了哪些组件（只要有需要用的组件，就不需要再手动配置）；如果有，则需要自己手动配置。 给容器中自动配置添加组件的时候，会从properties类中获取属性。我们就可以在配置文件中指定这些属性的值 xxxAutoConfiguration：自动配置类，给容器中添加组件。 xxxProperties：封装配置文件中的属性。 细节 @Conditional派生注解 利用Spring注解版原生的@Conditional注解 作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效。 @Conditional派生注解 作用（判断是否满足当前指定条件） @ConditionalOnJava 系统的java版本是否符合要求 @ConditionalOnBean 容器中存在指定Bean @ConditionalOnMissBean 容器中不存在指定Bean @ConditionalOnExpression 满足spEL表达式 @ConditionalOnClass 系统中有指定的类 @ConditionalOnMissClass 系统中没有指定的类 @ConditionalOnSingleCandidate 容器中只有一个指定的Bean,或者这个Bean是首选Bean @ConditionalOnProperty 系统中指定的属性是否有指定的值 @ConditionalOnResource 类路径下是否存在指定的资源文件 @ConditionalOnWebApplication 当前是web环境 @ConditionalOnNotWebApplication 当前不是web环境 @ConditionalOnJndi JNDI存在指定项 自动配置报告 自动配置类必须在一定条件下生效。 我们可以通过启用debug=true属性，配置文件，打印自动配合报告，这样就可以知道自动配置类生效。 自动配置报告： 12345678910111213141516171819============================ CONDITIONS EVALUATION REPORT============================ Positive matches:（启动的，匹配成功的） ----------------- CodecsAutoConfiguration matched: - @ConditionalOnClass found required class 'org.springframework.http.codec.CodecConfigurer'; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition) ...... Negative matches:（没有启动的，没有匹配成功的）----------------- ActiveMQAutoConfiguration: Did not match: - @ConditionalOnClass did not find required classes 'javax.jms.ConnectionFactory', 'org.apache.activemq.ActiveMQConnectionFactory' (OnClassCondition) ...... 日志日志框架 日志抽象层 日志实现 JCL(Jakarta Commons Logging) SLF4j(Simple Logging Facade for Java) jboss-logging Log4j JUL(java.util.logging) Log4j2 Logback 选用SLF4J + Logback SpringBoot的底层是Spring框架，使用的JCL，SpringBoot改用了SLF4J。 SLF4J的使用如何在系统中使用SLF4J以后开发的时候，日志记录方法的调用，不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法。 应该给系统里面导入slf4j的jar包和logback的实现jar包。 123456789import org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; SLF4J具体绑定 每一个日志的实现框架都有自己的配置文件。使用slf4j以后，配置文件还是做成日志实现框架的配置文件。 遗留问题如开发a系统（slf4j+logback）：Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis…… c 如何让系统中所有日志统一到slf4j？ 将系统中其他日志框架排除出去 用中间包来替换原有的日志框架 导入slf4j的其他实现 SpringBoot日志关系SpringBoot的日志功能： 123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;version&gt;2.0.1.RELEASE&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; SpringBoot日志关系 总结： SpringBoot底层也是使用slf4jJ+logback SpringBoot也把其他日志替换成了slf4j 起着commons.loggings的名字其实new的SLF4J替换中间包 如果要引入其他框架？一定要把这个框架的默认日志依赖移除掉 日志使用默认配置trace-debug-info-warn-error 可以调整需要的日志级别进行输出，不用注释语句。 1234567891011121314// 记录器Logger logger = LoggerFactory.getLogger(getClass());@Testpublic void contextLoads() &#123; // 日志的级别 // 从低到高 // 可以调整输出的日志级别；日志就只会在这个级别以后的高级别生效 logger.trace(\"这是trace日志\"); logger.debug(\"这是debug信息\"); // SpringBoot默认给的是info级别，如果没指定就是默认的root级别 logger.info(\"这是info日志\"); logger.warn(\"这是warn信息\"); logger.error(\"这是Error信息\");&#125; 调整指定包的日志级别在配置文件中进行配置： 1logging.level.com.gxk=trace 日志输出格式： 12345678#控制台输出的日志格式 #%d：日期#%thread：线程号 #%-5level：靠左 级别 #%logger&#123;50&#125;：全类名50字符限制,否则按照句号分割#%msg：消息+换行#%n：换行logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n SpringBoot修改日志的默认配置： 123456789logging.level.com.gxk=trace#不指定path就是当前目录下生成springboot.log#logging.file=springboot.log#当前磁盘下根路径创建spring文件中log文件夹，使用spring.log作为默认logging.path=/spring/log#控制台输出的日志格式 日期 + 线程号 + 靠左 级别 +全类名50字符限制+消息+换行logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n#指定文件中日志输出的格式logging.pattern.file=xxx 指定配置给类路径下放上每个日志框架自己的配置文件，SpringBoot就不会使用默认的配置 logging System Customization Logback logback-spring.xml,logback-spring.groovy,logback.xml or logback.groovy Log4J2 log4j2-spring.xml or log4j2.xml JDK(Java Util Logging) logging.properties logback.xml直接被logback日志框架识别 ，logback-spring.xml先由SpringBoot识别。 123&lt;springProfile name=\"dev\"&gt; &lt;!-- 可以指定某段配置只在某个环境下生效 --&gt;&lt;/springProfile&gt; 使用参数 --spring.profiles.active=dev运行，即使用这段配置。 切换日志框架 logback → log4j 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;&lt;/dependency&gt; 切换为log4j2的starter 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-log4j2&lt;/artifactId&gt;&lt;/dependency&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://gxkord.github.io/categories/Java/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://gxkord.github.io/tags/SpringBoot/"}]},{"title":"第7章 指令系统","slug":"计算机基础/计算机组成原理/第7章 指令系统","date":"2019-06-17T06:24:00.000Z","updated":"2019-06-18T10:16:32.250Z","comments":true,"path":"2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/","link":"","permalink":"https://gxkord.github.io/2019/06/17/计算机基础/计算机组成原理/第7章 指令系统/","excerpt":"","text":"机器指令 机器指令：每一条机器语言的语句。 指令系统：全部机器指令的集合。 指令的格式是什么 指令码 地址码 寻址方式 指令的字长 固定长度、可变字长 指令的一般格式 指令的一般格式 操作码（反映机器做说明操作） (1) 长度固定 用于指令字长较长的情况，RISC 如 IBM 370，操作码八位 (2) 长度可变 操作码分散在指令字的不同字段中。 (3) 扩展操作码技术 操作码的位数随地址数的减少而增加 三地址指令操作码每减少一种最多可多构成$2^4$种二地址指令； 二地址指令操作码每减少一种最多可多构成$2^4$种一地址指令。 思考：若给定一个指令集，要求对指令集中的指令的操作码进行编码，哪些指令的操作码用长操作码表示，哪些指令的操作码用短操作码表示？ 答：一般在程序执行过程中，经常出现的高频指令可以用短操作码来表示，低频指令用长操作码表示。 地址码 (1) 四地址 $A_1$第一操作数地址 $A_2$第二操作数地址 $A_3$结果的地址 $A_4$下一条指令的地址 $(A_1)OP(A_2)→A_3$ 设指令字长为32位，操作码固定为8位，4个地址字段各占6位，寻址范围为$2^6=64$。如果地址字段均指示内存的地址，则完成一条四地址指令，共需4次访存（取指令一次，取两个操作码两次，存放结果一次）。 程序计数器PC既能存放当前欲执行的指令的地址，又有计数功能，因此它能自动形成下一条指令的地址。这样，指令字中的第四地址字段$A_4$便可省去，即得三地址指令格式。 (2) 三地址 $(A_1)OP(A_2)→A_3$ 4次访存，寻址范围$2^8=256$ 机器在运行过程中，没必要将每次运行结果都存入主存，中间结果可以暂时存放在CPU的寄存器（如ACC）中，这样又省去一个地址字段$A_3$，从而得出二地址指令。 (3) 二地址 $(A_1)OP(A_2)→A_1$ 或 $(A_1)OP(A_2)→A_2$：4次访存 $(A_1)OP(A_2)→ACC$：3次访存 寻址范围$2^{12}=4K$ 如果将一个操作数的地址隐含在运算器的ACC中，则指令字中只需给出一个地址码，构成一地址指令。 (4) 一地址 $(ACC)OP(A_1)→ACC$ 2次访存 寻址范围$2^{24}=16M$ (5) 零地址 在指令字中无地址码，例如，空地址（NOP）、停机（HLT）这类指令只有操作码。而子程序返回（RET）、中断返回（IRET）这类指令没有地址码，其操作数的地址隐含在堆栈指针SP中。 指令字长$$指令字长决定于\\begin{cases}操作码的长度\\操作数地址的长度\\操作数地址的个数\\end{cases}$$ 指令字长固定 指令字长 = 存储字长 指令字长可变 按字节的倍数变化 操作数类型和操作种类操作数类型地址：无符号整数 数字：定点数、浮点数、十进制数 字符：ASCII 逻辑数：逻辑运算 数据在存储器中的存放方式例：12345678H的存放方式 (1) 大端、大尾方式 (2) 小端、小尾方式 字节编址，数据在存储器中的存放方式 从任意位置开始存储 优点：不浪费存储资源。 缺点：除了访问一个字节之外，访问其它任何类型的数据都可能花费两个存储周期的时间。读写控制比较复杂。 从一个存储字的起始位置开始访问 优点：无论访问何种类型的数据，在一个周期内均可完成，读写控制简单。 缺点：严重浪费存储资源。 边界对准方式——从地址的整数倍位置开始访问 数据存放的起始地址是数据长度（按照编址单位进行计算）的整数倍。 本方案是前两个方案的折衷，在一个周期内可以完成存储访问，空间浪费也不太严重。 操作类型 数据传输 源 目的 例如 寄存器 寄存器 MOVE 寄存器 存储器 STORE/MOVE/PUSH 存储器 寄存器 LOAD/MOVE/POP 存储器 存储器 MOVE 算术逻辑操作 加、减、乘、除、增1、减1、求补、浮点运算、十进制运算、与或、非、异或、位操作、位测试、位清除、位求反等。 移位操作 算术移位 逻辑移位 循环移位（带进位和不带进位） 转移 (1) 无条件转移 JMP (2) 条件转移 结果为零转 (Z=1) JZ 结果溢出转 (O=1) JO 结果有进位转 (C=1) JC 跳过一条指令 SKP (3) 调用和返回 (4) 陷阱（Trap）与陷阱指令 意外事故的中断 一般不提供给用户直接使用 在出现事故时，由CPU自动产生并执行（隐指令） 设置供用户使用的陷阱指令 输入输出 入：端口中的内容 → CPU的寄存器 出：CPU的寄存器 → 端口的内容 寻址方式寻址方式：确定本条指令的操作数地址以及下一条将要执行的指令的指令地址的方式，它与硬件结构紧密相关，而且直接影响指令格式和指令功能。 $$寻址方式\\begin{cases}指令寻址\\数据寻址\\end{cases}$$ 指令寻址 顺序寻址 $(PC)+1→PC$ 跳跃寻址 由转移指令指出 指令的寻址方式示意图 数据寻址 一种一地址指令的格式 形式地址：指令字中的地址 有效地址：操作数的真实地址 约定：指令字长 = 存储字长 = 机器字长 立即寻址 形式地址A就是操作数 数据采用补码的形式存放。 指令执行阶段不访存 A的位数限制了立即数的范围 直接寻址 $EA=A$ 有效地址由形式地址直接给出 执行阶段访问一次存储器 A的位数决定了该指令操作数的寻址范围 操作数的地址不易修改（必须修改A） 隐含寻址 操作数地址隐含在操作码中 指令字中少了一个地址字段，可缩短指令字长 间接寻址 $EA=(A)$ 有效地址由形式地址间接提供 执行指令阶段 2次访寻 可扩大寻址范围 便于编制程序 寄存器寻址 $EA=R_i$ 有效地址即为寄存器编号 执行阶段不访存，只访问寄存器，执行速度快 寄存器个数有限，可缩短指令字长 寄存器间接寻址 $EA=(R_i)$ 有效地址在寄存器中 有效地址在寄存器中，操作数在存储器中，执行阶段访存1次 便于编写循环程序 基址寻址 (1) 采用专用寄存器作基址寄存器 $EA=(BR)+A$ BR为基址寄存器 可扩大寻址范围 有利于多道程序 BR内容由操作系统或管理程序确定 在程序的执行过程中BR内容不变，形式地址A可变 (2) 采用通用寄存器作基址寄存器 由用户指定哪个通用寄存器作为基址寄存器 基址寄存器的内容由操作系统确定 在程序的执行过程中$R_0$内容不变，形式地址A可变 变址寻址 $EA=(IX)+A$ IX为变址寄存器（专用） 通用寄存器也可以作为变址寄存器 可扩大寻址范围 IX的内容由用户给定 在程序的执行过程中IX内容可变，形式地址A不变 便于处理数组问题 相对寻址 $EA=(PC)+A$ A是相对于当前指令的位移量（可正可负，补码） A的位数决定操作数的寻址范围 程序浮动 广泛用于转移指令 堆栈寻址 (1) 堆栈的特点 $$堆栈\\begin{cases}硬堆栈\\ \\ 多个寄存器\\软堆栈\\ \\ 指定的存储空间\\end{cases}$$ 先进后出（一个入出口） 栈顶地址由SP指出 $进栈(SP)-1→SP$ $出栈(SP)+1→SP$ (2) 堆栈寻址举例 (3) SP的修改与主存编址方法有关 ① 按字编址 $进栈(SP)-1→SP$ $进栈(SP)+1→SP$ ② 按字节编址 存储字长16位： $进栈(SP)-2→SP$ $进栈(SP)+2→SP$ 存储字长32位： $进栈(SP)-4→SP$ $进栈(SP)+4→SP$","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://gxkord.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://gxkord.github.io/tags/计算机组成原理/"}]},{"title":"第6章 计算机的运算方法","slug":"计算机基础/计算机组成原理/第6章 计算机的运算方法","date":"2019-05-03T06:00:00.000Z","updated":"2019-06-27T10:59:05.381Z","comments":true,"path":"2019/05/03/计算机基础/计算机组成原理/第6章 计算机的运算方法/","link":"","permalink":"https://gxkord.github.io/2019/05/03/计算机基础/计算机组成原理/第6章 计算机的运算方法/","excerpt":"","text":"无符号数和有符号数无符号数寄存器的位数反映无符号数的表示范围。 有符号数机器数与真值 真值 机器数 带符号的数 符号数字化的数 +0.1011 0.1011 -0.1011 1.1011 +1100 0,1100 -1100 1,1100 原码表示法 定义 整数 $[x]_原=\\begin{cases}0,\\ x\\quad\\quad2^n&gt;x\\geq0\\2^n-x\\quad\\quad0\\geq x&gt;-2^n\\end{cases}$ x为真值，n为整数的位数。 使用逗号（,）将符号位与数值部分隔开。 如： $x=+1110\\quad[x]_原=0,1110$ $x=-1110\\quad[x]_原=2^4+1110=1,1110$ 小数 $[x]_原=\\begin{cases}x\\quad\\quad1&gt;x\\geq0\\1-x\\quad\\quad0\\geq x&gt;-1\\end{cases}$ x为真值。 使用小数点（.）将符号位与数值部分隔开。 如： $x=+0.1101\\quad[x]_原=0.1101$ $x=-0.1101\\quad[x]_原=1-(-0.1101)=1.1101$ $x=+0.1000000\\quad[x]_原=0.1000000$ 特别地： 当$x=0$时， $[+0.0000]_原=0.0000$ $[-0.0000]_原=1-(0.0000)=1.0000$ 可见，$[+0]_原\\neq[-0]_原$，即原码中的“零”有两种表示形式 当$x=-1$时， x不存在原码。（因为按照定义来看，-1和0地补码都为1） 特点 简单、直观。 但是用原码作加法时，会出现如下问题： 要求 数1 数2 实际操作 结果符号 加法 正 正 加 正 加法 正 负 减 可正可负 加法 负 正 减 可正可负 加法 负 负 加 负 能否只作加法？ 找到一个与负数等价的正数来代替这个负数，就可使减→加。（补码） 补码表示法 补的概念 一个负数加上“模”即得该负数的补数。 一个正数和一个负数互为补数时，它们的绝对值之和即为模数。 如计数器（模16），求$1011→0000$？ $1011-1011=0000$ $1011+0101=(1)0000$（1超过表示范围，舍去） 可见，-1011可用+0101代替。 记作：$-1011\\equiv+0101\\quad(mod\\ 2^4)$ 同理：$-011\\equiv+101\\quad(mod\\ 2^3)$ $-0.1001\\equiv+1.01111\\quad(mod\\ 2)$ 正数的补码即为其本身 两个互为补数的数，分别加上模，结果仍互为补数： 例如：$-1011\\equiv+0101\\quad(mod\\ 2^4)$ $-1011+10000=+0101$ $+0101+10000=+(1)0101$ 所以，$+0101\\equiv+0101\\quad(mod\\ 2^4)$ 可见，+0101既可作+0101的补码，又可做-1011的补码。 为了区分，需要为补码添加其原码的符号位： 0,0101→+0101 1,0101→-1011 如何得到？ 只需增加一位模，即 $2^{4+1}-1011=100000-1011=1,0101$ $2^{4+1}+0101=100000+0101=(1)0,0101$ 补码的定义 整数 $[x]_补=\\begin{cases}0,\\ x\\quad\\quad2^n&gt;x\\geq0\\2^{n+1}+x\\quad\\quad0&gt;x\\geq-2^n\\ (mod\\ 2^{n+1})\\end{cases}$ x为真值，n为整数的位数。 如： $x=+1010\\quad[x]_补=0,1010$ $x=-1011000\\quad[x]_补=2^{7+1}+(-1011000)$ 小数 $[x]_补=\\begin{cases}x\\quad\\quad1&gt;x\\geq 0\\2+x\\quad\\quad0&gt;x\\geq-1\\ (mod\\ 2)\\end{cases}$ 如： $x=+0.1110\\quad[x]_补=0.1110$ $x=-0.1100000\\quad[x]_补=2+(-0.1100000)=10.0000000-0.1100000=1.0100000$ 求补码的快捷方式 设$x=-1010$， 则$[x]_补=2^{4+1}-1010=100000-1010=1,0110$ $=11111+1-1010=10101+1=1,0110$ 又$[x]_原=1,1010$ 当真值为负时，补码可用原码除符号位外每位取反，末位加1求得。 举例 已知$[x]_补=0.0001$，求x 解：由定义得 $x=+0.0001$ 已知$[x]_补=1.0001$，求x 解：方法(1)：由定义得 $x=[x]_补-2=1.0001-10.0000=-0.1111$ 方法(2)：$[x]_原=1.1111,则x=-0.1111$ 已知$[x]_补=1,1110，求x$ 解：方法(1)：由定义得 $x=[x]_补-2^{4+1}=1,1110-100000=-0010$ 方法(2)：$[x]_原=1,0010，则x=-0010$ 当真值为负时，原码可用补码除符号位外每位取反，末位加1求得。 特别地： 当$x=0$时， $[+0.0000]_补=[-0.0000]_补=0.0000$ 当$x=-1$时， $[-1]_补=2+x=10.000-1.0000=1.0000$ （但无原码） 反码表示法 定义 整数 $[x]_反=\\begin{cases} 0,x\\quad 2^n&gt;x\\geq0\\\\ (2^{n+1}-1)+x\\quad 0\\geq x&gt;-2^n(mod2^{n+1}-1)\\end{cases}$ x为真值，n为整数的位数 如： $x=+1101\\quad [x]_反=0,1101$ $x=-1101\\quad [x]_反=(2^{4+1}-1)-1101=11111-1101=1,0010$ 小数 $[x]_反=\\begin{cases} x\\quad 1&gt;x\\geq 0 \\\\ (2-2^{-n})+x\\quad 0\\geq x&gt;-1(mod\\ 2-2^{-n})\\end{cases}$ 如： $x=+0.1101\\quad[x]_反=0.1101$ $x=-0.1010\\quad[x]_反=(2-2^{-4})-0.1010=1.1111-0.1010=1.0101$ 举例 已知$[x]_反=0,1110，求x$ 解：$x=+1110$ 已知$[x]_反=1,1110$，求x 解：$x=-0001$ 特别地： 当$x=0$时， 设$x=+0.0000$，则$[+0.0000]_反=0.0000$ 设$x=-0.0000$，则$[-0.0000]_反=1.1111$ 同理，对于整数：$[+0]_反=0,0000$，$[-0]_反=1,1111$ 因此，$[+0]_反\\neq[-0]_反$ 三种机器数的小结 最高位为符号位，书写上用“,”（整数）或“.”（小数）将数值部分和符号位隔开。 对于正数，原码=补码=反码。 对于负数，符号位为1，其数值部分 原码除符号位外每位取反末位加1 → 补码 原码除符号位外每位取反 → 反码 例题1：设机器字长为8位（其中1位为符号位），对于正数，当其分别代表无符号数、原码、补码和反码时，对应的真值范围各为多少？ 解： 二进制代码 无符号数的对应真值 原码 补码 反码 00000000 0 +0 $\\pm0$ +0 00000001 1 +1 +1 +1 00000010 2 +2 +2 +2 $\\ldots$ $\\ldots$ $\\ldots$ $\\ldots$ $\\ldots$ 01111111 127 +127 +127 +127 10000000 128 -0 -128 -127 10000001 129 -1 -127 -126 $\\ldots$ $\\ldots$ $\\ldots$ $\\ldots$ $\\ldots$ 11111101 253 -125 -3 -2 11111110 254 -126 -2 -1 11111111 255 -127 -1 -0 例题2：已知$[y]_补$，求$[-y]_补$。 解：设$[y]_补=y_0.y_1y_2\\ldots y_n$ 若y为正数，$[y]_补=0.y_1y_2\\ldots y_n$ 则$y=0.y_1y_2\\ldots y_n$ $-y=-0.y_1y_2\\ldots y_n$ 得$[-y]_补=1.\\overline{y_1}\\overline{y_2}\\ldots\\overline{y_n}+2^{-n}$ $[y]_补$连同符号位在内，每位取反，末位加1，即得$[-y]_补$。 若y为负数，$[y]_补=1.y_1y_2\\ldots y_n$ 则$[y]_原=1.\\overline{y_1}\\overline{y_2}\\ldots \\overline{y_n}+2^{-n}$ $y=-(0.\\overline{y_1}\\overline{y_2}\\ldots \\overline{y_n}+2^{-n})$ $-y=0.\\overline{y_1}\\overline{y_2}\\ldots \\overline{y_n}+2^{-n}$ $[-y]_补=0.\\overline{y_1}\\overline{y_2}\\ldots\\overline{y_n}+2^{-n}$ $[y]_补$连同符号位在内，每位取反，末位加1，即得$[-y]_补$。 移码表示法补码表示很难直接判断其真值大小。 如： 十进制 二进制 补码 +21 +10101 0,10101 -21 -10101 1,01011 +31 +11111 0,11111 -31 -11111 1,00001 上述补码表示中“,”在计算机内部是不存在的，因此，从代码形式看，符号位也是一位二进制数。按这6位二进制代码比较大小的话，会得出$101011&gt;010101$，$100001&gt;011111$，其实恰恰相反。 如果每个真值加上一个$2^n$（n为整数的位数），则有： $+10101+100000=110101$ $-10101+100000=001011$ $+11111+100000=111111$ $-11111+100000=000001$ 定义 $[x]_移=2^n+x(2^n&gt;x\\geq-2^n)$ x为真值，n为整数的位数 如： $x=10100$ $[x]_移=2^5+10100=1,10100$ $x=-10100$ $[x]_移=2^5-10100=0,01100$ 移码和补码的比较 设 $x=+1100100$ $[x]_移=2^7+1100100=1,1100100$ $[x]_补=0,1100100$ 设 $x=-1100100$ $[x]_移=2^7-1100100=0,0011100$ $[x]_补=1,0011100$ 补码和移码只差一个符号位。 真值、补码和移码的对照表 真值x(n=5) $[x]_补$ $[x]_移$ $[x]_移对应的十进制整数$ -100000 100000 000000 0 -11111 100001 000001 1 -11110 100010 000010 2 $\\ldots$ $\\ldots$ $\\ldots$ $\\ldots$ -00001 111111 011111 31 ±00000 000000 100000 32 +00001 000001 100001 33 +00010 000010 100010 34 $\\ldots$ $\\ldots$ $\\ldots$ $\\ldots$ +11110 011110 111110 62 +11111 011111 111111 63 移码的特点 当x=0时 $[+0]_移=2^5+0=1,00000$ $[-0]_移=2^5-0=1,00000$ $[+0]_移=[-0]_移$ 当n=5时 最小真值为$-2^5=-100000$ $[-100000]_移=2^5-100000=000000$ 可见，最小真值的移位为全0。 数的定点表示和浮点表示定点表示 小数定点机 整数定点机 定点机 原码 补码 反码 小数定点机 $-(1-2^{-n})$~$+(1-2^{-n})$ $-1$~$+(1-2^{-n})$ $-(1-2^{-n})$~$+(1-2^{-n})$ 整数定点机 $-(2^n-1)$~$+(2^n-1)$ $-2^n$~$+(2^n-1)$ $-(2^n-1)$~$+(2^n-1)$ 浮点表示 为什么在计算机中要引入浮点数表示？ 编程困难，程序员要调节小数点的位置。 数的表示范围小，为了能表示两个大小相差很大的数据，需要很长的机器字长。 数据存储单元的利用率往往很低。 浮点表示的格式是什么？ 浮点数的一般形式：$N=S×r^j$ S：尾数 j：阶码 r：尾数的基值（计算机中r取2、4、8、16等） 当$r=2$， $N=11.0101=0.110101×2^{10}=1.10101×2^1=1101.01×2^{-10}$ 计算机中，S为小数、可正可负，j为整数、可正可负。 尾数和阶码的基值必须是2吗？基值的影响？ 表数范围与精度和哪些因素有关？ 为什么要引入规格化表示？ 目前浮点数表示格式的标准是什么？ 浮点数的表示形式 浮点数的表示形式 浮点数的表示范围 上溢：阶码&gt;最大阶码 下溢：阶码&lt;最小阶码 按机器零处理 浮点数在数轴上的表示范围 浮点数的规格化形式基数不同，浮点数的规格化形式不同。 r=2 尾数最高位为1 r=4 尾数最高2位不全为0 r=8 尾数最高3位不全为0 浮点数的规格化 r=2 左规 尾数左移1位，阶码减1 右规 尾数右移1位，阶码加1 r=4 左规 尾数左移2位，阶码减1 右规 尾数右移2位，阶码加1 r=8 左规 尾数左移3位，阶码减1 右规 尾数右移3位，阶码加1 基数r越大，可表示的浮点数的范围越大。 基数r越大，浮点数的精度越低。 举例IEEE 754 标准定点运算移位运算移位运算的数学意义算术移位规则算术移位的硬件实现算术移位与逻辑移位的区别浮点四则运算算术逻辑单元","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://gxkord.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://gxkord.github.io/tags/计算机组成原理/"},{"name":"二进制运算","slug":"二进制运算","permalink":"https://gxkord.github.io/tags/二进制运算/"}]},{"title":"第5章 输入输出系统","slug":"计算机基础/计算机组成原理/第5章 输入输出系统","date":"2019-04-18T07:05:00.000Z","updated":"2019-04-27T13:34:38.489Z","comments":true,"path":"2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/","link":"","permalink":"https://gxkord.github.io/2019/04/18/计算机基础/计算机组成原理/第5章 输入输出系统/","excerpt":"","text":"概述输入输出系统的发展概况 早期 分散连接 CPU和I/0设备串行工作 程序查询方式 接口模块和DMA阶段 总线连接 CPU和I/O设备并行工作（中断方式、DMA方式） 具有通道结构的阶段 具有I/0处理机的阶段 输入输出系统的组成 I/0软件 (1) I/O指令 CPU指令的一部分 (2) 通道指令 通道自身的指令 指出数组的首地址、传送字数、操作命令 I/0硬件 设备 I/O接口 设备 设备控制器 通道 I/0设备与主机的联系方式 I/0设备编址方式 (1) 统一编址 可以直接用取数、存数指令对I/O设备进行访问 (2) 不统一编址 有专门的I/O指令 设备选址 用设备选择电路识别是否被选中 传送方式 (1) 串行 (2) 并行 联络方式 (1) 立即响应 (2) 异步工作采用应答信号 并行 串行 (3) 同步工作采用同步时标 I/0设备与主机的连接方式 (1) 辐射式连接 每台设备都配有一套控制线路和一组信号线 不便于增删设备 (2) 总线连接 便于增删设备 I/O设备与主机信息传送的控制方式 程序查询方式 CPU和I/O串行工作 踏步等待 程序中断方式 倘若CPU在启动I/O设备后，不查询设备是否已准备就绪，继续执行自身程序，只是当I/O设备准备就绪并向CPU发出中断请求后才予以响应。 没有踏步等待现象 中断现行程序 直接存储器存取方式（DMA） 主存和I/O之间有一条直接数据通道 不中断现行程序 周期挪用（周期窃用） CPU和I/O并行工作 I/0通道方式 I/O处理机方式 4、5两种方式详解可以参照《计算机系统结构》的教材。 前三种方式的CPU工作效率比较 I/0设备（了解）概述 I/O设备结构框图 I/0设备大致分为三类： 人机交互设备 键盘、鼠标、的研究、显示器 计算机信息存储设备 磁盘、光盘、磁带 机-机通信设备 调制解调器等 输入设备 键盘 按键 判断哪个键按下 将此键翻译成ASCII码（编码键盘法） 鼠标 机械式：金属球、电位器 光电式：光电转换器 触摸屏 输出设备 显示器 (1) 字符显示：字符发生器 (2) 图形显示：主观图像 (3) 图像显示：客观图像 打印机 (1) 击打式：点阵式（逐字、逐行） (2) 非打击式：激光（逐页）、喷墨（逐页） 其他 A/D、D/A 模拟/数字（数字/模拟）转换器。 终端 由键盘和显示器组成。 完成显示控制与存储、键盘管理及通信控制。 汉字处理 汉字输入、汉字存储、汉字输出。 多媒体技术 什么是多媒体？ 多媒体计算机的关键技术？ I/0接口概述为什么设置接口？ 实现设备的选择 实现数据缓冲达到速度匹配 实现数据串-并格式转换 实现电平转换 传送控制命令 反应设备的状态（“忙”、“就绪”、“错误”、“中断请求”） 接口的功能和组成 总线连接方式的I/O接口电路 (1) 设备选择线 (2) 数据线 (3) 命令线 (4) 状态线 接口的功能和组成 功能 组成 选址功能 设备选择电路 传送命令的功能 命令寄存器、命令译码器 传送数据的功能 数据缓冲寄存器 反映设备状态的功能 设备状态标记 $$\\begin{cases}完成触发器D\\工作触发器B\\中断请求触发器INTR\\屏蔽触发器MASK\\end{cases}.$$ I/O接口的基本组成 接口类型 按数据传送方式分类 并行接口（Intel 8255） 串行接口（Intel 8251） 按功能选择的灵活性分类 可编程接口（Intel 8255、Intel 8251） 不可编程接口（Intel 8212） 按通用性分类 通用接口（Intel 8255、Intel 8251） 专用接口（Intel 8279、Intel 8275） 按数据传送的控制方式分类 程序型接口 DMA型接口 程序查询方式程序查询方式的流程 查询流程 程序流程 程序查询方式的接口电路 输入 ① 当CPU通过I/O指令启动输入设备时，指令的设备码字段通过地址线送至设备选择电路。 ② 若该接口的设备码与地址线上的代码吻合，其输出SEL有效。 ③ I/O指令的启动命令经过“与非”门将工作触发器B置为1，将完成触发器D置为0。 ④ 由B触发器启动设备工作。 ⑤ 输入设备将数据送至数据缓冲寄存器（DBR）中。 ⑥ 由设备发设备工作结束信号，将D置“1”，B置“0”，表示外设准备就绪。 ⑦ D触发器以“准备就绪”状态通知CPU，表示“数据缓冲满”。 ⑧ CPU执行输入指令，将DBR中的数据送至CPU的通用寄存器，再存入主存相关单元。 输出 ① 当CPU通过I/O指令启动输出设备时，指令的设备码字段通过地址线送至设备选择电路。 ② 若该接口的设备码与地址线上的代码吻合，其输出SEL有效。 ③ I/O指令的启动命令经过“与非”门将工作触发器B置为1，将完成触发器D置为0。 ④ CPU通过输出指令将数据送至数据缓冲 寄存器（DBR）中。 ⑤ 由B触发器启动设备工作，将数据从DBR中取走。 ⑥ 由设备发设备工作结束信号，将D置“1”，B置“0”，表示外设输出完成。 ⑦ D触发器以“准备就绪”状态通知CPU，表示“数据缓冲空”。 ⑧ CPU可再次向DBR输出数据，进行第二次传送。 程序中断方式中断的概念计算机在执行程序的过程中，当出现异常情况或特殊情况时，计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回现行程序的间断处，继续执行原程序，这就是“中断”。 程序中断方式 计算机系统引入中断技术的原因： 为了提高计算机的整机效率。 为了应对突发事件。 例如，当计算机运行过程中，若出现突然掉电这种异常情况，将会导致CPU中的全部信息丢失。倘若在突然掉电的瞬间立即启动另一个备份电源，并迅速进行一些必要的处理，例如，将有用的信息送至不受电源影响的存储系统内，待电源恢复后接着使用，这种处理技术也要用中断技术来实现。 为了实时控制的需要。 在实时控制领域中，要求CPU能即时响应外来信号的请求，并能完成相应的操作，也都要求采用中断技术。 中断的产生以打印机为例 CPU与打印机部分并行工作 CPU与打印机并行工作的时间示意图 程序中断方式的接口电路 配置中断请求触发器和中断屏蔽触发器 INTR：中断请求触发器（INTR=1表示有请求） MASK：中断屏蔽触发器（MASK=1表示被屏蔽） D：完成触发器 &amp;：与非门，其运算为$\\overline{A\\cdot B}$。 1：非门，其运算为$\\overline{A}$，相当于$\\overline{A\\cdot 1}$。 &amp;和1：效果相当于与门，但由于电路的原因，只能使用与非门。 排队器 $$排队\\begin{cases} 硬件\\ \\ 在CPU内或在接口电路中（链式排队器） \\ 软件\\ \\ 详见第八章\\end{cases}$$ 设备1、2、3、4的优先级按降序排列 $INTR_i=1$有请求，即$\\overline{INTR_i}=0$ 第一个反相器左侧接地（恒为0），经过反向器，信号变为1， 若${INTR_1}$有请求，即$INTR_1=1$，经过上方的与非门和非门，选中1号设备； 若${INTR_1}$无请求，即$\\overline{INTR_1}=1$，经过与非门，将1信号传到下一个排队器。 依此类推… 中断向量地址形成部件 $$入口地址\\begin{cases} 由软件产生\\ \\ 详见第八章 \\ 硬件向量法\\ \\ 由硬件产生向量地址，再由向量地址找到入口地址\\end{cases}$$ 中断向量地址形成部件框图 通过向量地址寻找入口地址 程序中断方式接口电路的基本组成 I/O中断处理过程 CPU响应中断的条件和时间 条件 允许中断触发器EINT=1 用开中断指令将EINT置“1” 用关中断指令将EINT置“0”或硬件自动复位 时间 当D = 1（随机）且MASK = 0时 在每条指令执行阶段的结束前 CPU发中断查询信号（将INTR置“1”） I/O中断处理过程 ① 由CPU发启动I/O设备的命令，将I/O接口中的B置“1”，D触发器置”0“。 ② 接口启动输入设备开始工作。 ③ 输入设备将数据送入数据缓冲寄存器。 ④ 输入设备向接口发出”设备工作结束“信号，将D置”1“，B置”0“，标志设备准备就绪。 ⑤ 当设备准备就绪（D=1），且本设备未被屏蔽（MASK=0）时，在指令执行阶段的结束时刻，由CPU发出中断查询信号。 ⑥ 设备中断请求触发器INTR被置”1“，标志设备向CPU提出中断请求。与此同时，INTR送至排队器，进行中断判优。 ⑦ 若CPU允许中断（EINT=1），设备又被排队选中，即进入中断响应阶段，由中断响应信号INTA将排队器输出送至编码器形成向量地址。 ⑧ 向量地址送至PC，作为下一条指令的地址。 ⑨ 由于向量地址中存放的是一条无条件转移指令，故这条指令执行结束后，即无条件转至该设备的服务程序入口地址，开始执行中断服务程序，进入中断服务阶段，通过输入指令将数据缓冲寄存器的输入数据送至CPU的通用寄存器，再存入主存相关单元。 ⑩ 中断服务程序的最后一条指令是中断返回指令，当其执行结束时，中断返回至原程序的断点处。至此，一个完整的程序中断处理过程即告结束。 综上所述，可将异常中断处理过程简单归纳为中断请求、中断判优、中断响应、中断服务和中断返回5个阶段。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://gxkord.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://gxkord.github.io/tags/计算机组成原理/"}]},{"title":"1. Spring入门","slug":"Java/Spring/1. Spring入门","date":"2019-03-27T05:05:00.000Z","updated":"2019-04-29T06:12:05.759Z","comments":true,"path":"2019/03/27/Java/Spring/1. Spring入门/","link":"","permalink":"https://gxkord.github.io/2019/03/27/Java/Spring/1. Spring入门/","excerpt":"","text":"概述Spring是什么Spring是分层的java SE/EE 应用一站式的轻量级开源框架，以 IoC（Inverse of Control，控制反转）和 AOP（Aspect Oriented Programming，切面编程）为内核，提供了展示层Spring MVC、持久层Spring JDBC及业务层事务管理等一站式的企业级应用技术。 Spring之父Rod Johnson 一个技术和商业上的天才。Spring的缔造者。 2004年3月24日发布了Spring1.0正式版并成立了SpringSource公司。 Spring优点 方便解耦，简化开发。 通过Spring的IoC容器，用户可以将对象之间的依赖关系交由Spring进行控制，避免硬解码所造成的过度程序耦合。 AOP编程的支持。 通过Spring提供的AOP功能，方便进行面向切面的编程。 声明式事务的支持。 通过声明的方式灵活地管理事务。 方便进行程序测试。 可以用非容器依赖的编程方式进行几乎所有的测试工作。 方便集成各种优秀的框架。 Spring对其他框架不排斥。更可以降低各种框架的使用难度。它提供了对各种优秀框架的直接支持。（如：Struts、Hibernate、Hessian、Quartz等） 降低了Java EE API的使用难度。 Spring对很多难用的Java EE API（如JDBC、JavaMail、远程调用等）提供了薄层封装，大大降低了这些API的使用难度。 Spring源码是经典的学习范例。 对Spring源码的学习无疑是Java技术的最佳实践范例。 Spring体系结构Spring核心框架由4000多个类组成，整个框架按其所属功能可以划分为5个模块，如下图所示。 Spring框架结构 HelloWorld 创建一个JavaBean 123456789101112131415public class HelloWorld &#123; private String name; public HelloWorld() &#123; System.out.println(\"调用了无参构造器...\"); &#125; public void setName(String name) &#123; this.name = name; &#125; public void hello() &#123; System.out.println(\"hello:\" + name); &#125;&#125; 在Spring配置文件中注册bean 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.1.xsd\"&gt; &lt;!-- 配置Bean --&gt; &lt;bean id=\"helloWorld\" class=\"cn.gxk.spring.beans.HelloWorld\"&gt; &lt;property name=\"name\" value=\"Spring\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 获取对象 123456789101112/* 传统方法创建对象 */HelloWorld helloWorld1 = new HelloWorld();helloWorld1.setName(\"simple\");helloWorld1.hello();/* Spring方法 */// 1.创建Spring的IoC容器ApplicationContext ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\");// 2.获得xml里的对象（xml解析，反射创建对象）HelloWorld helloWorld2 = (HelloWorld) ctx.getBean(\"helloWorld\");// 3.调用对象的方法helloWorld2.hello(); IoC容器Bean的配置1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans ...&gt; &lt;!-- 配置Bean： class：bean的全类名，通过反射的方法在IoC容器中创建对象，所以javabean中必须有无参构造器。 id：bean的唯一标识。 --&gt; &lt;bean id=&quot;helloWorld&quot; class=&quot;cn.gxk.spring.beans.HelloWorld&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; IoC容器的实现 BeanFactory：IoC容器的基本实现。（一般不用） ApplicationContext：提供了更多高级的特性，是BeanFactory的子类。 ConfigurableApplicationContext：扩展refresh()和close()，让ApplicationContext具有启动、刷新和关闭上下文的能力。 ClassPathXmlApplicationContext：从类路径下加载配置文件。 FileSystemXmlApplicationContext：从文件系统中加载配置文件。 常用方法： getBean(String) 通过xml中配置的id来创建唯一对象。 getBean(类名.class) 利用类型返回bean，但要求IoC中只有一个该类型的bean。 bean注入方法 属性注入（setter方法） 1&lt;property name=&quot;name&quot; value=&quot;Spring&quot;&gt;&lt;/property&gt; 构造器注入 12345678&lt;constructor-arg value=&quot;v1&quot; index=&quot;0&quot; type=&quot;java.lang.String&quot;&gt;&lt;/constructor-arg&gt;&lt;constructor-arg index=&quot;1&quot; type=&quot;int&quot;&gt; &lt;value&gt;100&lt;/value&gt;&lt;/constructor-arg&gt;&lt;!-- index、type可以不写。 type用来区分重载的构造器。--&gt; 工厂方法注入（很少使用，不推荐） 特殊的赋值 特殊字符（使用&lt;!CDATA[]]&gt;包裹） 123&lt;property name=&quot;address&quot;&gt; &lt;value&gt;&lt;!CDATA[&lt;hello&gt;]&gt;&lt;/value&gt;&lt;/property&gt; null 123&lt;constructor-arg type=&quot;java.lang.String&quot;&gt; &lt;null/&gt;&lt;/constructor-arg&gt; 内部bean或外部bean 内部bean，不能被外部引用 123&lt;property name=&quot;person&quot;&gt; &lt;bean id=&quot;person1&quot; class=&quot;包名.Person&quot;&gt;&lt;/bean&gt;&lt;/property&gt; 外部bean，用ref引用 12&lt;bean id=&quot;person2&quot; class=&quot;包名.Person&quot;&gt;&lt;/bean&gt;&lt;property name=&quot;person&quot; ref=&quot;person2&quot;&gt;&lt;/property&gt; 集合 java.util.List - &lt;list&gt; java.util.Set - &lt;set&gt; 内部集合 123456&lt;constructor-arg&gt; &lt;list&gt; &lt;ref bean=&quot;person1&quot;/&gt; &lt;ref bean=&quot;person2&quot;/&gt; &lt;/list&gt;&lt;/constructor-arg&gt; 外部集合 需要在spring配置文件中引入util命名空间。 1234&lt;util:list id=&quot;persons&quot;&gt; &lt;ref bean=&quot;person1&quot;/&gt; &lt;ref bean=&quot;person2&quot;/&gt;&lt;/util:list&gt; Map java.util.Map - &lt;map&gt; java.util.Properties - &lt;prop&gt; 内部Map 123456&lt;constructor-arg type=&quot;java.util.Map&quot;&gt; &lt;map&gt; &lt;entry key=&quot;aa&quot; value-ref=&quot;person1&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;bb&quot; value-ref=&quot;person2&quot;&gt;&lt;/entry&gt; &lt;/map&gt;&lt;/constructor-arg&gt; 外部Map 需要在spring配置文件中引入util命名空间。 1234&lt;util:map id=&quot;persons&quot;&gt; &lt;entry key=&quot;aa&quot; value-ref=&quot;person1&quot;&gt;&lt;/entry&gt; &lt;entry key=&quot;bb&quot; value-ref=&quot;person2&quot;&gt;&lt;/entry&gt;&lt;/util:map&gt; 使用p命名空间赋值 在spring配置文件中引入p命名空间 1&lt;bean id=&quot;person3&quot; class=&quot;包名.person&quot; p:name=&quot;zhangsan&quot; p:age=&quot;30&quot; p:cars-ref=&quot;cars&quot;&gt;&lt;/bean&gt; 自动装配（了解，一般不用） byName 12345&lt;bean id=&quot;car&quot; class=&quot;包名.Car&quot; ...&gt;&lt;/bean&gt;&lt;bean id=&quot;person4&quot; class=&quot;包名.Person&quot; p:name=&quot;zhangsan&quot; autowire=&quot;byName&quot;&gt;&lt;/bean&gt;&lt;!-- 若person有car属性，设置autowire=&quot;byName&quot;，IoC容器会自动寻找叫&quot;car&quot;的bean，自动装配。--&gt; byType 12345&lt;bean id=&quot;car1&quot; class=&quot;包名.car&quot; ...&gt;&lt;/bean&gt;&lt;bean id=&quot;person4&quot; class=&quot;包名.person&quot; p:name=&quot;zhangsan&quot; autowire=&quot;byType&quot;&gt;&lt;!-- 若person有car属性，设置autowire=&quot;byType&quot;，会寻找类car的bean，自动装配（若car有多个bean，会抛异常）--&gt; bean之间的关系 继承 123&lt;bean id=&quot;address&quot; p:city=&quot;BeiJing&quot; abstract=&quot;true&quot; /&gt;&lt;bean id=&quot;address2&quot; class=&quot;包名.Address&quot; p:street=&quot;DaZhongShi&quot; parent=&quot;address1&quot;/&gt; 先给给出的属性赋值，未给出的属性继承父bean。 设置了abstract=”true”的bean为抽象bean，不能将它实例化，只用于继承。（该抽象bean可以不指定class） 依赖 1&lt;bean id=&quot;person1&quot; p:age=&quot;23&quot; depends-on=&quot;name&quot;/&gt; depends-on=”name”指定了依赖属性，而name未赋值，会抛异常。 bean的作用域123456&lt;bean id=&quot;car&quot; class=&quot;包名.car&quot; scope=&quot;?&quot;&gt;&lt;!-- singleton：默认值，单例的，容器初始化时创建bean对象，在整个容器的生命周期中只有这一个对象。 prototype：原型的，每次getBean都会创建一个对象。--&gt; 外部属性文件（可用于配置数据库连接等） 新建属性文件person.properties 12pname=zhangsanpage=20 引入属性文件 Spring2.0 1234&lt;bean class=&quot;包名.person&quot;&gt;&lt;property name=&quot;location&quot; value=&quot;classpath:person.properties&quot;&gt;&lt;/property&gt;&lt;/bean&gt; Spring2.5以后 需要在spring配置文件中引入context工作空间 1&lt;context:property-paceholder location=&quot;classpath:person.properties&quot;/&gt; 创建bean 1234&lt;bean id=&quot;person&quot; class=&quot;包名.person&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;$&#123;pname&#125;&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;$&#123;page&#125;&quot;&gt;&lt;/property&gt;&lt;/bean&gt; Spring表达式语言(Spring EL) 一个支持运行时查询和操作对象图的表达式语言。 使用#{…}作为定界符。 为动态赋值提供了便利。 用法： 字面值 1&lt;property name=&quot;name&quot; value=&quot;#&#123;&apos;ZhangSan&apos;&#125;&quot;/&gt; 引用bean、属性和方法 引用其他bean对象（等同ref属性） 1&lt;property name=&quot;car&quot; value=&quot;#&#123;car1&#125;&quot;/&gt; 引用其他对象的属性 1&lt;property name=&quot;car_price&quot; value=&quot;#&#123;car1.price&#125;&quot;/&gt; 调用其他方法，还可以链式操作 1&lt;property name=&quot;person&quot; value=&quot;#&#123;person1.toString().toUpperCase()&#125;&quot;/&gt; 静态方法或属性，通过T()调用 1&lt;property name=&quot;initValue&quot; value=&quot;#&#123;T(java.lang.Math).PI&#125;&quot;/&gt; 运算符 算数运算符：+, -, *, /, &amp;, ^ 加号进行字符串连接 比较运算符：&lt;, &gt;, ==, &lt;=, &gt;=, lt, gt, eq, le, ge 逻辑运算符：and, or, not, | if-else运算： a&gt;b ?: (result1), a&lt;=b ?: (result2) a&gt;b ? ‘reslut1’ : ‘result2‘ 正则表达式 管理bean的生命周期 Spring IoC容器可以管理Bean的生命周期，并允许在Bean生命周期的特殊点执行相关方法。 Spring IoC容器对Bean的生命周期进行管理的过程： 通过构造器或工厂方法创建Bean实例 为Bean的属性设值和对其他Bean的引用 调用Bean的初始化方法 使用Bean 容器关闭时，调用bean的销毁方法 在Bean的声明里设置 init-method 和 destory-method 属性，为bean指定初始化和销毁方法。 Bean的后置处理器 创建MyBeanPostProcessor类实现BeanPostProcessor接口 12345678910public class MyBeanPostProcessor implements BeanPostProcessor &#123; //两方法的返回值是用户拿到的bean（可以在这两个方法里对创建的bean进行处理） //bean初始化（init-method）前调用 public Object PostProcessBeforeInitialization(Object bean, String beanName) &#123;...&#125; //bean初始化（init-method）后调用 public Object PostProcessAfterInitialization(Object bean, String beanName) &#123;...&#125;&#125; 在xml里配置 1&lt;bean class=&quot;包名.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt; 使用工厂方法创建bean 使用静态工厂方法 创建工厂类 123456789101112131415public class StaticCarFactory&#123; private static map&lt;String,Car&gt; cars = nw HashMap&lt;String,Car&gt;(); static &#123; cars.put(\"audi\", new Car(\"audi\")); cars.put(\"ford\", new Car(\"ford\")); &#125; public static Car getCar(String name)&#123; return cars.get(name); &#125;&#125; 在applictionContext.xml里配置bean 123&lt;bean id=&quot;car1&quot; class=&quot;包名.StaticCarFactory&quot; factory-method=&quot;getCar&quot;&gt; &lt;constructor-arg value=&quot;audi&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 使用实例工厂方法 创建工厂类 123456789101112131415public class InstanceCarFactory&#123; private Map&lt;String,Car&gt; cars = null; public InstanceCarFactory() &#123; cars = new HashMap&lt;String,Car&gt;(); cars.put(\"audi\", new Car(\"audi\")); cars.put(\"ford\", new Car(\"ford\")); &#125; public Car getCar(String name)&#123; return cars.get(name); &#125;&#125; 在applictionContext.xml里配置bean 1234&lt;bean id=&quot;carFactory&quot; class=&quot;包名.InstanceCarFactory&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;car2&quot; factory-bean=&quot;carFactory&quot; factory-method=&quot;getCar&quot;&gt; &lt;constructor-arg value=&quot;ford&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 使用FactoryBean配置bean 创建CarFactoryBean实现FactoryBean接口 123456789101112131415161718192021222324public class CarFactoryBean implements FactoryBean&lt;Car&gt;&#123; private String name; public void setName(String name)&#123; this.name = name; &#125; @Override public Car getObject() throws Exception &#123; return new Car(name); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; @Override public boolean isSingleton() &#123; return true; &#125;&#125; 在applictionContext.xml里配置bean 123&lt;bean id=&quot;car1&quot; class=&quot;包名.CarFactoryBean&quot;&gt; &lt;property name=&quot;name&quot; value=&quot;BMW&quot;&gt;&lt;/bean&gt; 基于注解方式配置Bean 组件扫描(component scanning) Spring能从classpath下自动扫描，侦测和实例化具有特定注解的组件。 特定组件包括：（这些注解只是用来给编程人员看的，Spring只识别有没有这些注解而不区别） @Component：基本注解，标识了一个受Spring管理的组件 @Respository：标识持久层组件 @Service：标识服务层（业务层）组件 @Controller：标识表现层组件 在applictionContext.xml里配置bean 在spring配置文件中引入context命名空间。 用法： 1234&lt;context:component-scan base-package=&quot;包名&quot; resource-pattern=&quot;a/*.class&quot;&gt;&lt;/context:component-scan&gt; 属性： base-package：指定包名，IoC容器扫描该包和子包下的所有类。 resource-pattern：限制扫描范围。 子标签： &lt;context:include-filter&gt;：包括指定的类 若实现”只包含指定类”，需要在&lt;context:component-scan&gt;中添加属性use-default-filters=”false” 属性： type：用来指定过滤类型。 annotation(过滤指定类) assinable(过滤继承或实现了指定类的子类) &lt;context:exclude-filter&gt;：不包括指定的类。 bean创建过程： IoC容器会扫描指定的包和其子类(经过过滤)，对添加了注解的类进行实例化，id为非限定类名（第一个字母小写）。 特殊： 若某被扫描的bean1里有其他bean2，可以在bean2前加 @Autowired 标记，该bean2也会被自动注入。（setter方法也可） 若bean2没有被注解，会抛异常。 解决方法：可以设置 @Autowired(required=false)，容器会对它赋值null。 若有两个bean2，也会抛异常。 如：UserService是抽象的接口，而项目中有两个实现类userService1和userService2，且都有注解。 解决方法： (1) 在组件中添加名字。（如： @Service(userService1) ） (2) 在bean2前添加 @Qualifier 注解。（如： @Qualifier(“userService2”) ） Spring4新特性——泛型限定式依赖注入 Spring4.0以前，对于父类里setter方法，必须在子类再写一个setter方法，然后指定注入的具体类型，然后进行注入。 123456789101112131415161718192021222324252627282930313233public abstract class BaseService&lt;M extends Serializable&gt; &#123; private BaseRepository&lt;M&gt; repository; public void setRepository(BaseRepository&lt;M&gt; repository) &#123; this.repository = repository; &#125; public void save(M m) &#123; repository.save(m); &#125;&#125;@Servicepublic class UserService extends BaseService&lt;User&gt; &#123; @Autowired public void setUserRepository(UserRepository userRepository) &#123; setRepository(userRepository); &#125;&#125;@Servicepublic class OrganizationService extends BaseService&lt;Organization&gt; &#123; @Autowired public void setOrganizationRepository(OrganizationRepository organizationRepository) &#123; setRepository(organizationRepository); &#125;&#125; Spring4.0实现了泛型依赖 12345678910111213141516public abstract class BaseService&lt;M extends Serializable&gt; &#123; @Autowired protected BaseRepository&lt;M&gt; repository; public void save(M m) &#123; repository.save(m); &#125;&#125;@Servicepublic class UserService extends BaseService&lt;User&gt; &#123;&#125;@Servicepublic class OrganizationService extends BaseService&lt;Organization&gt; &#123;&#125; AOP引入AOP 如何实现一个计算器？（OOP） 12345678910111213141516171819202122232425// 接口类public interface ArithmeticCalculator &#123; int add(int i, int j); int sub(int i, int j);&#125;// 实现接口类public class ArithmeticCalculatorImpl implents ArithmeticCalculator &#123; @Override public int add(int i, int j) &#123; int result = i + j; return result; &#125; @Override public int sub(int i, int j) &#123; int result = i - j; return result; &#125;&#125; 如何在使用计算器过程中打印日志？ 1234567@Overridepublic int add(int i, int j) &#123; System.out.println(\"The method add begins with[\" + i + \",\" + j + \"]\"); int result = i + j; System.out.println(\"The method add ends with \" + result); return result;&#125; 上述代码存在的问题： 代码混乱：越来越多的非业务需求加入后，原来的业务方法急剧膨胀，每个方法在处理核心逻辑的同时还必须兼顾其他多个关注点。 代码分散：每个模块都必须做相似的动作，而如果需求改变，每个模块都必须修改。 如何解决？ 使用动态代理（InvocationHandler）—— 使用反射(reflect)对目标对象的每个方法进行模块化操作。 代理类 1234567891011121314151617181920212223242526272829303132333435363738public class ArithmeticCalculatorLoggingProxy &#123; // 要代理的对象 private ArithmeticCalculator target; public ArithmeticCalculatorLoggingProxy(ArithmeticCalculator target) &#123; this.target = target; &#125; public ArithmeticCalculator getLoggingProxy() &#123; ArithmeticCalculator proxy = null; // 代理对象由哪个类加载器负责加载 ClassLoader loader = target.getClass().getClassLoader(); // 代理对象的类型，即其中有那些方法 Class[] interfaces = new Class[]&#123;ArithmeticCalculator.class&#125;; // 当调用代理对象其中方法时，执行的代码 InvocationHandler h = new InvocationHandler() &#123; /** * proxy：正在返回的代理对象，一般情况下，在invoke方法中都不使用该对象 * —— 如果你想使用这个对象，并调用它的方法，又会调用invoke()方法，直至发生死循环。 * method：正在调用的方法 * args：调用方法时传入的参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); //日志 System.out.println(\"The method \" + methodName + \" begins with [\" + args[0] + \",\" + args[1] + \"]\"); //执行方法 Object result = method.invoke(target, args); //日志 System.out.println(\"The method \" + methodName + \" ends with \" + result); return result; &#125; &#125; proxy = Proxy.newProxyInstance(loader, interfaces, h); &#125;&#125; 使用代理类创建对象 1234567public static void main(String[] args) &#123; ArithmeticCalculator target = new ArithmeticCalculatorImp(); ArithmeticCalculator proxy = new ArithmeticCalculatorLoggingProxy(target).getLoggingProxy(); int result = proxy.add(1, 2); System.out.println(\"--&gt;\" + result); &#125; 问题 这种方法太麻烦，Spring把它封装起来，称为AOP。 什么是AOP AOP (Aspect-Oriented Programming，面向切面编程)：是对传统OOP(Object-Oriented Programming，面向对象编程)的补充。 AOP的主要编程对象是切面(aspect)，而切面模块化横切关注点。 在AOP仍需定义公共功能，但不必修改受影响的类，这样横切的关注点就被模块化到特殊的对象(切面)里。 使用AOP的好处： 每个事物逻辑位于一个位置，代码不分散，便于维护和升级。 业务模块更简洁，只包含核心业务代码。 在上述的例子（计算器）中： 对于每个业务逻辑(add/sub/mul/div)，在实现这些逻辑之后用一个另外的类，对特定的多个逻辑进行额外操作（验证参数、前置/后置日志），这个过程，称为面向切面编程（AOP）。 相关概念 切面(aspect)：横切关注点（跨越应用程序多个模块的功能）被模块化的特殊对象。 通知(advice)：切面必须完成的工作。 目标(target)：被通知的对象。 代理(proxy)：向目标对象应用通知之后创建的对象。 连接点(joinpoint)：程序执行的某个特定位置（如：类某个方法调用前、调用后、方法抛出异常后等）。 切点(pointcut)：连接点是客观存在的事物。通过切点可以定位到特定的一个或多个连接点。 Spring AOP在Spring2.0以上版本中，可以使用 基于AspectJ(一种AOP框架)注解 或 基于XML 来配置AOP。 基于AspectJ注解 需要的jar包：aopalliance.jar、aspectj.weaver.jar 和 spring-aspects.jar 配置文件中导入aop命名空间。 使用AspectJ让aop自动动态代理。 1&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 配置自动扫描的包 1&lt;context:component-scan base-package=&quot;cn.gxk.spring.aop.impl&quot;&gt;&lt;/context:component-scan&gt;切面类 切面类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//把该类声明为一个切面：需要把该类放入IoC容器，再声明为切面@Aspect@Componentpublic class LoggingAspect &#123; /** * 前置通知：目标方法之前执行 */ @Before(\"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))\") public void beforeMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); List&lt;Object&gt; args = Arrays.asList(joinPoint.getArgs()); System.out.println(\"The method \" + methodName + \" begins with\"+args); &#125; /** * 后置通知：目标方法之前执行(无论是否发生异常都执行) * 拿不到返回结果 */ @After(\"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))\") public void afterMethod(JoinPoint joinPoint)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(\"The method \" + methodName + \" ends\"); &#125; /** * 返回通知：方法正常执行后返回结果 */ @AfterReturning(value=\"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))\", returning=\"result\") public void afterReturning(JoinPoint joinPoint, Object result)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(\"The method \" + methodName + \" return \" + result); &#125; /** * 异常通知：在目标方法发生异常时执行 * 可以访问到异常对象，甚至过滤指定异常 */ @AfterThrowing(value=\"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))\", throwing=\"ex\") public void afterThrowing(JoinPoint joinPoint, NullPointerException ex)&#123; String methodName = joinPoint.getSignature().getName(); System.out.println(\"The method \" + methodName + \" occurs exception:\" + ex.getStackTrace()); &#125; /** * 环绕通知：需要携带ProceedingJoinPoint类型的参数 * ProceedingJoinPoint参数可以决定是否执行目标方法 * 且环绕通知必须有返回值，返回值为目标方法的返回值 * @return */ @Around(\"execution(public int cn.gxk.spring.aop.impl.ArithmeticCalculatorImpl.*(int, int))\") public Object aroundMethod(ProceedingJoinPoint pjd)&#123; Object result = null; String methodName = pjd.getSignature().getName(); //执行目标方法 try &#123; //前置通知 System.out.println(\"[环绕]The method \" + methodName + \" begins with \" + Arrays.asList(pjd.getArgs())); result = pjd.proceed(); //返回通知 System.out.println(\"[环绕]The method \" + methodName + \"ends with \" + result); &#125;catch (Throwable e) &#123; //异常通知 System.out.println(\"[环绕]The method \" + methodName + \" occurs exception:\" + e.getStackTrace()); &#125; //后置通知 System.out.println(\"[环绕]The method \" + methodName + \"ends\"); return result; &#125;&#125; 通知的种类： @Before：前置通知 @After：后置通知(无论是否发生异常)，拿不到返回结果 @AfterRunning：返回通知，在方法返回结果后执行 @AfterThrowing：异常通知，在方法抛出异常后执行 @Around：环绕通知，围绕着方法执行，上述通知能做到的它都能做到。 注：可以使用通配符（*）来替代方法标志的任意部分（前缀、返回指、方法名等），方法参数则可以用(..)代替。 注意：动态代理需要使用接口，所以自动动态代理后的bean会自动转化为接口的类型使用 ctx.getBean(接口.class); 得到bean。 另：若有多个切面 ，可以 @Order(1) 用来指定切面的优先级，值越小优先级越高！ 重用切面表达式123456// 定义一个方法，用于声明切入点表达式，一般地，该方法不需要添加其他代码@Pointcut(\"execution(...)\")public void declareJointPointExpression()&#123;&#125;// 在通知注解中调用（不同包的不同类下需要声明包名和类名）@Before(\"包名.类名.declareJointPointExpression()\"); 基于XML文件 切面(Aspect)类写法与上述一致，不需要使用注释 xml里配置（返回或异常通知的returning和throwing属性需要与切面类的参数名相同） 12345678910111213141516171819202122232425262728293031&lt;!--bean--&gt;&lt;bean id=&quot;arithmeticCalculator&quot; class=&quot;cn.gxk.spring.aop.xml.ArithmeticCalculatorImpl&quot;&gt;&lt;/bean&gt;&lt;!--切面的bean--&gt;&lt;bean id=&quot;loggingAspect&quot; class=&quot;cn.gxk.spring.aop.xml.LoggingAspect&quot;&gt;&lt;/bean&gt;&lt;aop:config&gt; &lt;!--配置切点表达式--&gt; &lt;aop:pointcut expression=&quot;execution(* cn.gxk.spring.aop.xml.ArithmeticCalculator.*(int, int))&quot; id=&quot;pointcut&quot;/&gt; &lt;!--配置切面及通知--&gt; &lt;aop:aspect ref=&quot;loggingAspect&quot; order=&quot;1&quot;&gt; &lt;aop:before method=&quot;beforeMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:aspect&gt; &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt; &lt;aop:after method=&quot;afterMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:aspect&gt; &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt; &lt;aop:after-returning method=&quot;afterReturning&quot; pointcut-ref=&quot;pointcut&quot; returning=&quot;result&quot;/&gt; &lt;/aop:aspect&gt; &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt; &lt;aop:after-throwing method=&quot;afterThrowing&quot; pointcut-ref=&quot;pointcut&quot; throwing=&quot;ex&quot;/&gt; &lt;/aop:aspect&gt; &lt;aop:aspect ref=&quot;loggingAspect&quot;&gt; &lt;aop:around method=&quot;aroundMethod&quot; pointcut-ref=&quot;pointcut&quot;/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; JDBC相关JDBC相关工具c3p0配置数据源 数据源配置文件 db.properties 1234jdbc.password = 123456jdbc.driverClass = com.mysql:///spring4jdbc.initPoolSize = 5jdbc.maxPoolSize = 10 在applicationContext.xml里配置c3p0数据源 1234567891011&lt;!-- 导入资源文件 --&gt;&lt;context:property-placeholder location=&quot;classpath:db.properties&quot;/&gt;&lt;!-- 配置C3P0数据源 --&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.user&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClass&#125;&quot;/&gt; &lt;property name=&quot;initialPoolSize&quot; value=&quot;$&#123;jdbc.initialPoolSize&#125;&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;jdbc.maxPoolSize&#125;&quot;/&gt;&lt;/bean&gt; 测试连接数据源 12345678910111213public class JDBCTest &#123; private ApplicationContext ctx = null; &#123; ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); &#125; @Test public void testDataSource() throws SQLException &#123; DataSource dataSource = ctx.getBean(DataSource.class); System.out.println(dataSource.getConnection()); &#125;&#125; Spring的JDBCTemplate 在applicationContext.xml里配置JDBCTemplate 1234&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; JDBCTest 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class JDBCTest &#123; private ApplicationContext ctx = nulll; private JdbcTemplate jdbcTemplate; &#123; ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); jdbcTemplate = (JdbcTemplate) ctx.getBean(\"jdbcTemplate\"); &#125; /** * 单条更新 */ @Test public void testUpdate() &#123; String sql = \"UPDATE employee SET last_name = ? WHERE id=?\"; jdbcTemplate.update(sql, \"Jack\", 12); &#125; /** * 批量更新 */ @Test public void testBatchUpdate() &#123; String sql = \"INSERT INTO employee(last_name, email, dept_id) VALUES(?, ?, ?)\"; List&lt;Object[]&gt; betchArgs = new ArrayList&lt;&gt;(); batchArgs.add(new Object[]&#123;\"Zhang\", \"zhang@1.com\", 1&#125;); batchArgs.add(new Object[]&#123;\"Li\", \"li@2.com\", 2&#125;); batchArgs.add(new Object[]&#123;\"Wang\", \"wang@3.com\", 3&#125;); jdbcTemplate.batchUpdate(sql, batchArgs); &#125; /** * 得到数据库里一条记录，并生成对象 * 注意：并不是使用queryForObject(String sql, Class&lt;Employee&gt; requiredType, Object...args) * 而是 queryForObject(String sql, RowMapper&lt;Employee&gt; requiredType, Object...args) * 1. 其中RowMapper指定如何去映射结果集的行，常用的实现类为BeanPropertyRowMapper * 2. 使用SQL中列的别名完成列名和类的属性名的映射。例如:last_name lastName * 3. 并不支持级联属性，JdbcTemplate只是JDBC的小工具，并非ORM框架 */ @Test public void testQueryForObject() &#123; String sql = \"SELECT id,last_name lastName, email FROM employees WHERE id = ？\"; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Employee.class); Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, 1); System.out.println(employee); &#125; /** * 获得单列的值，或做统计查询 */ @Test public void testQueryForObject2() &#123; String sql = \"SELECT count(id) FROM employees\"; long count = jdbcTemplate.queryForObject(sql, Long.class); System.out.println(count); &#125; /** * 查询实体类的集合 */ @Test public void testQueryForList() &#123; String sql = \"SELECT id, last_name lastName, email FROM employees WHERE id&gt; ?\"; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Employee.class); List&lt;Employee&gt; employees = jdbcTemplate.query(sql, rowMapper, 5); System.out.println(employees); &#125;&#125; 说明： 每次使用都创建一个JdbcTemplate的新实例，这种做法效率低下。 JdbcTemplate类被设计成线程安全的，所有可以在IOC中声明它的单个实例，并把这个实例注入到所有的Dao里。 代码实例： 123456789101112@Respositorypublic class DepartmentDao extends JdbcDaoSupport &#123; @Autowired private JdbcTemplate jdbcTemplate; public Employee get(Integer id) &#123; String sql = \"SELECT id, last_name lastName, email FROM employees WHERE id= ?\"; RowMapper&lt;Employee&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(Employee.class); Employee employee = jdbcTemplate.queryForObject(sql, rowMapper, id); return employee; &#125;&#125; 扩展JdbcDaoSupport 使用起来更麻烦，不推荐！ 1234567891011121314151617181920212223@Respositorypublic class DepartmentDao extends JdbcDaoSupport &#123; /** * 需要提供数据源(或使用JdbcTemplate)才能连接数据库 * 但由于JdbcDaoSupport父类中已经有JdbcTemplate变量， * 且setDataSource()已经被设计成final类型， * 所以并不能直接注入数据源 */ @Autowired public void setDataSource2(DataSource dataSource)&#123; setDataSource(dataSource); &#125; /** * 需要通过getJdbcTemplate()得到 JdbcTemplate对象 */ public DepartMent get(Integer id) &#123; String sql = \"SELECT id, dept_name name FROM departments WHERE id= ?\"; RowMapper&lt;DepartMent&gt; rowMapper = new BeanPropertyRowMapper&lt;&gt;(DepartMent.class); DepartMent departMent = getJdbcTemplate().queryForObject(sql, rowMapper, id); return departMent; &#125;&#125; 使用具名参数 不需要再在java代码里绑定dataSource。 配置NamedParameterJdbcTemplate 该对象可以使用具名参数，其没有无参构造器，必须对其构造器指定参数。 1234&lt;bean id=&quot;namedParameterJdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate&quot;&gt; &lt;constructor-arg ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 测试使用 12345678910111213141516171819202122232425262728293031323334353637383940public class JDBCTest &#123; private ApplicationContext ctx = nulll; private NamedParameterJdbcTemplate namedParameterJdbcTemplate; &#123; ctx = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); namedParameterJdbcTemplate = ctx.getBean(NamedParameterJdbcTemplate.class); &#125; /** * 可以给参数起名字 * 1.好处：若有多个参数，不需要再去对应位置，直接对应参数名，不方便维护。 * 2.缺点：书写复杂。 */ @Test public void testNamedParameterJdbcTemplate()&#123; String sql = \"INSERT INTO employees(last_name, email, dept_id) VALUES(:ln, :email, :deptid)\"; Map&lt;String,Object&gt; paramMap = new HashMap&lt;&gt;(); paramMap.put(\"ln\",\"Alice\"); paramMap.put(\"email\",\"Alice@123.com\"); paramMap.put(\"deptid\",\"2\"); namedParameterJdbcTemplate.update(sql, paramMap); &#125; /** * update(String sql, SqlParameterSource paramSource); * 1.sql语句中的参数名与类的属性名保持一致！ * 2.使用SqlParameterSource的实现类BeanPropertySqlParameterSource作为参数。 */ @Test public void testNamedParameterJdbcTemplate()&#123; String sql = \"INSERT INTO employees(last_name, email, dept_id) VALUES(:lastName, :email, :deptId)\"; Employee employee = new Employee(); employee.setLastName(\"zhang\"); employee.setEmail(\"zhang@1.com\"); employee.setDeptId(1); SqlParameterSource paramSource = new BeanPropertySqlParameterSource(Employee); namedParameterJdbcTemplate.update(sql, paramSource); &#125;&#125; JDBC事务什么是事务 事务管理是企业级应用程序开发中必不可少的技术，用来确保数据的完整性和一致性。 事务管理就是一系列动作，它们作为一个单独的工作单元。这些动作需要全部完成后才能都起作用。 事务的四个属性： 原子性(atomicity) 一致性(consistency) 隔离性(isolation) 持久性(durability) JDBC事务操作1234567891011121314151617181920212223242526272829public class JDBCTest &#123; public void test() &#123; Connection conn = null; try &#123; conn = dataSource.getConnection(); conn.setAutoCommit(false); //... conn.commit(); &#125; catch (SQLException e) &#123; e.printStackTrace(); if (conn != null) &#123; try &#123; conn.rollback(); &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125; throw new RuntimeException(); &#125; finally &#123; if (conn != null) &#123; try &#123; conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrance(); &#125; &#125; &#125; &#125;&#125; Spring中的事务管理 编程式事务管理 声明式事务管理 将事务管理代码从业务方法中分离出来，以声明的方式来实现事务管理。 事务管理作为一种横切关注点，可以通过AOP方法模块化。Spring通过Spring AOP框架支持声明式事务管理。 Spring从不同的事务管理API中抽象了一整套的事务机制。从而让事务管理代码独立于特定的事务之外。 使用方法： applicationContext.xml配置 1234567&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 启动事务 --&gt;&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 使用方法 在相应方法前增加注释 @Transactional，这个方法就会变成事务方法，IoC会让这个方法拥有事务的特性。 事务传播属性 当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。 传播行为(propagation) REQUIRED(默认)：共用一个事务操作，回滚时都不执行。（例如：买了两本书，第二本购买失败，第一本也会失败） REQUIRES_NEW：开启一个新的事务。（买了两本书，第二本购买失败，不影响第一本） 隔离级别(isolation) DEFAULT 默认隔离级别，每种数据库支持的事务隔离级别不一样。 READ_UNCOMMITTED 读未提交，即能够读取到没有被提交的数据，所以很明显这个级别的隔离机制无法解决脏读、不可重复读、幻读中的任何一种，因此很少使用。 READ_COMMITED 读已提交，即能够读到那些已经提交的数据，自然能够防止脏读，但是无法限制不可重复读和幻读 REPEATABLE_READ 重复读取，即在数据读出来之后加锁，类似”select * from XXX for update”，明确数据读取出来就是为了更新用的，所以要加一把锁，防止别人修改它。REPEATABLE_READ的意思也类似，读取了一条数据，这个事务不结束，别的事务就不可以改这条记录，这样就解决了脏读、不可重复读的问题，但是幻读的问题还是无法解决。 SERLALIZABLE 串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了 回滚类型 默认情况下对所有运行时异常进行回滚。 对某些异常不会滚：noRollbackFor={UserAccountException.class} 对哪些异常回滚：rollbackFor={UserAccountException.class} 只读(readOnly=true) 标明这个事务只读取数据而不更新，这样可以帮助数据库引擎优化事务 强制回滚时间(timeout=1) 如果事务执行时间超过1s，会强制回滚。以保证不占用太多数据库连接时间。 使用实例 123456789@Transactional(propagation=Propagation.REQUIRES_NEW)public void purchase(String username, String isbn) &#123; //查询书的单价 int price = bookShopDao.findBookPriceByIsbn(isbn); //更新库存 bookShopDao.updateBookStock(isbn); //更新账户余额 bookShopDao.updateUserAccount(username, price);&#125; 使用xml配置声明式事务1234567891011121314151617181920&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;&lt;/bean&gt; &lt;!-- 配置事务属性 --&gt;&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;!-- 根据方法名置顶事务的属性 --&gt; &lt;tx:method name=&quot;purchase&quot; propagation=&quot;REQUIRES_NEW&quot;&gt; &lt;tx:method name=&quot;*&quot;/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置切入点 --&gt;&lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(* cn.gxk.spring4.xml.service.*.*(...))&quot; id=&quot;txPointCut&quot;/&gt; &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointCut&quot;/&gt;&lt;/aop:config&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://gxkord.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://gxkord.github.io/tags/Spring/"}]},{"title":"第4章 存储器","slug":"计算机基础/计算机组成原理/第4章 存储器","date":"2019-03-16T07:05:00.000Z","updated":"2019-04-08T13:41:11.330Z","comments":true,"path":"2019/03/16/计算机基础/计算机组成原理/第4章 存储器/","link":"","permalink":"https://gxkord.github.io/2019/03/16/计算机基础/计算机组成原理/第4章 存储器/","excerpt":"","text":"概述存储器分类 按存储介质分类 半导体存储器（TTL、MOS） 按材料不同，可分为TTL（双极型）半导体存储器和MOS半导体存储器。 磁表面存储器（磁头、磁载体） 磁芯存储器（硬磁材料、环状元件） 光盘存储器（激光、磁光材料） 按存取方式分类 存取时间与物理地址无关（随机访问） 随机存储器：在程序的执行过程中可读可写。 只读存储器：在程序的执行过程中只读。 存取时间与物理地址有关（串行访问） 顺序存取存储器（磁带） 直接存取存储器（磁盘） 按在计算机中的作用分类 主存储器 RAM（静态RAM、动态RAM） ROM（MROM、PROM、EPROM、EEPROM） Flash Memory 高速缓冲存储器（Cache） 辅助存储器（如：磁盘、磁带、光盘） 存储器的层次结构 存储器三个主要特性的关系 存储器三个主要特性的关系 缓存-主存层次和主存-辅存层次 (1) 主存-辅存层次是为了解决主存容量小的问题。 辅存容量较大，可以将暂时不需要的数据（或指令）保存起来，主存需要时再读取。 主存和辅存的整体，称为虚拟存储器。主存和辅存的地址空间相互独立，所以虚拟存储器中的数据需要虚地址（逻辑地址）来存取。 相对的，主存中的地址称为实地址（物理地址）。 (2) 缓存-主存层次是为了解决主存速度慢的问题。 缓存中保存了主存中部分常用数据（或指令）的副本，以提高CPU对这些常用信息（或指令）的读取速度。 主存储器概述 主存的基本组成 实际上，通过MAR中的地址访问某个存储单元时，还需要经过地址译码、驱动等电路，才能找到所需访问的单元。读出时，需经过读出放大器，才能将选中单元的存储字送到MDR。写入时，MDR中的数据也必须经过写入电路才能真正写入到被选中单元中。 主存和CPU的联系 主存中存储单元地址的分配 12345678H这个数据如何在主存储器中进行存储？ (1) 高位字节地址为字地址（大端、大尾方式） (2) 低位字节地址为字地址（小端、小尾方式） 设地址线24根——按字节寻址——2^24 = 16MB 若字长为16位——按 字 寻址——8MW 若字节为32位——按 字 寻址——4MW 主存的技术指标 (1) 存储容量：主存存放二进制代码的总位数。 (2) 存储速度 存取时间：存储器的访问时间（读出时间或写入时间）。 存取周期：连续两次独立的存储器操作（读或写）所需的最小间隔时间。（读周期或写周期） (3) 存储器带宽 表示单位时间内存储器存取的信息量，单位可用字/秒或字节/秒或位/秒来表示。 计算：若存周期为500ns，每个存储周期可访问16位（数据总线宽度），求它的带宽？ 解： $\\frac{16位}{50ns} = \\frac{16位×10^9}{50秒} = 32M位/秒$ 半导体存储芯片简介 半导体存储芯片的基本结构 译码驱动能把地址总线送过来的地址信号翻译成对应存储单元的选择信号，该信号在读/写电路的配合下完成对选中单元的读/写操作。 读/写电路包括读出放大器和写入电路，用来完成读/写操作。 存储芯片通过地址总线、数据总线和控制总线与外部连接。 片选线：$\\overline{CS}$、$\\overline{CE}$ 读/写控制线：$\\overline{WE}$（低电平写 高电平读） $\\overline{OE}$（允许读）、$\\overline{WE}$（允许写） 存储芯片片选线的作用： 用16K × 1位的存储芯片组成64K × 8位的存储器： ![32片存储芯片组成64K × 8位的存储器](用16K × 1位的存储芯片组成64K × 8位的存储器.jpg) 当地址为65535时， 由于$64K = 64 × 2^{10} = 65536$，显然，65535保存在最后一组（右）。 可以在最后一组的芯片的同一位置各存放一位数据组成一个字符（共8位）。 半导体存储芯片的译码驱动方式 (1) 线选法 译码器： 以二次译码器为例，2个输入，4个输出。若输入00，则输出线0有效，其他输出线无效；若输入01，则输出线1有效，其他输出线无效。 下图的地址译码器与之类似。输入有四个(A1,A2,A3,A4)，输出有16个（2^4，与输入相对应）。 读/写控制电路用来表示位，位线的数量与位数相等。 而对于容量大(m × n)的半导体存储芯片，若使用线选法，则需要大量的数据线(logm + n条)。这严重增加了集成芯片的难度。 (2) 重合法 下图有两根MOS管，用来控制电流的流向，从而切换译码器。 对于m × n的半导体存储芯片，若使用重合法，则需要log(m+n)条数据线。 随机存取存储器 静态RAM（SRAM） Q： 保存0和1的原理是什么？ 基本单元电路的构成是什么？ 对单元电路如何读出和写入？ 典型芯片的结构是什么样子的？ 静态RAM芯片如何进行读出和写入操作？ (1) 静态RAM基本电路 有哪些保存0和1的方式？ 开关（开：1；关：0） 熔丝（连通：1；断开：0）- 难以更改 触发器 T1~T4：由MOS管组成的触发器（用来存放0和1） T5、T6：行开关 T7、T8：列开关 A：触发器原端 A’：触发器非端 ① 静态RAM基本电路的读操作 行选 → T5、T6开 列选 → T7、T8开 读操作有效 VA → T6 → T8 → 读放 → Dout ② 静态RAM基本电路的写操作 行选 → T5、T6开 列选 → T7、T8开 写操作有效 DIN → 两个写放 DIN(左) → 反相 → T7 → T5 → A‘ DIN(右) → T8 → T6 → A (2) 静态RAM芯片举例（简单了解） ① Intel2114外特性 ② Intel2114 RAM矩阵(64 × 64) - 读 ③ Intel2114 RAM矩阵(64 × 64) -写 动态RAM（DRAM） Q： 保存0和1的原理是什么？ 基本单元电路的构成是什么？ 对单元电路如何读出和写入？ 典型芯片的结构是什么样子的？ 动态RAM芯片如何进行读出和写入操作？ 动态RAM为什么要刷新，刷新方法？ (1) 动态RAM基本单元电路 靠电容存储电荷的原理来寄存信息。若电容上存在足够多的电荷表示存“1”，电容上无电荷表示存“0”。 三管式 读出时，先对预充电管T4置一预充电信号，使读数据线达到高电平VDD。然后由读选择线打开T2，若T1的极间电容Cg存有足够电荷（被认为原存“1”），使T1导通，则因T2、T1接地，使读数据线降为零电平，读出“0”信息；若Cg没有足够电荷（原存“0”），则T1截止，读数据线为高电平不变，读出“1”信息。可见，读出线的高低电平可以区分“1”和“0”，且读出与原存信息相反。 写入时，将写信号加到写数据线上，然后由写数据线打开T3，这样，Cg便能随输入信息充电（写“1”）或放电（写“2”），且写入与输入信息相同。 单管式 为了提高集成度，将三管电路简化为单管。 去掉T1，将信息保存到电容 Cs中。 将T2、T3合并为一个管子T。 读出时，字线上的高电平使T接通，若Cs有电荷，视为“1”；若Cs无电荷，视为“0”。（读出结束时，Cs中电荷释放完毕，所以为破坏性读出，必须再生。） 写入时，字线上的高电平使T接通，若数据线为高电平，经过T对Cs充电，使其存“1”；若数据线为低电平，Cs经T放电，使其存“0”。 (2) 动态RAM芯片举例 ① 三管动态RAM芯片(Intel 1103) - 读 ② 三管动态RAM芯片(Intel 1103) - 写 ③ 单管动态RAM 4116 (16K × 1位)外特性 ④ 4116(16K × 1位)芯片读原理 ⑤ 4116(16K × 1位)芯片写原理 (4) 动态RAM刷新（刷新与行地址有关） ① 集中刷新（存取周期为0.5μs） 以128 × 128为例： “死区”为 $0.5μs × 128 = 64μs$ “死时间率”为 $128/4000 × 100% = 3.2%$ ② 分散刷新（存取周期1μs） 以128 × 128为例： 无“死区” 存取周期为$0.5μs + 0.5μs = 1μs$（周期变长，性能降低） ③ 异步刷新（分散刷新与集中刷新相结合）（存储周期为0.5μs） 对于128×128的存储芯片： 若每隔15.6μs刷新一行 每行每隔2ms刷新一次 死区为0.5μs 将刷新安排在指令译码阶段，不会出现“死区”问题。 动态RAM和静态RAM的比较 DRAM SRAM 存储原理 电容 触发器 集成度 高 低 芯片引脚 少 多 功耗 小 大 价格 低 高 速度 慢 快 刷新 有 无 DRAM（动态RAM）常用于做主存；SRAM（静态RAM）常用于做缓存。 只读存储器（ROM） 早期的只读存储器——由厂家写内容 改进1——用户可以自己写（一次性） 改进2——可以多次写（要能对信息进行擦除） 改进3——电可擦写（特定设备） 改进4——电可擦写（直接连接到计算机） 掩模ROM（MROM） 行列选择交叉处有MOS管为“1” 行列选择交叉处无MOS管为“0” PROM（一次性编程） 熔丝断：为“0” 熔丝未断：为“1” EPROM（多次性编程） N型沟道浮动栅MOS电路 D端加正电压——形成浮动栅——S与D不导通为“0” D端不加正电压——不形成浮动栅——S与D导通为“1” 使用紫外线驱散浮动栅（擦除过程麻烦） EEPROM（多次编程） 电可擦写 局部擦写 全部擦写 Flash Memory（闪速型存储器） EPROM —— 价格便宜 集成度高 EEPROM —— 电可擦洗重写 Flash Memory —— 比EEPROM快 具备RAM功能 存储器与CPU的连接 存储器容量的扩展 (1) 位扩展（增加存储字长） 用2片1K × 4位存储芯片组成1K × 8位的存储器 1K → 10根地址线 8位 → 8根数据线 (2) 字扩展 用2片1K × 8位存储芯片组成2K × 8位的存储器 2K → 11根地址线 8位 → 8根数据线 (3) 字、位同时扩展 用8片1K × 4位存储芯片组成4K × 8位的存储器 4K → 12根地址线 8位 → 8根数据线 存储器与CPU的连接 (1) 地址线的连接 (2) 数据线的连接 (3) 读/写命令线的连接 (4) 片选线的连接 (5) 合理选择存储芯片 (6) 其他（时序、负载） 例4.1、例4.2。 存储器的校验 为什么要对存储器的信息进行校验？ 为了能够校验出信息是否正确，如何进行编码？ 检测和纠错能力与什么因素有关？ 校验出信息出错后是如何进行纠错的？ 除了教材上讲的校验码，你还知道哪些容错编码？原理是什么？ 合法代码集合 {000, 001, 010, 011, 100, 101, 110, 111} 若出现错误代码，不会被发现。 检0位错，纠0位错。 {000, 011, 101, 110}（代码中1的个数为偶数。） 若出现错误代码100，能检测到1位错，但并不能纠错（来源可能是000或101或110）。 检1位错，纠0位错。 {000, 111}（3位表示1位） 若出现错误代码100，几乎可以认定是第1位出错了（正确代码为000）。 若出现错误代码110，几乎可以认定是第3位出错了（正确代码为111）。 检1位错，纠1位错。 {0000, 1111}（4位表示1位） 若出现错误代码1000，几乎可以认定是第1位出错了（正确代码为0000）。 若出现错误代码1100，几乎可以认定是第1位出错了（正确代码无法确定）。 检2位错，纠1位错。 {00000, 11111}（5位表示1位） 若出现错误代码11000，几乎可以认定第2、3位出错了（正确代码为00000）。 若出现错误代码11100，几乎可以认定第4、5位出错了（正确代码为11111）。 检2位错，纠2位错。 编码的最小距离 指任意两组合法代码之间二进制位的最少差异数。 编码的纠错、检错能力与编码的最小距离有关。 $L - 1 = D + C (D &gt;= C)$ L —— 编码的最小距离 D —— 检测错误的位数 C —— 纠正错误的位数 例如，当L=3时，这种编码可视为最多能检错二位，或能检错一位、纠错一位。 汉明码是具有一位纠错能力的编码。 汉明码的组成 汉明码采用奇偶检验 汉明码采用分组检验 若要储存的信息为00100011，增加1位校验位100100011，使‘1’的个数为偶数。若读出的信息中‘1’的个数为奇数，即可检1位错。 一种分组方式（基于划分的分组方式）：可以采用4位一组，得到10010 00011，若前五位中‘1’为奇数，则前五位有1位错，这样就能大大缩短需要检错的范围。 汉明码的分组是一种非划分方式。 若有7位数据（1 - 2 - 3 - 4 - 5 - 6 - 7），将其分成3组，每组有1位校验位，共包含4位数据位。如下图所示： 按上图方式对三组数据进行奇偶校验（异或），得到校验结果$P_3$，$P_2$，$P_1$。（校验结果为1则该组出错） 结论如下： 如何分组？ 第1组：XXXX1（1） 第2组：XXX1X（2） 第3组：XX1XX（4） 第4组：X1XXX（8） 以此类推…… 汉明码的组成需要添加多少位检测位？ $2^k&gt;=n+k+1$ 检测位的位置？ $2^i(i=0,1,2,3,…)$ 检测位的取值？ 与该位所在的检测“小组”所承担的奇偶校验任务有关。 各检测位$C_i$所承担的检测小组为： $C_1$检测的g1小组包含第1, 2, 3, 7, 9, 11, …位（二进制编码为X…XXX1） $C_2$检测的g2小组包含第2, 3, 6, 7, 10, 11, …位（二进制编码为X…XX1X） $C_4$检测的g3小组包含第4, 5, 6, 7, 12, 13, …位（二进制编码为X…X1XX） $C_8$检测的g4小组包含第8, 9, 10, 11, 12, 13, …位（二进制编码为X…1XXX） …… $g_i$小组独占$2^{i-1}$位，二进制编码为0…10…0 $g_i$和$g_j$小组共同占第$2^{i-1}+2^{j-1}$位，二进制编码为0…010…010…0 $g_i$、$g_j$和$g_l$小组共同占第$2^{i-1}+2^{j-1}+2^{l-1}$位 例题：求0101按“偶校验”配置的汉明码？ 解： $∵n=4$ 根据$2^k&gt;=n+k+1$，得$k=3$ 汉明码排序如下： 汉明码排序 $C_1=3⊕5⊕7=0$ $C_2=3⊕6⊕7=1$ $C_4=5⊕6⊕7=0$ $∴$ 0101的汉明码为 0100101 汉明码的纠错过程 形成新的检验位$P_i$，其位数与增添的检测位有关， 如增添3位（k=3），新的检测位$P_4$、$P_2$、$P_1$ 以k=3位例，$P_i$的取值为： $P_1=1⊕3⊕5⊕7$ $P_2=2⊕3⊕6⊕7$ $P_4=4⊕5⊕6⊕7$ 对于按“偶校验”配置的汉明码： 不出错时， $P_1=0$，$P_2=0$，$P_4=0$ 例题：已知接收的汉明码为0100111， （按配偶原则配置）试问要求传送的信息是什么？ 解： 纠错过程如下： $P_1=1⊕3⊕5⊕7=0$ 无错 $P_2=2⊕3⊕6⊕7=1$ 有错 $P_4=4⊕5⊕6⊕7=1$ 有错 即第6位出错，可纠正为0100101， 故要求传送的信息为0101。 提高访问速度的措施 采用高速器件 采用层次结构欧Cache-主存 调整主存结构 单体多字系统 由于程序和数据在存储体内是连续存放的，因此CPU访存取出的信息也是连续的，如果可在一个存储周期内，从同一地址取出4条指令，然后再逐条送至CPU执行，即每隔1/4存取周期，主存向CPU送一条指令，这样显然增大了存储器的带宽，提高了单体存储器的工作速度，如下图所示。 存在的问题： 若只需向存储体写入16位数据（单字长），而数据寄存器却多读出了48位，若想让这48位不存入存储体，会增加寄存器的复杂性。 若需要取出的数据（或指令）不是连续的，必然会使数据寄存器取出无用的数据。 虽然单体多字系统把数据分开存取，但它们依然是以整体的方式存在的。 多体并行系统 高位交叉（顺序编址） 存在的问题： 某个存储体可能会非常繁忙，其余存储体空闲。 这种方式主要适用于存储器容量的扩展，并不适合提高存储器的带宽。 低位交叉（各个体轮流编址） 低位交叉的特点： 在不改变存储周期的前提下，增加存储器的带宽。 以四体低位交叉存储器为例，存储周期位$T$，总线传输周期为$τ$，为实现流水线方式存取，应满足$T=4τ$。 连续读取4个字所需时间位$T+(4-1)τ$ 高性能存储芯片 SDRAM(同步RAM) 在系统时钟的控制下进行读出和写入。 CPU无须等待。 RDRAM 由Rambus开发，主要解决存储器带宽问题。 带Cache的DRAM 在DRAM的芯片内集成了一个由SRAM组成的Cache，有利于猝发式读取。 高速缓冲存储器概述 问题的提出 避免CPU“空等”现象 CPU和主存（DRAM）的速度差异 程序访问的局部性原理：指令和数据在主存的地址分布不是随机的，而是相对的簇聚，使得CPU在执行程序时，访存具有相对的局部性。 Cache工作原理 (1) 主存和缓存的编址 主存和缓存按块存储，块的大小相同。 实际上，缓存中块内地址的意义不大。这是因为主存的块内地址和缓存中的块内地址位数是相同的，而且“块”在主存和Cache之间是整体传输的，块内字节顺序不会发生变化。 缓存中的标记，是用来保存对应主存块号的。若CPU给出一个内存地址，并希望在缓存中访问到这个地址，首先要对比缓存中的标记，确定该块是否已经被读取到了Cache中。 (2) 命中与未命中 缓存共有C块，主存共有M块（M&gt;&gt;C） 命中 主存块调入缓存 主存块与缓冲块建立了对应关系 用标记记录与某缓存块建立了对应的主存块号 未命中 主存块未调入缓存 主存块与缓冲块未建立对应关系 (3) Cache的命中率 CPU欲访问的信息在Cache中的比率 命中率与Cache的容量与块长有关 一般每块可取4~8个字 块长取一个存取周期内从主存调出的信息长度 (4) Cache - 主存系统的效率 效率e与命中率有关 $e=\\frac{访问Cache的时间}{平均访问时间}×100%$ 设Cache命中率为h，访问Cache的时间为$t_c$，访问主存的时间为$t_m$， 则$e=\\frac{t_c}{h×t_c+(1-h)×t_m}×100%$ Cache的基本结构 CPU（通过地址总线）给出地址，这个地址包括（主存）块号和块内地址。块内地址直接传给Cache，使用块号在主存Cache地址映像机构中确认是否命中。如果发生命中，得到Cache的块号；如果未命中，查看Cache中是否有空间可装入主存块。若有，访问主存装入Cache；若没有，启用Cache替换机构，根据替换算法，决定Cache中哪块可以被替换，然后访问主存替换Cache即可。 Cache的读写操作 读 写 写直达法（Write-through） 写操作时数据既写入Cache又写入主存 写操作时间就是访问主存时间，Cache块退出时，不需要对主存执行写操作，更新策略比较容易实现 写回法（Write-back） 写操作只把数据写入Cache而不写入主存 当Cache数据被替换出去时才写回主存 Cache的改进 (1) 增加Cache的级数 片载（片内）Cache 片外Cache (2) 统一缓存和分立缓存 统一缓存：指令和数据放在同一缓存内的Cache 分立缓存：分成指令Cache、数据Cache 两种缓存的选取主要考虑两个因素： 与主存结构有关。如果计算机的主存是统一的（指令和数据存储在统一主存中），则相应的Cache采用统一缓存；如果主存采用指令、数据分开存储的方案，则相应的Cache采用分立缓存。 与指令执行的控制方式有关。当采用超前控制或流水线控制方式时，一般采用分立缓存。 Cache-主存地址映射 直接映射 根据Cache存储体的大小将主存储体划分成多个区，每个区与Cache存体大小相同。 每个缓存块i可以和若干个主存块对应。 每个主存块j只能和一个缓存块对应。 优点：实现简单，只需利用主存地址的某些位直接判断，就可确定所需字块是否在缓存中。 缺点：不够灵活，因每个内存块只能固定地对应某个缓存块，即使缓存内还空着许多位置也不能占用，使缓存的存储空间得不到充分的利用。此外，如果程序恰好要重复访问对应同一缓存位置的不同主存块，就要不停地进行替换，从而降低命中率。 例题：设主存容量为1MB，采用直接映射方式的Cache容量为16KB，块长为4，每字32位。试问主存地址位ABCDEH的存储单元在Cache中的什么位置？ 解： 每块容量：$4×\\frac{32}{8}=16B=2^4B$，即字块内地址4位。 块数：$\\frac{16KB}{16B}=1K=1024$，即Cache字块地址10位。 主存容量$1MB=2^{20}B$，即地址总格式20位，分为$\\frac{1MB}{4×\\frac{32}{8}B}=2^{16}$块，每块$2^4B$，采用直接映射方式，主存字块标记为$20-14=6$位。 综上，主存地址格式为： 主存字块标记（6位）Cache字块地址（10位）字块内地址（4位） 主存地址$ABCDEH=(1010 1011 1100 1101 1110)_2$，主存字块标记为101010，Cache字块地址为1111001101，字块内地址为1110，故该主存单元应映射到Cache的101010块的第1110字节，即第42块第14字节位置。 全相联映射 允许主存中每一字块映射到Cache中的任何一块位置上。 优点：灵活，命中率高，缩短了块冲突率。 缺点： (1) 主存字块标记需要与Cache的所有标记进行同时比较，电路会非常复杂。 (2) 主存字块标记从t位增加到t+c位，这就使Cache”标记“的位数增多，比较器的长度就会增长。 组相联映射 组相联映射是对直接映射和全相联映射的一种折中。 $i = jmodQ$ 某一主存块j按模Q映射到缓存的第i组中的任一块。 替换算法 先进先出（FIFO）算法 近期最少使用（LRU）算法 随机法 辅助存储器（非重要）概述 特点 不直接与CPU交换信息。 磁表面存储器的技术指标 (1) 记录密度（道密度$D_t$、位密度$D_b$） (2) 存储容量 $C=n×k×s$，n为存放信息的盘面数，k为每个盘面的磁道数，s为每条磁道上记录的二进制代码数。 (3) 平均寻址地址 寻道时间 + 等待时间 辅存的速度：寻址时间、磁头读写时间 (4) 数据传输率 $D_r=D_b×V$ (5) 误码率 出错信息位数与读取信息的总位数。 磁记录原理和记录方式 磁记录原理 写： 读： 硬磁盘存储器 硬磁盘存储器的类型 (1) 固定磁头和移动磁头 (2) 可换盘和固定盘 硬磁盘存储器结构 (1) 磁盘驱动器 (2) 磁盘控制器 接收主机发来的命令，转换成磁盘驱动器的控制命令。 实现主机和驱动器之间的数据格式转换。 控制磁盘驱动器读写。 磁盘控制器是主机与磁盘驱动器之间的接口。 (3) 盘片 由硬质铝合金材料制成。 软磁盘存储器 概述 硬盘 软盘 速度 高 低 磁头 固定、活动（浮动） 活动（接触盘片） 盘片 固定盘、盘组大部分不可换 可换盘片 价格 高 低 环境 苛刻 软盘片 光盘存储器 概述 采用光存储技术 —- 利用激光写入和读出 第一代光存储技术 —- 采用非磁性介质 —- 不可擦写 第二代光存储技术 —- 采用磁性介质 —- 可擦写 光盘的存储原理 只读型和只写一次型 —- 热作用（物理或化学） 可擦写光盘 —- 热磁效应","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://gxkord.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://gxkord.github.io/tags/计算机组成原理/"}]},{"title":"第3章 系统总线","slug":"计算机基础/计算机组成原理/第3章 系统总线","date":"2019-03-15T07:10:12.000Z","updated":"2019-03-15T16:49:56.680Z","comments":true,"path":"2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/","link":"","permalink":"https://gxkord.github.io/2019/03/15/计算机基础/计算机组成原理/第3章 系统总线/","excerpt":"","text":"总线的基本概念为什么要用总线计算机系统的五大部件之间有两种互联方式：分散连接、总线连接。 分散连接：各部件之间使用单独的连线。（分散连接会使系统难以扩展，所以引入总线结构。) 总线连接：将各部件连接到一组公共信息传输线上。 什么是总线总线是连接各个部件的信息传输线，是各个部件共享的传输介质。 总线上信息的传输串行：信息在总线上按位传输。常用与计算机与计算机之间。 并行：信息在总线上多位传输。需要多条数据线平行传输，所以，若传输距离过长，数据线之间容易发生干扰。常用于单个计算机内部。 总线结构的计算机举例 单总线结构框图 缺点：设备的利用率低。在同一时刻，只有一对设备能使用总线。 面向CPU的双总线结构框图 缺点：主存和外部设备之间无直接通路。若两者之间需要通信，会打断CPU的运行。 以存储器为中心的总线结构框图 总线的分类 按连接部件不同： (1) 片内总线：芯片内部的总线。 (2) 系统总线：计算机各部件之间的信息传输线。 ① 数据总线：双向，与机器字长、存储字长有关。 ② 地址总线：单向，与存储地址、I/O地址有关。 ③ 控制总线：有出（存储器读、写，总线许可，中断确认）有入（中断请求、总线请求）。(3) 通信总线：用于计算机系统之间或计算机系统与其他系统（如控制仪表、移动通信等）之间的通信。 按传输方式：并行传输总线、串行传输总线。 总线特性及性能指标总线物理实现 总线物理实现 总线特性 机械特性：尺寸、形状、管脚数及排列顺序。 电气特性：传输方向和有效的电平范围。 功能特性：每根传输线的功能（地址、数据或控制）。 时间特性：信号的时序关系。 总线的性能指标 总线宽度：数据线的根数。 标准传输率：每秒传输的最大字节数（MBps）。 时钟同步/异步：同步、不同步（不等同于异步）。 总线复用：地址线与数据线复用。 信号线数：地址线、数据线和控制线的总和。 总线控制方式：突发、自动、仲裁、逻辑、计数。 其他指标：负载能力。 总线标准 总线标准 总线结构单总线结构 单总线结构 多总线结构 双总线结构 双总线结构 三总线结构 三总线结构1 三总线结构2 四总线结构 四总线结构 总线结构举例 传统微型机总线结构 VL-BUS局部总线结构 PCI总线结构 多层PCI总线结构 总线控制总线判优 基本概念 主设备（模块）：对总线有控制权。 从设备（模块）：响应从主设备发来的总线命令。 总线判优控制：决定由哪个主设备占用总线。分为集中式、分布式两种。 总线判优控制（集中式） (1) 链式查询方式 I/0接口n获得总线使用权的过程：I/0接口n发出BR（总线请求），然后总线控制部件发出BG（总线统一），I/0接口n再发送BS（总线忙）。 (2) 计数器定时查询方式 I/0接口n获得总线使用权的过程：I/0接口n发出BR给总线控制部件，若可以给出总线使用权，则启用计数器，并初始化为0。总线控制部件通过设备地址（线）访问设备0，检查其是否发出了BR；若否，计数器+1，再访问设备1……若检查至设备n，且设备n发出了BR，则设备n发送BS。 优点：设备（接口）的优先级设置非常灵活。 (3) 独立请求方式 I/O接口n获得总线使用权的过程：直接向总线控制部件发送BR，比对排队器里的序列，向对应I/O接口发送BG信号即可。 优点：每个I/O接口都有独立的BR和BG。优先级的设置更加灵活，只需要管理总线控制部件的排队器即可。 总线通信控制 目的 解决通信双方协调配合问题。 总线传输周期 (1) 申请分配阶段：主模块申请，总线仲裁决定。 (2) 寻址阶段：主模块向从模块给出地址和命令。 (3) 传数阶段：主模块和从模块交换数据。 (4) 结束阶段：主模块撤销有关信息。 总线通信的四种方式 (1) 同步通信：由统一时标控制数据传送。 ① 同步式数据输入 T1 - 主模块发地址 T2 - 主模块发读命令。 T3 - 从模块提供数据。 T4 - 主模块撤销读命令，从模块撤销数据。 ② 同步数据输出 T1 - 主模块发地址。 T1.5 - 主模块提供数据。 T2 - 从模块发出写命令，从模块接收到命令后，必须在规定时间内将数据总线上的数据写到 地址总线所知名的单元中。 T4 - 主模块撤销写命令和数据等信号。 (2) 异步通信：采用应答方式，没有公共时钟标准。 ① 不互锁方式：请求和回答互不相关。无法保证通信的可靠性。 ② 半互锁方式：主模块接到从模块发送的回答信号，才撤销请求信号。可能会造成请求信号一直保持高电平状态。 ③ 全互锁方式：主模块的请求信号撤销以后，从模块才撤销其回答信号。 (3) 半同步通信：同步、异步结合。 同步：发送方用系统时钟前沿发信号；接收方用系统时钟后沿判断、识别。 异步：允许不同速度的模块和谐工作。增加一条“等待”响应信号。($\\overline{WAIT}$) 以输入数据为例： T1 - 主模块发出地址信号。 T2 - 主模块发出命令。 Tw - 当$\\overline{WAIT}$为低电平时，进入等待，Tw的宽度与T的宽度一致。 . . . T3 - 从模块提供数据。 T4 - 主模块撤销读命令，从模块撤销数据。 上述三种通信（同步、异步、半同步）的共同点： 一个总线传输周期（以输入数据为例） 主模块发地址、命令（占用总线） 从模块准备数据（不占用总线，总线空闲） 从模块向主模块发数据（占用总线） (4) 分离式通信：充分挖掘系统总线每个瞬间的潜力。 原因：上述三种通信从模块准备数据时，总线处于空闲状态！ 一个总线传输周期： 子周期1：主模块申请占用总线，使用完后即放弃总线的使用权。 子周期2：从模块申请占用总线，将各种信号送至总线上。 特点： ① 各模块有权申请占用总线。 ② 采用同步方式通信，不等对方回答。 ③ 各个模块准备数据时，不占用总线。 ④ 总线被占用时，无空闲。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://gxkord.github.io/categories/计算机基础/"}],"tags":[{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://gxkord.github.io/tags/计算机组成原理/"}]},{"title":"16. 3Sum Closest(Medium)","slug":"算法/LeetCode/16. 3Sum Closest(Medium)","date":"2019-03-02T12:40:12.000Z","updated":"2019-10-16T07:35:23.589Z","comments":true,"path":"2019/03/02/算法/LeetCode/16. 3Sum Closest(Medium)/","link":"","permalink":"https://gxkord.github.io/2019/03/02/算法/LeetCode/16. 3Sum Closest(Medium)/","excerpt":"","text":"题目描述原题 Description:Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution. Example: Given array nums = [-1, 2, 1, -4], and target = 1.The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 原题翻译 描述：给定一个由n个整数构成的数组nums和一个整数target，在nums中找到三个整数，使它们的总和最接近target。返回这三个整数的总和。您可以假设每个输入都只有一个答案。 例如: 给定数组 nums = [-1, 2, 1, -4], 和 target = 1.最接近target的整数为2。(-1 + 2 + 1 = 2) 解法一主要思想这道题是第15题的加强版，解法与15题相似。 运行速度：超过了98.65%的解答。 内存使用：超过了100%的解答。 源码12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public int threeSumClosest(int[] nums, int target) &#123; int cha = Integer.MAX_VALUE; int result = 0; Arrays.sort(nums); for (int i = 0; i &lt; nums.length - 2; i++) &#123; if (result &gt; 0 &amp;&amp; nums[i] * 3 - target &gt;= result) &#123; // 若result &gt; 0，nums[i]与target的差大于result，后面的结果一定大于result。 break; &#125; if (i == 0 || nums[i] != nums[i - 1]) &#123; int low = i + 1, high = nums.length - 1, sum = target - nums[i]; while (low &lt; high) &#123; if (nums[low] + nums[high] == sum) &#123; return target; &#125; else if (nums[low] + nums[high] &lt; sum) &#123; if (sum - nums[low] - nums[high] &lt; cha) &#123; cha = sum - nums[low] - nums[high]; result = target - cha; &#125; low++; &#125; else &#123; if (nums[low] + nums[high] - sum &lt; cha) &#123; cha = nums[low] + nums[high] - sum; result = target + cha; &#125; high--; &#125; &#125; &#125; &#125; return result; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Medium","slug":"LeetCode-Medium","permalink":"https://gxkord.github.io/tags/LeetCode-Medium/"}]},{"title":"15. 3Sum(Medium)","slug":"算法/LeetCode/15. 3Sum(Medium)","date":"2019-02-15T11:33:12.000Z","updated":"2019-10-13T10:11:11.771Z","comments":true,"path":"2019/02/15/算法/LeetCode/15. 3Sum(Medium)/","link":"","permalink":"https://gxkord.github.io/2019/02/15/算法/LeetCode/15. 3Sum(Medium)/","excerpt":"","text":"题目描述原题 Description:Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0?Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. Example: Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 原题翻译 描述:给定一个包含n个实数的数组nums，其中是否存在元素a，b，c，使得a + b + c = 0？找到数组中所有唯一的三元组，它们的总和为零。 另外: 结果集中不得包含重复的三元组 例如: 给定数组 nums = [-1, 0, 1, 2, -1, -4],一个解决方案集合为:[ [-1, 0, 1], [-1, -1, 2]] 解法一主要思想首先，对数组进行排序。 然后，从0位置开始到倒数第三个位置（num.length-3)，进行遍历，假定num[i]就是3sum中得第一个加数，然后从i+1的位置开始，进行2sum的运算。 当找到一个3sum==0的情况时，判断是否在结果hashset中出现过，没有则添加。(利用hashset的value唯一性） 因为结果不唯一，此时不能停止，继续搜索，左右指针同时挪动。 需要注意： 排除一切结果为空的情况。 若第一次遍历到的值大于0，则后续一定也大于0。 若第一次遍历到的值等于0，则只需判断后面有没有两个相同值。 运行速度：超过了91.74%的解答。 内存使用：超过了91.87%的解答。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if (nums.length &lt; 3 || nums == null) return res; Arrays.sort(nums); // 对数组排序 if (nums[0] &gt; 0 || nums[nums.length - 1] &lt; 0) &#123; // 若数组中，最小值大于0 或 最大值小于0，则直接返回res。 return res; &#125; for (int i = 0; i &lt;= nums.length - 3; i++) &#123; if (nums[i] &gt; 0) &#123; // 若nums[i]的3倍比目标值大，后面的结果一定小 break; &#125; if (nums[i] == 0) &#123; // 若nums[i]的3倍与目标值相等 if (nums[i + 1] == 0 &amp;&amp; nums[i + 2] == 0) &#123; List&lt;Integer&gt; unit = new ArrayList&lt;Integer&gt;(); unit.add(0); unit.add(0); unit.add(0); res.add(unit); &#125; break; &#125; if (i == 0 || nums[i] != nums[i-1]) &#123; // 避免重复 int low = i + 1; int high = nums.length - 1; while (low &lt; high) &#123; int sum = nums[i] + nums[low] + nums[high]; if (sum == 0) &#123; List&lt;Integer&gt; unit = new ArrayList&lt;Integer&gt;(); unit.add(nums[i]); unit.add(nums[low]); unit.add(nums[high]); res.add(unit); low++; high--; while (low &lt; high &amp;&amp; nums[low] == nums[low - 1]) // 避免重复 low++; while (low &lt; high &amp;&amp; nums[high] == nums[high + 1]) // 避免重复 high--; &#125; else if (sum &gt; 0) high--; else &#123; low++; &#125; &#125; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Medium","slug":"LeetCode-Medium","permalink":"https://gxkord.github.io/tags/LeetCode-Medium/"}]},{"title":"14. Longest Common Prefix(Easy)","slug":"算法/LeetCode/14. Longest Common Prefix(Easy)","date":"2019-01-23T12:08:22.000Z","updated":"2019-10-13T10:11:38.399Z","comments":true,"path":"2019/01/23/算法/LeetCode/14. Longest Common Prefix(Easy)/","link":"","permalink":"https://gxkord.github.io/2019/01/23/算法/LeetCode/14. Longest Common Prefix(Easy)/","excerpt":"","text":"题目描述原题 Description:Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string “”. Example 1: Input: [“flower”,”flow”,”flight”]Output: “fl” Example 2: Input: [“dog”,”racecar”,”car”]Output: “”Explanation: There is no common prefix among the input strings. Note: All given inputs are in lowercase letters a-z. 原题翻译 描述:编写一个函数来查找字符串数组中最长的公共前缀字符串。 如果没有公共前缀，则返回空字符串””。 例1: 输入: [“flower”,”flow”,”flight”]输出: “fl” 例2: 输入: [“dog”,”racecar”,”car”]输出: “”解释: 输入字符串中没有公共前缀。 注意: 所有给定的输入都是小写字母a-z。 解法一(Mine)主要思想按每位依次比对字符串数组中的每个字符。注意：若遍历到某个字符串的第i个字符，其为当前字符串的最后一位，后面的字符就无需比对了。 运行速度：超过了74.19%的解答。 内存使用：超过了100%的解答。 源码1234567891011121314151617181920212223242526272829class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) return &quot;&quot;; else if (strs.length == 1) return strs[0]; StringBuilder res = new StringBuilder(); int index = 0; char temp = &apos; &apos;; boolean flag = true; f1: while (flag) &#123; f2: for (int i = 0; i &lt; strs.length; i++) &#123; if (&quot;&quot;.equals(strs[i])) break f1; if (i == 0) temp = strs[i].charAt(index); else if (temp != strs[i].charAt(index)) break f1; else if (i == strs.length - 1) if (temp == strs[i].charAt(index)) res.append(temp); if (index &gt;= strs[i].length() - 1) flag = false; &#125; index++; &#125; return res.toString(); &#125;&#125; 解法二主要思想 比较前两个字符串，得到公共前缀，与第三个字符串比较，直至公共前缀为空。 运行速度：超过了100%的解答。 内存使用：超过了80.70%的解答。 源码12345678910111213class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs.length == 0) return &quot;&quot;; String prefix = strs[0]; for (int i = 1; i &lt; strs.length; i++) while (strs[i].indexOf(prefix) != 0) &#123; prefix = prefix.substring(0, prefix.length() - 1); if (prefix.isEmpty()) return &quot;&quot;; &#125; return prefix; &#125;&#125; 解法三主要思想 与我的解法思想相同。 想象一下，一个非常短的字符串位于数组的末尾。上述方法仍将非常困难。优化此情况的一种方法是进行垂直扫描。在转到下一列之前，我们在同一列（字符串的相同字符索引）上从上到下比较字符。 运行速度：超过了74.19%的解答。 内存使用：超过了100%的解答。 源码1234567891011121314class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) return \"\"; for (int i = 0; i &lt; strs[0].length() ; i++)&#123; char c = strs[0].charAt(i); for (int j = 1; j &lt; strs.length; j ++) &#123; if (i == strs[j].length() || strs[j].charAt(i) != c) return strs[0].substring(0, i); &#125; &#125; return strs[0]; &#125;&#125; 解法四主要思想分治。先求左半边，再求右半边，然后合并。 运行速度：超过了74.19%的解答。 内存使用：超过了100%的解答。 源码123456789101112131415161718192021222324252627class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) return \"\"; return longestCommonPrefix(strs, 0 , strs.length - 1); &#125; private String longestCommonPrefix(String[] strs, int l, int r) &#123; if (l == r) &#123; return strs[l]; &#125; else &#123; int mid = (l + r)/2; String lcpLeft = longestCommonPrefix(strs, l , mid); String lcpRight = longestCommonPrefix(strs, mid + 1,r); return commonPrefix(lcpLeft, lcpRight); &#125; &#125; String commonPrefix(String left,String right) &#123; int min = Math.min(left.length(), right.length()); for (int i = 0; i &lt; min; i++) &#123; if ( left.charAt(i) != right.charAt(i) ) return left.substring(0, i); &#125; return left.substring(0, min); &#125;&#125; 解法五主要思想二分法。把第一个字符串分成两半，判断前一半是不是公共前缀。若是，后一半分成两半；若不是，前一半分成两半。 运行速度：超过了100%的解答。 内存使用：超过了97.08%的解答。 源码123456789101112131415161718192021222324252627class Solution &#123; public String longestCommonPrefix(String[] strs) &#123; if (strs == null || strs.length == 0) return \"\"; int minLen = Integer.MAX_VALUE; for (String str : strs) minLen = Math.min(minLen, str.length()); int low = 1; int high = minLen; while (low &lt;= high) &#123; int middle = (low + high) / 2; if (isCommonPrefix(strs, middle)) low = middle + 1; else high = middle - 1; &#125; return strs[0].substring(0, (low + high) / 2); &#125; private boolean isCommonPrefix(String[] strs, int len)&#123; String str1 = strs[0].substring(0,len); for (int i = 1; i &lt; strs.length; i++) if (!strs[i].startsWith(str1)) return false; return true; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Easy","slug":"LeetCode-Easy","permalink":"https://gxkord.github.io/tags/LeetCode-Easy/"}]},{"title":"13. Roman to Integer(Easy)","slug":"算法/LeetCode/13. Roman to Integer(Easy)","date":"2019-01-16T11:33:21.000Z","updated":"2019-10-13T09:52:01.305Z","comments":true,"path":"2019/01/16/算法/LeetCode/13. Roman to Integer(Easy)/","link":"","permalink":"https://gxkord.github.io/2019/01/16/算法/LeetCode/13. Roman to Integer(Easy)/","excerpt":"","text":"题目描述原题 Description:Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: “III”Output: 3 Example 2: Input: “IV”Output: 4 Example 3: Input: “IX”Output: 9 Example 4: Input: “LVIII”Output: 58Explanation: L = 50, V = 5, III = 3. Example 5: Input: “MCMXCIV”Output: 1994Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 原题翻译 描述:罗马数字由七个不同的符号表示：I，V，X，L，C，D和M。 符号 值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。十二写为XII，简称为X + II。第二十七号写成XXVII，即XX + V + II。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个罗马数字，将其转换为整数。输入确保在1到3999的范围内。 例1: 输入: “III”输出: 3 例2: 输入: “IV”输出: 4 例3: 输入: “IX”输出: 9 例4: 输入: “LVIII”输出: 58解释: L = 50, V = 5, III = 3. 例5: 输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90， IV = 4. 解法一(Mine)主要思想result（int类型）保存结果，从右向左遍历字符。若上一个大于当前，则result减当前value；否则，result加当前value。 运行速度：超过了100%的解答。 内存使用：超过了100%的解答。 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution &#123; public int romanToInt(String s) &#123; int result = 0; int i = s.length(); int pre = 0; int now = 0; while (i &gt; 0) &#123; char c = s.charAt(--i); switch(c) &#123; case 'I': now = 0; result = getResult(now, pre, 1, result); pre = 0; break; case 'V': now = 1; result = getResult(now, pre, 5, result); pre = 1; break; case 'X': now = 2; result = getResult(now, pre, 10, result); pre = 2; break; case 'L': now = 3; result = getResult(now, pre, 50, result); pre = 3; break; case 'C': now = 4; result = getResult(now, pre, 100, result); pre = 4; break; case 'D': now = 5; result = getResult(now, pre, 500, result); pre = 5; break; case 'M': now = 6; result = getResult(now, pre, 1000, result); pre = 6; break; &#125; &#125; return result; &#125; private int getResult(int now, int pre, int value, int result) &#123; if (pre &gt; now) result -= value; else result += value; return result; &#125;&#125; 解法二主要思想 第一名的答案，与方法一思想类似。 使用两次for循环。第一次把当前位置是否大于下一位置保存到boolean数组中。第二次根据boolean数组和字符串的同一位置，得到结果。 运行速度：超过了100%的解答。 内存使用：超过了100%的解答。 源码12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public int romanToInt(String s) &#123; int result = 0; boolean[] mem = new boolean[s.length()]; for (int i = 0; i&lt; s.length() - 1; i++) &#123; if (test(s.charAt(i)) &lt; test(s.charAt(i+1))) &#123; mem[i] = true; &#125; else &#123; mem[i] = false; &#125; &#125; mem[s.length() - 1] = false; for (int i = 0; i &lt; s.length(); i++)&#123; if (mem[i])&#123; result = result - test(s.charAt(i)); &#125;else&#123; result = result + test(s.charAt(i)); &#125; &#125; return result; &#125; public int test(char a) &#123; if (a == 'I') &#123; return 1; &#125; else if (a == 'V')&#123; return 5; &#125; else if (a == 'X')&#123; return 10; &#125; else if (a == 'L')&#123; return 50; &#125; else if (a == 'C')&#123; return 100; &#125; else if (a == 'D')&#123; return 500; &#125; else if (a == 'M')&#123; return 1000; &#125; else &#123; return 0; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Easy","slug":"LeetCode-Easy","permalink":"https://gxkord.github.io/tags/LeetCode-Easy/"}]},{"title":"2018","slug":"一些话/年终总结/2018","date":"2018-12-31T05:20:00.000Z","updated":"2019-01-23T07:57:46.342Z","comments":true,"path":"2018/12/31/一些话/年终总结/2018/","link":"","permalink":"https://gxkord.github.io/2018/12/31/一些话/年终总结/2018/","excerpt":"","text":"2018，可以称得上悠闲，也可以说是惨淡。 2018，考上了新的学校，有了一个新的身份，也创建了自己的博客。看了不少的电影，学了不多的知识。 2018，留下了不少遗憾：想刷LeetCode，由于某些原因只做了12道；想学Spring，却也没有每天坚持；想学机器学习，借到的书被一直搁置在书角；想通关的游戏，在Steam里没时间玩；电视剧电影看了一部又一部，反而极少拿出时间安静地读书…… 2019，给自己定了几个小目标：刷完LeetCode前200，搞懂SSM并有个小成果，学完吴恩达的CS229课程，拿到《Iris.Fall》《Slay the Spire》所有奖杯，每天都要学英语、读书…… 最后，放上B站关注了好久的一位UP主（独立菌儿）的视频：http://www.bilibili.com/video/av39426478 诚如电影《熔炉》的结尾时所说：“我们一路奋斗，不是为了改变世界，而是为了不让这个世界改变我们”。愿我们在新的一年都能保持独立思考，不卑不亢不怂，长成自己想要到的样子。 你好，2019","categories":[{"name":"一些话","slug":"一些话","permalink":"https://gxkord.github.io/categories/一些话/"}],"tags":[{"name":"年终总结","slug":"年终总结","permalink":"https://gxkord.github.io/tags/年终总结/"}]},{"title":"12. Integer to Roman(Medium)","slug":"算法/LeetCode/12. Integer to Roman(Medium)","date":"2018-12-17T11:12:23.000Z","updated":"2019-10-13T09:46:09.209Z","comments":true,"path":"2018/12/17/算法/LeetCode/12. Integer to Roman(Medium)/","link":"","permalink":"https://gxkord.github.io/2018/12/17/算法/LeetCode/12. Integer to Roman(Medium)/","excerpt":"","text":"题目描述原题 Description:Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M. Symbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, two is written as II in Roman numeral, just two one’s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used: I can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999. Example 1: Input: 3Output: “III” Example 2: Input: 4Output: “IV” Example 3: Input: 9Output: “IX” Example 4: Input: 58Output: “LVIII”Explanation: L = 50, V = 5, III = 3. Example 5: Input: 1994Output: “MCMXCIV”Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. 原题翻译 描述:罗马数字由七个不同的符号表示：I，V，X，L，C，D和M。 符号 值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 例1: 输入: 3输出: “III” 例2: 输入: 4输出: “IV” 例3: 输入: 9输出: “IX” 例4: 输入: 58输出: “LVIII”解释: L = 50, V = 5, III = 3. 例5: 输入: 1994输出: “MCMXCIV”解释: M = 1000, CM = 900, XC = 90， IV = 4. 解法一(Mine)主要思想对每一位上的数字分别处理，对个十百位上的4,9进行特殊处理。 运行速度：超过了100%的解答。 内存使用：超过了100%的解答。 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Solution &#123; public String intToRoman(int num) &#123; StringBuilder s = new StringBuilder(); int temp; // 千位 temp = num / 1000; while (temp &gt; 0) &#123; s.append(\"M\"); temp--; &#125; num %= 1000; // 百位 temp = num / 100; if(temp == 9) &#123; s.append(\"CM\"); &#125; else if (temp == 4) &#123; s.append(\"CD\"); &#125; else &#123; if (temp &gt;= 5) &#123; s.append(\"D\"); temp -= 5; &#125; while (temp &gt; 0) &#123; s.append(\"C\"); temp--; &#125; &#125; num %= 100; // 十位 temp = num / 10; if(temp == 9) &#123; s.append(\"XC\"); &#125; else if (temp == 4) &#123; s.append(\"XL\"); &#125; else &#123; if (temp &gt;= 5) &#123; s.append(\"L\"); temp -= 5; &#125; while (temp &gt; 0) &#123; s.append(\"X\"); temp--; &#125; &#125; num %= 10; // 个位 temp = num; if(temp == 9) &#123; s.append(\"IX\"); &#125; else if (temp == 4) &#123; s.append(\"IV\"); &#125; else &#123; if (temp &gt;= 5) &#123; s.append(\"V\"); temp -= 5; &#125; while (temp &gt; 0) &#123; s.append(\"I\"); temp--; &#125; &#125; return s.toString(); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Medium","slug":"LeetCode-Medium","permalink":"https://gxkord.github.io/tags/LeetCode-Medium/"}]},{"title":"11. Container With Most Water(Medium)","slug":"算法/LeetCode/11. Container With Most Water(Medium)","date":"2018-12-16T10:03:22.000Z","updated":"2019-10-13T10:12:43.852Z","comments":true,"path":"2018/12/16/算法/LeetCode/11. Container With Most Water(Medium)/","link":"","permalink":"https://gxkord.github.io/2018/12/16/算法/LeetCode/11. Container With Most Water(Medium)/","excerpt":"","text":"题目描述原题 Description: Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai).n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0).Find two lines, which together with x-axis forms a container, such that the container contains the most water. Note:You may not slant the container and n is at least 2. Example: Input: [1,8,6,2,5,4,8,3,7]Output: 49Explanation: Example_Explanation 原题翻译 描述: 给定n个非负整数a1，a2，…，an，其中每个表示坐标（i，ai）处的点。绘制n条垂直线，使得线i的两个端点位于（i，ai）和（i，0）。找到两条线，它们与x轴一起形成一个容器，这样容器就含有最多的水。 另外:不要倾斜容器，n至少为2。 例如: 输如: [1,8,6,2,5,4,8,3,7]输出: 49解释: 例子解释 解法一(Mine)主要思想得到可能出现的面积，求最大值。 运行速度：超过了16.18%的解答。 内存使用：超过了95.51%的解答。 源码1234567891011121314class Solution &#123; public int maxArea(int[] height) &#123; int result = 0; for (int i = 0; i &lt; height.length; i++) &#123; for (int j = i + 1; j &lt; height.length; j++) &#123; int temp = Math.min(height[i], height[j]); int r = temp * (j - i); if(r &gt; result) result = r; &#125; &#125; return result; &#125;&#125; 解法二主要思想仔细想想，解法一有什么问题？在本题的例子中，第一条线高度为1，如果按照第一种解法运行，右边界需要从左往右遍历，依次求面积进行比较。但事实上，容器的高是由最短的线决定的，容器的面积毫无疑问地随右边界的增加而增加。我们真的有必要求出每块面积进行比较吗？没错，这道题可以由一个标准的首尾指针法来解。 运行速度：超过了95.02%的解答。 内存使用：超过了100%的解答。 源码12345678910111213public class Solution &#123; public int maxArea(int[] height) &#123; int maxarea = 0, l = 0, r = height.length - 1; while (l &lt; r) &#123; maxarea = Math.max(maxarea, Math.min(height[l], height[r]) * (r - l)); if (height[l] &lt; height[r]) l++; else r--; &#125; return maxarea; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Medium","slug":"LeetCode-Medium","permalink":"https://gxkord.github.io/tags/LeetCode-Medium/"}]},{"title":"3. 垃圾收集器与内存分配策略","slug":"Java/JVM/《深入理解java虚拟机》第2版/3. 垃圾收集器与内存分配策略","date":"2018-12-14T12:22:12.000Z","updated":"2019-04-19T09:50:07.679Z","comments":true,"path":"2018/12/14/Java/JVM/《深入理解java虚拟机》第2版/3. 垃圾收集器与内存分配策略/","link":"","permalink":"https://gxkord.github.io/2018/12/14/Java/JVM/《深入理解java虚拟机》第2版/3. 垃圾收集器与内存分配策略/","excerpt":"","text":"概述垃圾收集（Garbage Collection, GC）的历史比Java久远。1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。 目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”时代，那为什么我们还要去了解GC和内存分配？ 当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，就需要对这些“自动化”的技术实施必要的监控和调节。 在Java内存区域中，程序计数器、虚拟机栈、本地方法栈3个区域是线程私有的；栈中的栈帧随方法的进入和退出执行出栈和入栈。这几个区域内不需要过多考虑回收的问题，方法和线程结束后，内存自然就跟随回收了。需要考虑如何回收内存的区域是Java堆和方法区。 对象已死吗堆中存放着Java世界中几乎所有的对象实例，垃圾处理器在对堆进行回收前，第一件事就是确定这些对象有没有“死去”？ 不能再被任何途径使用的对象，就成为了“死去”的对象。 引用计数算法很多教科书上判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。 客观来说，引用计数算法（Reference Counting）实现简单，判定效率也很高，但是，主流的Java虚拟机都没用采用它。主要原因是它无法解决对象之间的相互循环引用的问题。 如下面的代码： 1234567891011121314151617181920public class ReferenceCountingGC &#123; public Object instance = null; private static final int _1MB = 1024*1024; // 这个成员变量唯一意义就是让对象占更大的内存方便在GC日志里观察 private byte[] bigSize = new byte[2 * _1MB]; public static void testGC() &#123; ReferenceCountingGC objA = new ReferenceCountingGC(); ReferenceCountingGC objB = new ReferenceCountingGC(); objA.instance = objB; objB.instance = objA; objA = null; objB = null; // 假设这里发生GC，objA和objB是否能被回收 System.gc(); &#125;&#125; 显然，上述代码中，objA和objB互相引用，如果使用引用计数算法，这两个对象将无法被回收。 可达性分析算法在主流的商用程序语言的主流实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。这个算法的基本思路：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连的时，则证明此对象是不可用的。 可达性分析 在Java语言中，可作为GC Roots的对象包括以下几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI（即一般说的Native方法）引用的对象。 再谈引用无论通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判断对象是否存活都与“引用”有关。 在JDK1.2以前，Java中引用的定义很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表一个引用。 在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4种，这4种引用强度逐渐减弱。 强引用：在代码中普遍存在，比如：“Object obj = new Object();”。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 软引用：用来描述还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。JDK1.2之后，提供了SoftReference类来实现软引用。 弱引用：也是用来描述非必需对象，但强度比软引用更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前。JDK1.2之后，提供了WeakReference类来实现软引用。 虚引用：最弱的一种引用关系。设置虚引用的唯一目的是能在这个对象被收集器回收时收到一个系统通知。JDK1.2之后，提供了PhantomReference类来实现软引用。 生存还是死亡 “生存还是死亡这是个问题。” 既然如此，可达性分析算法中不可达的对象是不是“非死不可”？并不是！ 如果一个对象在进行可达性分析后发现没有与GC Roots相连的引用链，那它将会被第一次标记并且进行一次筛选。 筛选条件：是否有必要执行finalize()方法。当没有对象没有重写finalize()方法或者finalize()方法已经被虚拟机调用过，将被视为“没有必要执行”。 如果对象被判定为有必要执行finalize()方法，那么这个对象会被放置在一个叫做F-Queue的队列中，并稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行。 这里的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。如果一个的对象在finalize()方法中执行缓慢，或者进入了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永远处于等待，甚至导致整个内存回收系统崩溃。 finalize()方法是对象死亡前的最后“自救”机会。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 此代码演示了两点： * 1. 对象可以在被GC时自我拯救。 * 2. 这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次。 */public class FinalizeEscapeGC &#123; public static FinalizeEscapeGC SAVE_HOOK = null; public void isAlive() &#123; System.out.println(“yes, I am still alive”); &#125; @Override protected void finalize() throws Throwable &#123; super.finalize(); System.out.println(“finalize method executed!”); FinalizeEscapeGC.SAVE_HOOK = null; &#125; public static void main(String[] args) throws Throwable &#123; SAVE_HOOK = new FinalizeEscapeGC(); // 对象第一次成功自救 SAVE_HOOK = null; System.gc(); // 由于finalize方法优先级很低，所以暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.printn(“no, I am dead”); &#125; // 下面这段代码与上面的完全相同，但是这次自救却失败了 SAVE_HOOK = null; System.gc(); // 由于finalize方法优先级很低，所以暂停0.5秒以等待它 Thread.sleep(500); if (SAVE_HOOK != null) &#123; SAVE_HOOK.isAlive(); &#125; else &#123; System.out.printn(“no, I am dead”); &#125; &#125;&#125; 上述代码中，有两段完全一样的代码片段，这行结果却是一次逃脱成功，一次失败，这是因为任何一个对象的finalize()方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救失败了。 需要特别说明的是，上面关于对象死亡时finalize()方法的描述可能带有悲情的艺术色彩，但是本书作者建议尽量避免使用它。因为这是Java刚诞生时为了使C/C++程序员更容易接受它所做出的的妥协。它的运行代价极高，不确定性极大，无法保证各个对象的调用顺序。finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时。 回收方法区很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低。 永久代的垃圾回收主要回收两部分内容：废弃常量和无用的类。 回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String叫做“abc”，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这是发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。 判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要满足下面3个条件才能算是“无用的类”： 该类所有的实例都已经被回收。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述条件的无用类进行回收，但这仅仅是“可以”，是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product班的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。 在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁定义ClassLoader的场景中都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。 垃圾收集算法标记 - 清除算法最基础的收集算法是“标记-清除”（Mark-Sweep）算法，正如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 它的不足有两个：一是效率不高，二是清除后会产生大量不连续的内存碎片。 标记-清除算法 复制算法为了解决效率问题，“复制”（Copying）算法出现了。 它将可用内存按容量分为大小相等的两块，每次只使用其中的一块。当这块内存用完了，就将还存活的对象复制到另一块上面，然后将已使用过的内存空间一次清理掉。 复制算法1 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司专门的研究表明，新生代中对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例划分内存空间。而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1。 当然，我们并没有办法保证每次回收都有不多于10%的对象存活，当Survior空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保 （Handle Promotion）。 暂时利用做担保的内存来存放多余的对象。 复制算法2 标记-整理算法复制算法在对象存活率高时就要进行较多的复制，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所有老年代一般不能直接采用这种算法。 “标记-整理”（Mark-Compact）算法，其标记过程与“标记-清除”算法一样，后续则是让存活下来的对象都向一端移动，然后直接清除掉边界以外的内存。 标记-整理算法 分代收集算法当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法。一般把Java堆分成新生代和老年代。 在新生代中，每次垃圾收集时都会有大量对象死去，采用复制算法。 在老年代中，对象的存活率高，就必须使用“标记-清除”或者“标记-整理”算法。 HotSpot的算法实现上面两小节分别在理论上介绍了对象存活判定算法和垃圾收集算法，而在HotSpot虚拟机上实现这些算法时，必须对算法的执行效率有严格的考量，才能保证虚拟机高效运行。 枚举根节点从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots节点主要在全局性的引用（例如常量表或类静态属性）与执行上下文（栈帧中的本地变量表）中，如果逐个检查java堆和方法区的引用，必将消耗很多时间。 另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行。 这里的“一致性”是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况。Sun将这个快照称为“Stop The World”。 这点不满足的话，分析结果准确性就无法保证。这也是导致GC进行时必须停顿所有线程的重要原因之一。 目前的主流Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文对象和全局引用位置，虚拟机应当有办法直接得知那些地方存放着对象引用。在HotSpot的实现中，是使用一组OopMap的数据结构来达成的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中也会在特定位置记录下栈和寄存器中哪些位置是引用。 安全点在OopMap的帮助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每条指令都生成相应的OopMap，将需要大量额外空间，这样GC的空间成本就会非常高。 实际上，HotSpot也没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint）。 安全点的选定基本上以程序“是否具有让程序长时间执行的特征”为标准来选定的。“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。 对于Safepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（不包括执行JNI的线程）都“跑”到最近的安全点上再停顿下来。有两个解决方案：抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）。 抢先式中断不需要代码主动配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。 主动式中断的思想是当GC需要中断线程时，不直接对线程操作，仅仅设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。 安全区域使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却不一定。Safepoint机制保证了程序执行时，在不长的时间内就会遇到GC的Safepoint。而程序“不执行”的时候，就需要安全区域（Safe Region）来解决。 所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求。 安全区域是指在一段代码片段中，引用关系不会发生变化。在这个区域内的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的Safepoint。 在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。 垃圾收集器如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。没有最好的收集器，我们选择的只是具体应用最合适的收集器。 Serial收集器这是一个“单线程 ”的收集器。 “单线程”的意义并不仅仅说明它只会使用一个CPU或一个收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束 它优于其他收集器的地方：简单而高效（与其他收集器的单线程比）。 Serial收集器 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样。 ParNew收集器 除了Serial收集器之外，只有它能与CMS收集器配合工作。 CMS收集器（Concurrent Mark Sweep），这是第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户现场（基本上）同时工作。 ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百保证可以超越Serial收集器。 从ParNew开始，会接触几款并发和并行的收集器。在这里先解释一下这两个概念： 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行在另一个CPU上。 Parallel Scavenge收集器Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。 Parallel Scavenge收集器 Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。Parallel Scavenge收集器中提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的 –XX:MaxGCPauseMills 参数以及直接设置吞吐量大小的 –XX:GCTimeRatio 参数。 MaxGCPauseMills参数允许的值是一个大于0的毫秒数，收集器则尽可能保证内存回收花费的时间不超过设定值。不过，并不是将这个参数设置的越小越好，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的。 GCTimeRatio参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。 Parallel Scavenge还有一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。自适应调节也是Parallel Scabenge收集器与ParNew收集器的一个重要区别。 Serial Old收集器Serial Old收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurret Mode Failure时使用。它的工作过程与Serial收集器相同。 Serial Old收集器 Parallel Old收集器Parallel Old 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在JDK1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于“比较尴尬”的状态。 原因：如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？）。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。 直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合。 它的工作过程与Parallel Scavenge收集器相同。 Parallel Old收集器 CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。CMS收集器是基于“标记-清除”算法实现的，它的运行过程较为复杂，整个过程分为4个步骤： 初始标记（CMS initial mark） 并发标记（CMS concurrent mark） 重新标记（CMS mark） 并发清除（CMS concurrent sweep） 其中，初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体来说，CMS收集器的回收过程是与用户线程一起并发执行的。 CMS收集器 但是CMS还远达不到完美的程度，它有以下3个明显的缺点： 对CPU资源非常敏感。 无法处理浮动垃圾（Floating Garbage），可能出现“Concurrent Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记之后，CMS无法在当次收集中处理它们，只好留待下一次GC时再清理掉。这部分垃圾就称为“浮动垃圾”。 “标记-清除”算法收集结束时会产生大量空间碎片。当空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认开启），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程。内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。还有另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认为0，表示每次进入Full GC时都进行碎片整理）。 G1收集器G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一。G1是面向服务器端应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点： 并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。 空间整合：G1从整体上来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）来看是基于“复制”算法实现的。但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。 可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。 在G1之前的其他收集器进行收集的范围都是整个新生代或者老生代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老生代的概念，但新生代和老生代不再是物理隔离了，它们都是一部分Region（不需要连续）的集合。 G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值问题（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以获得尽可能高的收集效率。 G1把内存“化整为零”的思路，理解起来似乎很容易，但其中的实现细节并不简单。以其中一个细节为例：把Java堆分成多个Region后，垃圾收集是否就真的能以Region为单位进行了？听起来顺理成章，但仔细想想：Region不可能是孤立的。一个对象分配在某个Region中，它并非只能被本Region中的其他对象引用，而是可以与整个Java堆任意的对象发生引用关系。那在做可达性判定确认对象是否存活的时候，岂不是还得扫描整个Java堆才能保证准确性？这个问题并非在G1中才有，只是在G1中更为突出。 在G1收集器中，Region之间的对象引用以及其他收集器中的新生代与老生代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1中每个Region都有一个与之对应的Rememered Set，虚拟机发现程序在对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中。当进行内存回收时，在GC根节点的枚举范围中加入Remebered Set即可保证不对全堆扫描也不会有遗漏。 如果不计算维护Remembered Set的操作，G1收集器的运作大致可划分为以下几个步骤： 初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。 并发标记（Concurrent Marking）：从GC Root开始对堆内对象进行可达性分析，找出存活对象，这阶段耗时较长，但可与用户程序并发执行。 最终标记（Final Marking）：为了修正在并发标记时期因用户程序继续运行而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。 筛选回收（Live Data Counting and Evacuation）：首先对各个Region回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。 理解GC日志以下为两段典型的GC日志： 33.125: [GC [DefNew: 3324K-&gt;152K(3712K), 0.0025925 secs] 3324K-&gt;152K(11904K), 0.0031680 secs] 100.667: [Full GC [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(10456K), [Parm : 2999K-&gt;2999K(21248K)], 0.0150007 secs] [Times : user=0.01 sys=0.00, real=0.02 secs] 最前面的数字“33.125”和“100.667”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。 GC日志开头的“[GC”和“[Full GC”说明了这次垃圾回收的停顿类型，而不是用来区分新生代GC还是老生代GC的。如果有“Full”，说明这次GC是发生Stop-The-World的，如果调用System.GC()方法所触发的收集，那么在这里将会显示“[Full GC(System)”。 接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名与使用的GC收集器是密切相关的，例如上面样例使用的Serial收集器中的新生代名，为“Default New Generation” ，所以显示的是“[DefNew”。如果是ParNew收集器，新生代名称就会变成“[ParNew”，意为“Parallel New Generation”。如果采用Parallel Scavenge收集器，那它配套的新生代称为“PSYoungGen”，老年代和永久代同理，名称也是由收集器决定的。 方括号内部的“3324K-&gt;152K(3712K)”含义是“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-&gt;152K(11904K)”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）”。 “0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。 内存分配与回收策略内存的分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并间接地栈上分配），对象分配的规则不是百分百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。 以下是几条最普遍的内存分配规则。 对象优先在Eden分配大多数情况下，对象会在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。 Minor GC和Full GC有什么不一样？ 新生代GC(Minor GC）：指发生在新生代中的垃圾回收动作，因为Java对象大多具备朝生夕灭的特性，所以Minor GC分成频繁，一般回收速度也比较快。 老生代GC(Major GC/Full GC)：指发生在老生代中的GC，出现了Major GC经常伴随至少一次的Minor GC(并非绝对，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。Major GC的速度一般会比Minor GC慢10倍以上。 123456789101112private static final int _1MB = 1024 * 1024;/** * VM参数：-verbose:gc –Xms20M –Xmx20M –Xmn10M * –XX:+PrintGCDetails –XX:SurvivorRatio=8 */public static void testAllocation() &#123; byte[] allocation1, allocation2, allocation3, allocation4; allocation1 = new byte[2 * _1MB]; allocation2 = new byte[2 * _1MB]; allocation3 = new byte[2 * _1MB]; allocation4 = new byte[4 * _1MB]; //出现一次MinorGC&#125; 运行结果：[GC [DefNew: 6487K-&gt;194K(9216K), 0.0042856 secs] 6487K-&gt;6338K(19456K), 0.0043281 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]Heap def new generation total 9216K, used 4326K [0x029d0000, 0x033d0000, 0x033d0000) eden space 8192K, 51% used [0x029d0000, 0x02de4828, 0x031d0000) from space 1024K, 14% used [0x032d0000, 0x032f5370, 0x033d0000) to space 1024K, 0% used [0x031d0000, 0x031d0000, 0x032d0000) tenured generation total 10240K, used 6144K [0x033d0000, 0x03dd0000, 0x03dd0000) the space 10240K, 60% used [0x033d0000, 0x039d0030, 0x039d0200, 0x03dd0000) compacting perm gen total 21248K, used 2982K [0x03dd0000, 0x049d0000, 0x07dd0000) the space 12288K, 17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000)No shared spaces configured. 虚拟机提供了–XX:+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。 上述代码的testAllocation()中分配allocation4对象的语句时，会发生一次Minor GC，这次GC的结果是新生代6652KB变为148KB，而总内存占用量几乎不变（因为allocation1-3均存活，虚拟机几乎没有找到可回收的对象）。这次GC发生的原因是给allocation4分配内存的时候，发现Eden已经被占用6MB，剩余空间已不足以分配allocation4所需的4MB。GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。 大对象直接进入老生代所谓大对象是指，需要大量连续内存空间的Java对象，最经典的大对象就是那种很长的字符串以及数组。大对象对于虚拟机内存分配来说是个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。 对于虚拟机来说，比遇到大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序使请尽量避免。 虚拟机提供了-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接进入老生代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。 12345678910private static final int _1MB = 1024 * 1024;/** * VM参数：-verbose:gc –Xms20M -Xmx20M -Xmn10M * -XX:+PrintGCDetails –XX:SurvivorRatio=8 * -XX:PretenureSizeThreshold=3145728 */public static void testPretenureSizeThreshold() &#123; byte[] allocation; allocation = new byte[4 * _1MB]; //直接分配在老生代&#125; 运行结果：Heap def new generation total 9216K, used 671K [0x029d0000, 0x023d0000, 0x033d0000) eden space 8192K, 8% used [0x029d0000, 0x02a77e98, 0x031d0000) from space 1024K, 0% used [0x031d0000, 0x031d0000, 0x032d0000) to space 1024K, 0% used [0x032d0000, 0x032d0000, 0x033d0000) tenured generation total 10240K, used 4096K [0x033d0000, 0x03dd0000, 0x03dd0000) the space 10240K, 40% used [0x033d0000, 0x037d0010, 0x037d0200, 0x03dd0000) compacting perm gen total 12288K, used 2107K [0x03dd0000, 0x049d0000, 0x07dd0000) the space 12288K, 17% used [0x03dd0000, 0x03fdefd0, 0x03fdf000, 0x049d0000)No shared spaces configured. 因为allocation对象超过了3MB，直接在老分代中分配。 长期存活的对象将进入老年代虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Servivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升老年代的年龄阙值，可以通过参数-XX:MaxTenuringThreshold设置。 你可以尝试分别以-XX:MaxTenuringThreshold=1 和 -XX:MaxTenuringThreshold=15两种设置来执行testTenuringThreshold()方法，此方法中的allocation1对象需要256KB内存，Survivor空间可以容纳。当MaxTenuringThreshold=1时，allocation1对象在第二次GC发生时进入老年代，新生代已使用的内存GC后非常干净地变成0KB。而MaxTenuringThreshold=15时，第二次GC发生后，allocation1对象则还留在新生代Survivor空间，这时新生代仍然有404KB占用。 12345678910111213private static final int _1MB = 1024 * 1024;/** * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails * -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=1 */@SuppressWarnings(\"unused\")public static void testTenuringThreshold() &#123; byte[] allocation1, allocation2, allocation3; allocation1 = new byte[_1MB / 4]; // 什么时候进入老年代取决于 XX:MaxTenuringThreshold设置 allocation2 = new byte[4 * _1MB]; allocation3 = new byte[4 * _1MB];&#125; 以MaxTenuringThreshold=1参数来运行的结果：[GC (Allocation Failure) [DefNewDesired survivor size 524288 bytes, new threshold 1 (max 1)-age 1: 414664 bytes, 414664 total: 4859K-&gt;404K(9216K), 0.0065012 secs] 4859K-&gt;4500K(19456K), 0.0065283 secs] [Times: user=0.00 sys=0.00, real=0.02 secs][GC (Allocation Failure) [DefNewDesired survivor size 524288 bytes, new threshold 1 (max 1)4500K-&gt;0K(9216K), 0.0009253 secs] 8596K-&gt;4500K(19456K), 0.0009458 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]Heap def new generation total 9216K, used 4178K [0x029d0000, 0x033d0000, 0x033d0000) eden space 8192K, 51% used [0x029d0000, 0x02de4828, 0x031d0000) from space 1024K, 0% used [0x031d0000, 0x031d0000, 0x032d0000) to space 1024K, 0% used [0x032d0000, 0x032d0000, 0x033d0000) tenured generation total 10240K, used 4500K [0x033d0000, 0x03dd0000, 0x07dd0000) the space 10240K, 43% used [0x033d0000, 0x03835348, 0x03835400, 0x03dd0000) compacting perm gen total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000) the space 12288K, 17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000]No shared spaces configured.以MaxTenuringThreshold=15参数来运行的结果：[GC (Allocation Failure) [DefNewDesired survivor size 524288 bytes, new threshold 15 (max 15)-age 1: 414664 bytes, 414664 total: 4859K-&gt;404K(9216K), 0.0049637 secs] 4859K-&gt;4500K(19456K), 0.0049932 secs] [Times: user=0.00 sys=0.00, real=0.00 secs][GC (Allocation Failure) [DefNewDesired survivor size 524288 bytes, new threshold 15 (max 15)-age 2: 414520 bytes, 414520 total4500K-&gt;404K(9216K), 0.0008091 secs] 8596K-&gt;4500K(19456K), 0.0008305 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]Heap def new generation total 9216K, used 4582K [0x029d0000, 0x033d0000, 0x033d0000) eden space 8192K, 51% used [0x029d0000, 0x02de4828, 0x031d0000) from space 1024K, 39% used [0x031d0000, 0x032335338, 0x032d0000) to space 1024K, 0% used [0x032d0000, 0x032d0000, 0x033d0000) tenured generation total 10240K, used 4096K [0x033d0000, 0x03dd0000, 0x03dd0000) the space 10240K, 40% used [0x033d0000, 0x037d0010, 0x037d0200, 0x03dd0000) compacting perm gen total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000) the space 12288K, 17% used [0x03dd0000, 0x03fe0998, 0x03fe0a00, 0x049d0000]No shared spaces configured.动态对象年龄判定为了更好地适应不同程序的内存情况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。 1234567891011121314151617private static final int _1MB = 1024 * 1024;/** * VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 * -XX:+PrintTenuringDistribution */@SuppressWarnings(\"unused\")public static void testTenuringThreshold2() &#123; byte[] allocation1, allocation2, allocation3, allocation4; allocation1 = new byte[_1MB / 4]; // allocation1 + allocation2大于Survivor空间一半 allocation2 = new byte[_1MB / 4]; allocation3 = new byte[4 * _1MB]; allocation4 = new byte[4 * _1MB]; allocation4 = null; allocation4 = new byte[4 * _1MB];&#125; 运行结果：[GC [DefNewDesired Survivor size 524288 bytes, new threshold 1 (max 15)-age 1: 676824 bytes, 676824 total: 5115K-&gt;660K(9216K), 0.0050136 secs] 5115K-&gt;4756K(19456K), 0.0050443 secs] [Times: user=0.00 sys=0.01, real=0.01 secs][GC [DefNewDesired Survivor size 524288 bytes, new threshold 15 (max 15)4756K-&gt;0K(9216K), 0.0010571 secs] 8852K-&gt;4756K(19456K), 0.0011009 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]Heap def new generation total 9216K, used 4178K [0x029d0000, 0x033d0000, 0x033d0000) eden space 8192K, 51% used [0x029d0000, 0x02de4828, 0x031d0000) from space 1024K, 0% used [0x031d0000, 0x031d0000, 0x032d0000) to space 1024K, 0% used [0x032d0000, 0x032d0000, 0x033d0000) tenured generation total 10240K, used 4756K [0x033d0000, 0x03dd0000, 0x03dd0000) the space 10240K, 46% used [0x033d0000, 0x038753e8, 0x03875400, 0x03dd0000) compacting perm gen total 12288K, used 2114K [0x03dd0000, 0x049d0000, 0x07dd0000) the space 12288K, 17% used [0x03dd0000, 0x03fe09a0, 0x03fe0a00, 0x049d0000)No shared spaces configured.在testTenuringThreshold2()方法中，设置-XX:MaxTenuringThreshold=15，会发现运行结果中Survivor的空间仍然为0%，而老年代比预期增加60%，也就是说，allocation1、allocation2对象都直接进入了老年代，而没有等到15岁的临界年龄。因为这两个对象加起来已经到达了512KB，并且它们是同年的，满足同年对象达到Survivor空间的一半规则。我们只要注释掉其中一个对象new操作，就会发现另外一个就不会晋升到老年代中去了。 空间分配担保在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。 “冒险”是冒了什么风险？前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。而老年代进行这样的担保，前期是老年代本身还有容纳这些对象的剩余空间，一个有多少对象会存活下来在实际完成内存回收之前是无法明确知道的，所有只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。 取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure开关打开，避免Full GC过于频繁。（参见以下代码，请在JDK6 Update24之前的版本中运行测试。） 1234567891011121314151617181920private static final int _1MB = 1024 * 1024;/** * VM参数：-Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8 -XX:-HandlePromotionFailure */@SuppressWarnings(\"unused\")public static void testHandlePromotion() &#123; byte[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6, allocation7; allocation1 = new byte[2 * _1MB]; allocation2 = new byte[2 * _1MB]; allocation3 = new byte[2 * _1MB]; allocation1 = null; allocation4 = new byte[2 * _1MB]; allocation5 = new byte[2 * _1MB]; allocation6 = new byte[2 * _1MB]; allocation4 = null; allocation5 = null; allocation6 = null; allocation7 = new byte[2 * _1MB];&#125; 以HandlePromotionFailure=false参数来运行的结果：[GC [DefNew: 6651K-&gt;148K(9216K), 0.0078936 secs] 6651K-&gt;4244K(19456K), 0.0079192 secs] [Times: user=0.00 sys=0.02, real=0.02 secs][GC [DefNew: 6378K-&gt;6378K(9216K), 0.0000206 secs][Tenured: 4096K-&gt;4244K(10240K), 0.0042901 secs] 10474K-&gt;4244K(19456K), [Perm : 2104K-&gt;2104K(12288K)], 0.0043613 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 以HandlePromotionFailure = true参数来运行的结果：[GC [DefNew: 6651K-&gt;148K(9216K), 0.0054913 secs] 6651K-&gt;4244K(19456K), 0.0055327 secs] [Times: user=0.00 sys=0.00, real=0.00 secs][GC [DefNew: 6378K-&gt;148K(9216K), 0.0006584 secs] 10474K-&gt;4244K(19456K), 0.0006857 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 在JDK 6 Update 24之后，这个测试结果会有差异，HandlePromotionFailure不会影响到虚拟机空间分配担保策略，观察OpenJDK中的源码变化： 12345678910bool TenuredGeneration::promotion_attempt_is_safe(size_tmax_promotion_in_bytes) const&#123; // 老年代最大可用的连续空间 size_t available = max_contiguous_available(); // 每次晋升到老年代的平均大小 size_t av_promo = (size_t) gc_stats()-&gt;avg_promoted()-&gt;padded_average(); // 老年代可用空间是否大于平均晋升大小，或者老年代可用空间是否大于当此GC时新生代所有对象容量 bool res = (available &gt;= av_promo) || (available &gt;= max_promotion_in_bytes); return res;&#125; 虽然源码中还定义了HandlePromotionFailure参数，但是在代码中已经不会再使用它。JDK 6 Update 24之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。","categories":[{"name":"Java","slug":"Java","permalink":"https://gxkord.github.io/categories/Java/"}],"tags":[{"name":"《深入理解Java虚拟机》","slug":"《深入理解Java虚拟机》","permalink":"https://gxkord.github.io/tags/《深入理解Java虚拟机》/"},{"name":"第二部分 自动内存管理机制","slug":"第二部分-自动内存管理机制","permalink":"https://gxkord.github.io/tags/第二部分-自动内存管理机制/"},{"name":"JVM","slug":"JVM","permalink":"https://gxkord.github.io/tags/JVM/"}]},{"title":"10. Regular Expression Matching(Hard)","slug":"算法/LeetCode/10. Regular Expression Matching(Hard)","date":"2018-12-13T11:11:22.000Z","updated":"2019-10-13T10:13:00.128Z","comments":true,"path":"2018/12/13/算法/LeetCode/10. Regular Expression Matching(Hard)/","link":"","permalink":"https://gxkord.github.io/2018/12/13/算法/LeetCode/10. Regular Expression Matching(Hard)/","excerpt":"","text":"题目描述原题 Description:Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘‘.‘.’ Matches any single character.‘‘ Matches zero or more of the preceding element.The matching should cover the entire input string (not partial). Note:s could be empty and contains only lowercase letters a-z.p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1: Input: s = “aa”p = “a” Output: falseExplanation: “a” does not match the entire string “aa”. Example 2: Input: s = “aa”p = “a*” Output: trueExplanation: ‘*’ means zero or more of the precedeng element, ‘a’. Therefore, by repeating ‘a’ once, it becomes “aa”. Example 3: Input: s = “ab”p = “.*” Output: trueExplanation: “.*” means “zero or more (*) of any character (.)”. Example 4: Input: s = “aab”p = “cab” Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches “aab”. Example 5: Input: s = “mississippi”p = “misis*p.” Output: false 原题翻译 描述:给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘‘ 的正则表达式匹配。‘.’ 匹配任意单个字符。‘‘ 匹配零个或多个前面的元素。匹配应该覆盖整个字符串 (s) ，而不是部分字符串。 另外:s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 例1: 输入: s = “aa”p = “a” 输出: false解释: “a” 无法匹配 “aa” 整个字符串。 例2: 输入: s = “aa”p = “a*” 输出: true解释: ‘*’ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 一次, 字符串可变为 “aa”。 例3: 输入: s = “ab”p = “.*” 输出: true解释: “.*” 表示可匹配零个或多个(‘*’)任意字符(‘.’)。 例4: 输入: s = “aab”p = “cab” 输出: true解释: ‘c’ 可以不被重复, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。 例5: 输入: s = “mississippi”p = “misis*p.” 输出: false 解法一主要思想递归地判断当前位置是否匹配。 运行速度：超过了14.44%的解答。 内存使用：超过了35.35%的解答。 源码123456789101112131415161718192021public class Solution &#123; public boolean isMatch(String s, String p) &#123; if (p.isEmpty()) //保证p非空 return s.isEmpty(); //第0个字符是否匹配 boolean first_match = (!s.isEmpty() &amp;&amp; (p.charAt(0) == s.charAt(0) || p.charAt(0) == '.')); //p下一个字符是不是* if (p.length() &gt;= 2 &amp;&amp; p.charAt(1) == '*') &#123; /** * 如果是，两种情况： * 1. 前面第0个字符出现0次，再比较s和p[2~]的 * 2. p[0]这个字符可能重复了一次或一次以上，比较s[1~]和p */ return (isMatch(s, p.substring(2)) || (first_match &amp;&amp; isMatch(s.substring(1), p))); &#125; else &#123; //如果不是，递归s和p后面的字符 return first_match &amp;&amp; isMatch(s.substring(1), p.substring(1)); &#125; &#125;&#125; 解法二主要思想动态规划：自顶向下。 运行速度：超过了96.25%的解答。 内存使用：超过了100%的解答。 源码123456789101112131415161718192021222324252627public class Solution &#123; Boolean[][] memo; public boolean isMatch(String s, String p) &#123; memo = new Boolean[s.length() + 1][p.length() + 1]; return dp(0, 0, s, p); &#125; public boolean dp(int i, int j, String s, String p) &#123; if (memo[i][j] != null) &#123; return memo[i][j]; &#125; if (j == p.length()) &#123; memo[i][j] = i == s.length(); &#125; else &#123; //s[i]和p[j]是否匹配 boolean first_match = (i &lt; s.length() &amp;&amp; (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.')); if (j + 1 &lt; p.length() &amp;&amp; p.charAt(j+1) == '*') &#123; memo[i][j] = (dp(i, j+2, s, p) || first_match &amp;&amp; dp(i+1, j, s, p)); &#125; else &#123; memo[i][j] = first_match &amp;&amp; dp(i+1, j+1, s, p); &#125; &#125; return memo[i][j]; &#125;&#125; 解法三主要思想动态规划：自下向上。 运行速度：超过了49.75%的解答。 内存使用：超过了100%的解答。 源码1234567891011121314151617181920public class Solution &#123; public boolean isMatch(String s, String p) &#123; boolean[][] dp = new boolean[s.length() + 1][p.length() + 1]; dp[s.length()][p.length()] = true; for (int i = s.length(); i &gt;= 0; i--)&#123; for (int j = p.length() - 1; j &gt;= 0; j--)&#123; //s[i]和p[j]是否匹配 boolean first_match = (i &lt; s.length() &amp;&amp; (p.charAt(j) == s.charAt(i) || p.charAt(j) == '.')); if (j + 1 &lt; p.length() &amp;&amp; p.charAt(j+1) == '*')&#123; dp[i][j] = dp[i][j+2] || first_match &amp;&amp; dp[i+1][j]; &#125; else &#123; dp[i][j] = first_match &amp;&amp; dp[i+1][j+1]; &#125; &#125; &#125; return dp[0][0]; &#125;&#125; 解法四主要思想 如果p.charAt(j) == s.charAt(i)，那么dp[i][j] = dp[i-1][j-1]; 如果p.charAt(j) == ‘.’ ，那么dp[i][j] = dp[i-1][j-1]; 如果p.charAt(j) == ‘*’， (1) 如果p.charAt(j-1) != s.charAt(i)，那么 1dp[i][j] = dp[i][j-2] // a*表示空（0个a） (2) 如果p.charAt(i-1) == s.charAt(i) 或者 p.charAt(i-1) == ‘.’，那么 123 dp[i][j] = dp[i-1][j] // a*表示多个ass|| dp[i][j] = dp[i][j-1] // a*表示一个a|| dp[i][j] = dp[i][j-2] // a*表示空 运行速度：超过了49.75%的解答。 内存使用：超过了100%的解答。 源码1234567891011121314151617181920212223242526272829303132public class Solution &#123; public boolean isMatch(String s, String p) &#123; if (s == null || p == null) &#123; return false; &#125; boolean[][] dp = new boolean[s.length()+1][p.length()+1]; dp[0][0] = true; for (int i = 0; i &lt; p.length(); i++) &#123; if (p.charAt(i) == '*' &amp;&amp; dp[0][i-1]) &#123; dp[0][i+1] = true; &#125; &#125; for (int i = 0 ; i &lt; s.length(); i++) &#123; for (int j = 0; j &lt; p.length(); j++) &#123; if (p.charAt(j) == '.') &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == s.charAt(i)) &#123; dp[i+1][j+1] = dp[i][j]; &#125; if (p.charAt(j) == '*') &#123; if (p.charAt(j-1) != s.charAt(i) &amp;&amp; p.charAt(j-1) != '.') &#123; dp[i+1][j+1] = dp[i+1][j-1]; &#125; else &#123; dp[i+1][j+1] = (dp[i+1][j] || dp[i][j+1] || dp[i+1][j-1]); &#125; &#125; &#125; &#125; return dp[s.length()][p.length()]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Hard","slug":"LeetCode-Hard","permalink":"https://gxkord.github.io/tags/LeetCode-Hard/"}]},{"title":"9. Palindrome Number(Easy)","slug":"算法/LeetCode/9. Palindrome Number(Easy)","date":"2018-12-12T13:12:02.000Z","updated":"2019-10-13T09:36:33.023Z","comments":true,"path":"2018/12/12/算法/LeetCode/9. Palindrome Number(Easy)/","link":"","permalink":"https://gxkord.github.io/2018/12/12/算法/LeetCode/9. Palindrome Number(Easy)/","excerpt":"","text":"题目描述原题 Description:Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121Output: true Example 2: Input: -121Output: falseExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10Output: falseExplanation: Reads 01 from right to left. Therefore it is not a palindrome. Follow up:Could you solve it without converting the integer to a string? 原题翻译原题 描述:确定整数是否是回文。当它向前读取向后时，整数是回文。 例1: 输入: 121输出: true 例2: 输入: -121输出: false解释: 从左到右读取它，为-121。从右到左读取它，为121-。因此它不是回文。 例3: 输入: 10输出: false解释: 从左到右读取它，为10。从右到左读取它，为01。因此它不是回文。 提升:你可以不将整数转换为字符串解决它吗？ 解法一主要思想把x倒置，再与x比较即可。 运行速度：超过了100%的解答。 内存使用：超过了5.02%的解答。 源码123456789101112public class Solution &#123; public boolean isPalindrome(int x) &#123; if(x &lt; 0) return false; int a = 0, b = x; while(b != 0) &#123; a = a * 10 + b % 10; b /= 10; &#125; return a == x; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Easy","slug":"LeetCode-Easy","permalink":"https://gxkord.github.io/tags/LeetCode-Easy/"}]},{"title":"7. 着色器","slug":"JavaScript/Three.js/7. 着色器","date":"2018-12-11T13:33:02.000Z","updated":"2019-04-19T10:00:05.174Z","comments":true,"path":"2018/12/11/JavaScript/Three.js/7. 着色器/","link":"","permalink":"https://gxkord.github.io/2018/12/11/JavaScript/Three.js/7. 着色器/","excerpt":"","text":"定义渲染（Rendering）就是指将你做的模型数据呈现在屏幕上的过程。 着色器（Shader）就是屏幕上呈现画面之前的最后一步。它可以用来对先前渲染结果做修改，包括对颜色、位置等等信息的修改，甚至可以对先前渲染的结果做后处理，实现高级的渲染效果。 分类着色器通常分为：几何着色器（Geometry Shader）、顶点着色器（Vertex Shader）、片元着色器（Fragment Shader）等。 由于WebGL是基于OpenGL ES 2.0的，所以，它只支持 顶点着色器 和 片元着色器。 顶点着色器“顶点”指的是Mesh中的顶点，对于每个顶点调用一次。 可以修改顶点的位置或颜色等信息，然后传入片元着色器。 片元着色器“片元”是由给定的”顶点”计算后得到的图形里所有的点组成的。 片元着色器特别适合用来做图像后处理。 Three.js与着色器有上述描述可以看出，并不是在所有应用中都需要着色器。 但是WebGL要求程序编写者必须定义着色器（即使你只希望使用默认的渲染方法）。对于不了解图形学的开发者来说，这并不容易。 对此，Three.js友好地允许了不定义着色器，即采用默认的方法渲染。 着色器限定符(Qualifier) const：常量 uniform：它表示每个顶点/片元对应相同的值。(比如，一个点光源的位置。)既可以传入顶点着色器，也可以传入片元着色器。 attribute：从js代码传递到顶点着色器中，每个顶点可以对应不同的值。(比如每个顶点都具有一个颜色。)attribute变量和顶点的关系是一一对应的。 varying：从顶点着色器中定义，传入给片元着色器的变量。 为了确保这点，我们需要确保在两个着色器中变量的类型和命名完全一致。 一个经典的应用是法线向量，因为在计算光照的时候需要用到法线。 HelloWorld着色器简单创建示例**注意：首先，着色器是一段在GPU中执行的接近C语言的代码，它需要main方法！！ 123456789101112131415161718192021/** * Example：一个最简单的顶点着色器。 * 每个顶点坐标乘以模型视图矩阵在乘以投影矩阵 * 获得在二维屏幕上的坐标 */ void main() &#123; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); &#125;/** * Example：一个最简单的片元着色器。 * 将任意一个像元色设置为粉红（注意颜色参数为float类型，即需要使用0.0） */ void main() &#123; gl_FragColor = vec4( 1.0, // R 0.0, // G 1.0, // B 1.0 // A );&#125; 在HTML中使用着色器 着色器创建代码可以写在单独的文件中（顶点着色器后缀为.vs；片元着色器后缀为.fs） 使用Ajax完成文件的导入（这里使用了JQuery的get()方法）。 12345678910//导入shader$.get('shader/my.vs', function(vShader)&#123; $.get('shader/my.fs', function(fShader)&#123; //把顶点和片元传入材质 meterial = new THREE.ShaderMeterial(&#123; vertexShader: vShader, fragmentShader: fShader &#125;); &#125;);&#125;); 也可以在HTML文件中使用script标签创建着色器 123456789101112&lt;script id=\"vs\" type=\"x-shader/x-vertex\"&gt;//这里的内容相当于.vs中的内容(顶点着色器)&lt;/script&gt;&lt;script id=\"fs\" type=\"x-shader/x-fragment\"&gt;//这里的内容相当于.fs中的内容(片元着色器)&lt;/script&gt;//材质定义meterial = new THREE.ShaderMeterial(&#123; vertexShader: document.getElementById('vs').textContent, fragementShader: document.getElementById('fs').textContent&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gxkord.github.io/categories/JavaScript/"}],"tags":[{"name":"3D","slug":"3D","permalink":"https://gxkord.github.io/tags/3D/"},{"name":"WebGL","slug":"WebGL","permalink":"https://gxkord.github.io/tags/WebGL/"},{"name":"Three.js入门","slug":"Three-js入门","permalink":"https://gxkord.github.io/tags/Three-js入门/"}]},{"title":"8. String to Integer(atoi)(Medium)","slug":"算法/LeetCode/8. String to Integer(atoi)(Medium)","date":"2018-12-11T12:12:02.000Z","updated":"2019-10-13T09:35:20.723Z","comments":true,"path":"2018/12/11/算法/LeetCode/8. String to Integer(atoi)(Medium)/","link":"","permalink":"https://gxkord.github.io/2018/12/11/算法/LeetCode/8. String to Integer(atoi)(Medium)/","excerpt":"","text":"题目描述原题 Description:Implement atoi which converts a string to an integer. The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value. The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function. If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed. If no valid conversion could be performed, a zero value is returned. Note:Only the space character ‘ ‘ is considered as whitespace character. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^(31), 2^(31) − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^(31) − 1) or INT_MIN (−2^(31)) is returned. Example 1: Input: “42”Output: 42 Example 2: Input: “ -42”Output: -42Explanation: The first non-whitespace character is ‘-‘, which is the minus sign.Then take as many numerical digits as possible, which gets 42. Example 3: Input: “4193 with words”Output: 4193Explanation: Conversion stops at digit ‘3’ as the next character is not a numerical digit. Example 4: Input: “words and 987”Output: 0Explanation: The first non-whitespace character is ‘w’, which is not a numericaldigit or a +/- sign. Therefore no valid conversion could be performed. Example 5: Input: “-91283472332”Output: -2147483648Explanation: The number “-91283472332” is out of the range of a 32-bit signed integer.Thefore INT_MIN (−2^(31)) is returned. 原题翻译 Description:实现将字符串转换为整数的atoi。 该函数首先丢弃所需数量的空白字符，直到找到第一个非空白字符。 然后，从该字符开始，采用可选的初始加号或减号，后跟尽可能多的数字，并将它们解释为数值。 字符串可以包含在形成整数之后的其他字符，这些字符将被忽略并且对此函数的行为没有影响。 如果str中的第一个非空白字符序列不是有效的整数，或者由于str是空的或者只包含空白字符而不存在这样的序列，则不执行转换。 如果无法执行有效转换，则返回零值。 Note:只有空格字符’ ‘被视为空格字符。 假设我们正在处理一个只能在32位有符号整数范围内存储整数的环境：[-2^(31), 2^(31) - 1]。 如果数值超出可表示值的范围，则返回INT_MAX（2^(31)-1）或INT_MIN（-2^(31)）。 例1: 输入: “42”输出: 42 例2: 输入: “ -42”输出: -42解释: 第一个非空白字符是’ - ‘，这是减号。然后取尽可能多的数字，得到42。 Example 3: Input: “4193 with words”Output: 4193Explanation: 转换在数字’3’处停止，因为下一个字符不是数字。 Example 4: Input: “words and 987”Output: 0Explanation: 第一个非空白字符是’w’，它不是数字或+/-符号。因此，无法执行有效的转换。 Example 5: Input: “-91283472332”Output: -2147483648Explanation: 数字“-91283472332”超出32位有符号整数的范围。返回INT_MIN（-2^(31)）之前。 解法一(mine) 运行速度：超过了100%的解答。 内存使用：超过了100%的解答。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public int myAtoi(String str) &#123; if (str.equals(\"\")) return 0; char[] chars = str.toCharArray(); int len = chars.length; int result = 0; int i = 0; while (i != len - 1 &amp;&amp; (chars[i] == '\\0' || chars[i] == ' ')) &#123; ++i; &#125; boolean flag = true; //结果是否为正 if (i == len) return 0; if (chars[i] == '-') &#123; flag = false; ++i; &#125; else if (chars[i] == '+') &#123; ++i; &#125; while (i &lt; chars.length &amp;&amp; chars[i] != '\\0' &amp;&amp; chars[i] != ' ') &#123; if (chars[i] &gt;= '0' &amp;&amp; chars[i] &lt;= '9') &#123; // 验证是否超过int的最大值 int now = chars[i] - '0'; int temp = result * 10 + now; if ((temp &gt; 0 &amp;&amp; result &lt; 0) || (temp &lt; 0 &amp;&amp; result &gt; 0) || result != (temp - now) / 10) &#123; if (flag) &#123; return Integer.MAX_VALUE; &#125; else &#123; return Integer.MIN_VALUE; &#125; &#125; result = temp; &#125; else &#123; break; &#125; ++i; &#125; if (flag) &#123; return result; &#125; else &#123; return -result; &#125; &#125;&#125; 解法二 第一名答案 运行速度：超过了100%的解答。 内存使用：超过了100%的解答。 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public int myAtoi(String str) &#123; if (str == null) return 0; str = str.trim(); if (str.length() == 0) return 0; char[] chArray = str.toCharArray(); int sign = 1; int i = 0; if (chArray[0] == '+') &#123; sign = 1; i++; &#125; else if (chArray[0] == '-') &#123; sign = -1; i++; &#125; int result = 0; while (i &lt; chArray.length) &#123; int digit = chArray[i] - '0'; if (digit &lt; 0 || digit &gt; 9) &#123; return sign * result; &#125; if (result &gt; Integer.MAX_VALUE / 10 || (result == Integer.MAX_VALUE / 10 &amp;&amp; Integer.MAX_VALUE % 10 &lt; digit)) &#123; return (sign == 1) ? Integer.MAX_VALUE : Integer.MIN_VALUE; &#125; result = result * 10 + digit; i++; &#125; return sign * result; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Medium","slug":"LeetCode-Medium","permalink":"https://gxkord.github.io/tags/LeetCode-Medium/"}]},{"title":"6. 动画","slug":"JavaScript/Three.js/6. 动画","date":"2018-12-07T13:15:02.000Z","updated":"2019-04-19T09:59:32.348Z","comments":true,"path":"2018/12/07/JavaScript/Three.js/6. 动画/","link":"","permalink":"https://gxkord.github.io/2018/12/07/JavaScript/Three.js/6. 动画/","excerpt":"","text":"定义动态画面，简称动画(animation)：利用人眼的视觉暂留特性，快速地变换画面，从而产生物体在运动的假象。 每秒帧数(FPS, Frames Per Second)：每秒画面重绘的次数。 FPS越大，则动画效果越平滑，当FPS小于20时，一般就能明显感觉到卡滞。人眼感觉到连续不间断的动画的FPS并不高，一般在30-60之间是可取的，否则就会消耗较多资源。 动画的制作方式JavaScript计时器1234setInterval(func, msec);// func：每过msec毫秒执行的函数。// 该函数会返回一个id，使用clearInterval(id)方法，可停止动画的重绘。 requestAnimationFrame当不在意多久绘制一次时，适合使用该方法。 1234setInterval(func);// 该函数会返回一个id，使用cancelAnimationFrame(id)方法，可停止动画的重绘// 注意：requestAnmationFrame只请求一帧画面，所以在被调函数中应再次调用。 两种方法的不同点setInterval可以手动设置FPS，而requestAnmationFrame在浏览器处理繁忙时会采取跳帧处理画面。 记录FPSstat.js是Three.js的作者Mr. Doob的另一个有用的JavaScript库。stat.js下载地址 很多情况下，我们希望知道实时的FPS信息，从而更好地监测动画效果。这时候，stat.js就能提供一个很好的帮助，它占据屏幕中的一小块位置（如左上角），效果为： 每秒的帧数(默认) 单击后显示每帧渲染时间： 每帧渲染时间 1234567891011var stat = null;function init() &#123; stat = new Stats(); stat.domElement.style.position = &apos;absolute&apos;; stat.domElement.style.right = &apos;0px&apos;; stat.domElement.style.top = &apos;0px&apos;; document.body.appendChild(stat.domElement); // Three.js init ...&#125;// 在动画绘制函数(&quot;动画制作方法&quot;中的func)中调用stat.begin() 与 stat.end()，分别表示一帧的开始与结束。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gxkord.github.io/categories/JavaScript/"}],"tags":[{"name":"3D","slug":"3D","permalink":"https://gxkord.github.io/tags/3D/"},{"name":"WebGL","slug":"WebGL","permalink":"https://gxkord.github.io/tags/WebGL/"},{"name":"Three.js入门","slug":"Three-js入门","permalink":"https://gxkord.github.io/tags/Three-js入门/"}]},{"title":"7. Reverse Integer(Easy)","slug":"算法/LeetCode/7. Reverse Integer(Easy)","date":"2018-12-07T12:02:01.000Z","updated":"2019-10-13T09:33:31.646Z","comments":true,"path":"2018/12/07/算法/LeetCode/7. Reverse Integer(Easy)/","link":"","permalink":"https://gxkord.github.io/2018/12/07/算法/LeetCode/7. Reverse Integer(Easy)/","excerpt":"","text":"题目描述原题 Description:Reverse digits of an integer. Note:The input is assumed to be a 32-bit signed integer. Your function should return 0 when the reversed integer overflows. Example1: x = 123, return 321Example2: x = -123, return -321 原题翻译 描述:给定一个 int 的整数，将其颠倒。 另外:假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。根据这个假设，如果反转后的整数溢出，则返回 0。 例1：x = 123, 返回 321例2：x = -123, 返回 -321 解法一 运行速度：超过了100%的解答。 内存使用：超过了11.66%的解答。 123456789101112131415public class Solution &#123; public static int reverse(int x) &#123; if (x == 0) return 0; int result = 0; while (x != 0) &#123; if (result &gt; Integer.MAX_VALUE / 10 || result &lt; Integer.MIN_VALUE / 10) return 0; result = result * 10 + x % 10; x /= 10; &#125; return result; &#125;&#125; 解法二 运行速度：超过了100%的解答。 内存使用：超过了5.55%的解答。 1234567891011121314public class Solution &#123; public int reverse(int x) &#123; int res = 0; int left = x; while (left != 0)&#123; int temp = res * 10 + left % 10; if ((temp - left % 10) / 10 != res) return 0; left /= 10; res = temp; &#125; return res; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Easy","slug":"LeetCode-Easy","permalink":"https://gxkord.github.io/tags/LeetCode-Easy/"}]},{"title":"5. 外部模型","slug":"JavaScript/Three.js/5. 外部模型","date":"2018-12-06T13:03:02.000Z","updated":"2019-04-19T09:59:09.273Z","comments":true,"path":"2018/12/06/JavaScript/Three.js/5. 外部模型/","link":"","permalink":"https://gxkord.github.io/2018/12/06/JavaScript/Three.js/5. 外部模型/","excerpt":"","text":"为什么要导入外部模型？ 在上一节中，我们了解到，使用THREE.js创建常见几何图形十分方便。 但对于人或动物这样的复杂模型使用简单几何体的组合就非常麻烦。 支持格式 Three.js有一系列导入外部文件的辅助函数，是在three.js之外的，使用前需要下载，在https://github.com/mrdoob/three.js/tree/master/examples/js/loaders可以找到。 目前，支持的模型格式有： *.obj（需导入OBJLoader.js） *.obj, *.mtl（导入MTLLoader.js 与 OBJMTLLoader.js） *.dae *.ctm *.ply *.stl *.wrl *.vtk 无材质的模型需导入OBJLoader.js。 12345678910111213141516171819// 创建Loadervar loader = new THREE.OBJLoader();// 两个参数，第一个表示模型路径，第二个是完成导入后的回调函数loader.load('../lib/***.obj', function(obj)&#123; mesh = obj;//储存到全局变量中 scene.add(obj);&#125;);// 默认情况下，只有正面的面片被绘制，而如果需要双面绘制则需要：loader.load('../lib/***.obj', function(obj)&#123; obj.traverse(function(child)&#123; if(child instanceof THREE.Mesh)&#123; child.material.side = THREE.DoubleSide; &#125; &#125;); mesh = obj; scene.add(obj);&#125;); 有材质的模型 在代码中导入模型后设置材质 123456789101112loader.load('../lib/***.obj', function(obj)&#123; obj.traverse(function(child)&#123; if(child instanceof THREE.Mesh)&#123; child.material = new THREE.MeshLambertMaterial(&#123; color: 0xffff00, side: THREE.DoubleSide &#125;); &#125; &#125;); mesh = obj; scene.add(obj);&#125;); 在建模软件中导出材质信息 需导入MTLLoader.js 与 OBJMTLLoader.js。 123456789101112// 创建Loader var loader = new THREE.OBJMTLLoader();// 监听loader的load事件loader.addEventListener('load', function(event)&#123; var obj = event.content; mesh = obj; scene.add(obj);&#125;);// 加载模型loader.load('../lib/***.obj', '../lib/***.mtl'); 补充：在r78版本中，删除了OBJMTLLoader.js库，使用OBJLoader.js和MTLLoader.js一起使用来代替它 123456789101112var mtlLoader = new THREE.MTLLoader();mtlLoader.load(&apos;*.mtl&apos;, function(materials) &#123; materials.preload(); //预加载 var objLoader = new THREE.OBJLoader(); objLoader.setMaterials(materials); objLoader.load(&apos;*.obj&apos;, function(object) &#123; object.position.y = -300; // 这里调整模型位置 mesh = object; // 赋值给全局变量 scene.add(object); &#125;);&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gxkord.github.io/categories/JavaScript/"}],"tags":[{"name":"3D","slug":"3D","permalink":"https://gxkord.github.io/tags/3D/"},{"name":"WebGL","slug":"WebGL","permalink":"https://gxkord.github.io/tags/WebGL/"},{"name":"Three.js入门","slug":"Three-js入门","permalink":"https://gxkord.github.io/tags/Three-js入门/"}]},{"title":"6. ZigZag Conversion(Medium)","slug":"算法/LeetCode/6. ZigZag Conversion(Medium)","date":"2018-12-06T09:42:02.000Z","updated":"2019-10-13T09:32:13.809Z","comments":true,"path":"2018/12/06/算法/LeetCode/6. ZigZag Conversion(Medium)/","link":"","permalink":"https://gxkord.github.io/2018/12/06/算法/LeetCode/6. ZigZag Conversion(Medium)/","excerpt":"","text":"题目描述原题 Description: The string “PAYPALISHIRING” is written in a zigzag pattern on a given number of rows like this:(you may want to display this pattern in a fixed font for better legibility) 1234&gt; P A H N&gt; A P L S I I G&gt; Y I R&gt; And then read line by line: “PAHNAPLSIIGYIR”. Write the code that will take a string and make this conversion given a number of rows: Example 1: Input: s = “PAYPALISHIRING”, numRows = 3Output: “PAHNAPLSIIGYIR” Example 2: Input: s = “PAYPALISHIRING”, numRows = 4Output: “PINALSIGYAHRPI”Explanation: 12345&gt; &gt; &gt; P I N&gt; &gt; &gt; A L S I G&gt; &gt; &gt; Y A H R&gt; &gt; &gt; P I&gt; &gt; &gt; 原题翻译 描述： 字符串“PAYPALISHIRING”以Z字形图案写在给定数量的行上，如下所示:(您可能希望以固定字体显示此图案以获得更好的易读性） 1234&gt; P A H N&gt; A P L S I I G&gt; Y I R&gt; 然后逐行读取得到：“PAHNAPLSIIGYIR”。 编写将给定字符串转化的代码： Example 1: Input: s = “PAYPALISHIRING”, numRows = 3Output: “PAHNAPLSIIGYIR” Example 2: Input: s = “PAYPALISHIRING”, numRows = 4Output: “PINALSIGYAHRPI”Explanation: 12345&gt; &gt; &gt; P I N&gt; &gt; &gt; A L S I G&gt; &gt; &gt; Y A H R&gt; &gt; &gt; P I&gt; &gt; &gt; 解法一(mine) 打败了5.54%的回答… 主要思想把每个$|/$形状作为一个分组（如：例子中的PAYPAL）。 用一个二维数组保存过程中的图形，然后遍历这个数组。 运行速度：超过了7.39%的解答。 内存使用：超过了84.04%的解答。 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public String convert(String s, int numRows) &#123; int len = s.length(); if (len &lt; 2 || numRows == 1) &#123; return s; &#125; StringBuffer result = new StringBuffer(\"\"); int last = len % (numRows + numRows - 2); int nums = len / (numRows + numRows - 2); //分组数 int m = nums * (1 + numRows - 2); if (last &gt; numRows) &#123; m += 1 + (last - numRows); &#125; else &#123; m += 1; &#125; char[][] temp = new char[m][numRows]; boolean flag = true; int a = 0, b = 0; for (int i = 0; i &lt; len; i++) &#123; temp[a][b] = s.charAt(i); if (flag) &#123; ++b; &#125; else &#123; ++a; --b; &#125; if (b == (numRows - 1)) &#123; flag = false; &#125; else if (b == 0) &#123; flag = true; &#125; &#125; for (int i = 0; i &lt; numRows; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; String ss = String.valueOf(temp[j][i]); if (!ss.equals(\"\\u0000\")) &#123; result.append(ss); &#125; &#125; &#125; return result.toString(); &#125;&#125; 解法二主要思想通过从左往右迭代字符串，可以得到每个字符位于”Z”图案的第几行。 用一个list保存每一行。 源码12345678910111213141516171819202122public class Solution &#123; public String convert(String s, int numRows) &#123; if (numRows == 1) return s; List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; Math.min(numRows, s.length()); i++) rows.add(new StringBuilder()); int curRow = 0; boolean goingDown = false; for (char c : s.toCharArray()) &#123; rows.get(curRow).append(c); if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown; curRow += goingDown ? 1 : -1; &#125; StringBuilder ret = new StringBuilder(); for (StringBuilder row : rows) ret.append(row); return ret.toString(); &#125;&#125; 解法三 第一名的答案。 运行速度：超过了100%的解答。 内存使用：超过了100%的解答。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class Solution &#123; public String convert(String s, int numRows) &#123; if (s == null || s.length() == 0) &#123; return \"\"; &#125; if (s.length() == 1) &#123; return s; &#125; if (numRows &lt;= 1) &#123; return s; &#125; int stringLength = s.length(); char[] chars = s.toCharArray(); char[] output = new char[stringLength]; int outputIndex = 0; for (int offset = 0; offset &lt; numRows; offset++) &#123; int index = offset; // Add the first letter if (index &gt;= stringLength) &#123; break; &#125; output[outputIndex++] = chars[index]; while (index &lt; stringLength) &#123; // Skip this for the last row, since it will // output the same spot if (offset &lt; numRows - 1) &#123; index += 2 * (numRows - 1 - offset); if (index &gt;= stringLength) break; output[outputIndex++] = chars[index]; &#125; // Skip this for the first row, since it will // always output the same spot if (offset &gt; 0) &#123; index += 2 * offset; if (index &gt;= stringLength) break; output[outputIndex++] = chars[index]; &#125; &#125; &#125; return new String(output); // rows = 4 // 0 (2 * rows - 1) // 6 // 12 // offset = 1 // 1 (2 * (rows - offset - 1)) // 5 (2 * (offset)) // 7 // 11 // 13 // offset = 2 // 2 (2 * (rows - offset - 1)) // 4 (2 * offset) // 8 // 10 // 14 // offset = 3 // 3 // 3 // 9 &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Medium","slug":"LeetCode-Medium","permalink":"https://gxkord.github.io/tags/LeetCode-Medium/"}]},{"title":"4. 物体","slug":"JavaScript/Three.js/4. 物体","date":"2018-12-05T13:04:01.000Z","updated":"2019-04-19T09:58:28.156Z","comments":true,"path":"2018/12/05/JavaScript/Three.js/4. 物体/","link":"","permalink":"https://gxkord.github.io/2018/12/05/JavaScript/Three.js/4. 物体/","excerpt":"","text":"创建物体的两个必要条件 几何形状(Geometry) 材质(Material) 几何形状作用储存一个物体的顶点信息。 基本几何形状立方体(CubeGeometry)12345678910new THREE.CubeGeometry( width, // x方向上的长度 height, // y方向上的长度 depth, // z方向上的长度 widthSegments, // x方向切片数 heightSegments, // y方向切片数 depthSegments // z方向切片数);// 后三个参数为切片数，默认为1。// 如不需要，可以不设置。 平面(PlaneGeometry) 并不是数学上无限大小的平面。 12345678new THREE.PlaneGeometry( width, // x方向上的长度 height, // y方向上的长度 widthSegments, // x方向切片数 heightSegments // y方向切片数);// 后两个参数为切片数，默认为1。// 如不需要，可以不设置。 球体(SphereGeometry)123456789new THREE.SphereGeometry( radius, // 半径 segmentsWidth, // 经度上的切片数 segmentsHeight, // 纬度上的切片数 phiStart, // 经度开始的弧度 phiLegth, // 经度跨过的弧度 thetaStart, // 纬度开始的弧度 thetaLength // 纬度跨过的弧度); 球体 圆形(CircleGeometry)123456new THREE.CircleGeometry( radius, // 半径 segments, // 切片数 thetaStart, // 开始弧度 thetaLength // 跨过的弧度); 圆柱体(CylinderGeometry) 正圆柱 圆台 1234567new THREE.CylinderGeometry( radiusTop, // 顶面半径 radiusBottom, // 底面半径 height, // 高度 radiusSegments, // 纵向切片数 heightSegments // 横向切片数); 正n面体 正四面体(TetrahedronGeometry) 正八面体(OctahedronGeometry) 正十二面体(IcosahedronGeometry) 1234new Three.xxxGeometry( radius, // 半径 detail // 细节层次，一般使用缺省); 圆环面(TorusGeometry) 它的形状类似于甜甜圈。 1234567new THREE.TorusGeometry( radius, // 圆环半径 tube, // 管道半径 radialSegments, // 纵切分段数 tubularSegments, // 横切分段数 arc // 圆环面的弧度); 圆环 圆环结(TorusKnotGeometry) 它的形状类似于打了结的甜甜圈。 123456789THREE.TorusKnotGeometry( radius, // 圆环半径 tube, // 管道半径 radialSegments, // 纵切分段数 tubularSegments, // 横切分段数 p, // 控制样式的参数，一般缺省 q, // 控制样式的参数，一般缺省 heightScale // 在z轴方向上的缩放) 自定义形状1234567891011121314151617181920212223242526/* *自定义一个梯台 */// 初始化var geometry = new THREE.Geometry();// 顶部4顶点geometry.vertices.push(new Victor3(-1, 2, -1));geometry.vertices.push(new Victor3(1, 2, -1));geometry.vertices.push(new Victor3(1, 2, 1));geometry.vertices.push(new Victor3(-1, 2, 1));// 底部4顶点geometry.vertices.push(new Victor3(-2, 0, 2));geometry.vertices.push(new Victor3(2, 0, -2));geometry.vertices.push(new Victor3(2, 0, 2));geometry.vertices.push(new Victor3(-2, 0, 2));// 设置顶点连接情况// 顶面geometry.faces.push(new THREE.Face(0, 1, 2, 3));// 底面geometry.faces.push(new THREE.Face(4, 5, 6, 7));// 四个侧面geometry.faces.push(new THREE.Face(0, 1, 5, 4));geometry.faces.push(new THREE.Face(1, 2, 6, 5));geometry.faces.push(new THREE.Face(2, 3, 7, 6));geometry.faces.push(new THREE.Face(3, 0, 4, 7)); 材质定义材质是独立于物体顶点信息之外的与渲染效果相关的属性。 通过修改它，可以改变物体的颜色、纹理贴图、光照模式等。 种类基本材质（MeshBasicMaterial）使用基本材质的物体，渲染后不会由于光照产生明暗、阴影效果。 123456789101112new THREE.MeshBasicMaterial(opt);/** *opt可以缺省，也可以包含以下属性： * visible：是否可见，默认为true * side：渲染面为正面或反面 * 正面：THREE.FrontSide(缺省)； * 反面：THREE.BackSide； * 双面:THREE.DoubleSide。 * wireframe：是否渲染线而非面，默认false * color：十六进制RGB颜色 * map：使用纹理贴图 */ Lambert材质（MeshLambertMaterial） 符合Lambert光照模型的材质。 只考虑漫反射而不考虑镜面反射。 123456789new THREE.MeshLambertMaterial(opt);/** *opt可以缺省，也可以包含以下属性： * color：用来表现材质对散射光的反射能力，也是最常用来设置材质颜色的属性。 * ambient：对环境光的反射能力， * 只有当设置了AmbientLight后，该值才是有效的。 * 材质对环境光的反射能力与环境光强相乘后得到材质实际表现的颜色。 * emissive：材质的自发光颜色 */ 其光照模型（了解即可）： 123456&gt; Idiffuse = Kd * Id * cos(theta)&gt; Idiffuse：漫反射光强。&gt; Kd：物体表面的漫反射属性。&gt; Id：光强。&gt; theta：光的入射角弧度。&gt; Phong材质（MeshPhongMaterial） 既考虑漫反射又考虑镜面反射。 其漫反射模型与Lambert相同。 123456789new THREE.MeshPhongMaterial(opt);/** *opt可以缺省，也可以包含以下属性： * ambient：对环境光的反射能力， * 只有当设置了AmbientLight后，该值才是有效的。 * emissive：材质的自发光颜色 * specular：指定镜面反射系数 * shiniess：值越大光斑越小（高光系数n） */ Phong材质镜面反射光照模型（漫反射模型与Lambert相同）： 1234567&gt; Ispecular = Ks * Is * (cos(alpha))^n&gt; Ispecular：镜面反射光强&gt; Ks：材质表面镜面反射系数&gt; Is：光源强度&gt; alpha：反射光与视线的夹角&gt; n：高光系数，值越大则高光系数越小&gt; 法向材质 将材质的颜色设置为其法向量的方向。 其材质颜色与照相机与该物体的角度相关。 1new THREE.MeshNormalMaterial(); 材质的纹理贴图 注意：贴图只有运行在服务器上才能显示出来。 1234567// 创建纹理贴图var texture = THREE.ImageUtils.loadTexture('../img/0.png');// 将纹理贴图应用到材质上var material = new THREE.MeshLambertMaterial(&#123; map:texture&#125;); 有哪些物体？ 最常见：网格(Mesh) 其他：线段(Line)、骨骼(Bone)、粒子系统(ParticleSystem) 如何创建物体？ 创建物体时，需要指定几何形状和材质。 12]// 如：创建一个网格new THREE.Mesh(geometry, material);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gxkord.github.io/categories/JavaScript/"}],"tags":[{"name":"3D","slug":"3D","permalink":"https://gxkord.github.io/tags/3D/"},{"name":"WebGL","slug":"WebGL","permalink":"https://gxkord.github.io/tags/WebGL/"},{"name":"Three.js入门","slug":"Three-js入门","permalink":"https://gxkord.github.io/tags/Three-js入门/"}]},{"title":"5. Longest Palindromic Substring(Medium)","slug":"算法/LeetCode/5. Longest Palindromic Substring(Medium)","date":"2018-12-05T10:22:01.000Z","updated":"2019-10-16T07:41:57.600Z","comments":true,"path":"2018/12/05/算法/LeetCode/5. Longest Palindromic Substring(Medium)/","link":"","permalink":"https://gxkord.github.io/2018/12/05/算法/LeetCode/5. Longest Palindromic Substring(Medium)/","excerpt":"","text":"题目描述原题 Description: Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: “babad”Output: “bab”Note: “aba” is also a valid answer. Example 2: Input: “cbbd”Output: “bb” 原题翻译 描述： 给定一个字符串s，找到s中最长的回文子字符串。您可以假设s的最大长度为1000。 例1： 输入: “babad”输出: “bab”另外: “ava”也是一个可行的答案。 例2： 输入: “cbbd”输出: “bb” 解法一主要思想用变量i遍历字符串，从第i个字符开始，left，right两个指针分别向左右遍历，求最大回文长度。 运行速度：超过了86.94%的解答。 内存使用：超过了100%的解答。 源码1234567891011121314151617181920212223242526public class Solution &#123; public String longestPalindrome(String s) &#123; if (s.length() &lt; 2) &#123; return s; &#125; int start = 0, end = 0; for (int i = 0; i &lt; s.length(); i++) &#123; int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i + 1); int len = Math.max(len1, len2); if (len &gt; end - start) &#123; start = i - (len - 1) / 2; end = i + len / 2; &#125; &#125; return s.substring(start, end + 1); &#125; // 使用left和right两指针遍历是否为回文 private int expandAroundCenter(String s, int left, int right) &#123; while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123; left--; right++; &#125; return right - left - 1; &#125;&#125; 解法二主要思想 第一名的答案。 运行速度：超过了100%的解答。 内存使用：超过了100%的解答。 源码1234567891011121314151617181920212223242526272829public class Solution &#123; int len = 0, maxLength = 0, start = 0; public String longestPalindrome(String s) &#123; char[] arr = s.toCharArray(); len = s.length(); if (len &lt;= 1) return s; for (int i = 0; i &lt; len; i++) &#123; i = helper(arr, i); &#125; return s.substring(start, start + maxLength); &#125; // 从k开始向两边遍历 private int helper(char[] arr, int k) &#123; int i = k - 1, j = k; while (j &lt; len - 1 &amp;&amp; arr[j] == arr[j + 1]) j++; int nextCenter = j++; while (i &gt;= 0 &amp;&amp; j &lt; len &amp;&amp; arr[i] == arr[j]) &#123; i--; j++; &#125; if (j - i - 1 &gt; maxLength) &#123; maxLength = j - i - 1; start = i + 1; &#125; return nextCenter; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Medium","slug":"LeetCode-Medium","permalink":"https://gxkord.github.io/tags/LeetCode-Medium/"}]},{"title":"3. 光与影","slug":"JavaScript/Three.js/3. 光与影","date":"2018-12-04T13:04:05.000Z","updated":"2019-04-19T09:54:57.548Z","comments":true,"path":"2018/12/04/JavaScript/Three.js/3. 光与影/","link":"","permalink":"https://gxkord.github.io/2018/12/04/JavaScript/Three.js/3. 光与影/","excerpt":"","text":"光源光源的种类 环境光(AmbientLight) 点光源(PointLight) 平行光(DirectionalLight) 聚光灯(SpotLight) 环境光介绍：对场景整体光照效果相同的光源。特点：没有明确的光源位置，各处亮度一致。 12345678/* 创建环境光 * 参数说明： * -- hex：16进制RGB颜色信息） */var light = new THREE.AmbientLight(hex);// 加入场景scene.add(light); 点光源介绍：点向周围空间均匀发光的光源。特点：不计光源的大小；距离越远，光线越散。 12345678910111213/* 创建点光源 * 参数说明： * hex：16进制RGB颜色 * intensity：亮度（缺省为1） * distance：光源最远照射到的距离（缺省为0） */ var light = new THREE.PointLight(hex, intensity, distance);// 位置light.position.set(0, 1.5, 2);// 加入场景scene.add(light); 平行光介绍：一组没有衰减的平行的光线。特点：对于任意平行的平面，平行光照射的亮度都是相同的。 123456789101112/* 创建平行光源 * 参数说明： * hex：16进制RGB颜色 * intensity：亮度（缺省1） */var light = new THREE.DirectionalLight( hex, intensity );// 设置位置light.position.set(2, 5, 3); // 意味着平行光沿矢量(-2.-5,-3)的方向照射到所有平面// 加入场景scene.add(light); 聚光灯介绍：一种可以投影出类似圆锥形阴影的特殊的“点光源”。特点：同点光源。不计光源的大小；距离越远，光线越散。 123456789101112131415/* 创建平行光源 * 参数说明： * hex：16进制RGB颜色 * intensity：亮度（缺省值为1） * distance：光源最远照射到的距离（缺省值为0） * angle：聚光灯的张角（缺省值为Math.PI/3，最大值Math.PI/2） * exponent：光强在偏离target的衰减指数（缺省值为10。target需要在之后定义，缺省值为(0,0,0)） */var light = THREE.SpotLight(hex, intensity, distance, angle, exponent)；// 设置位置light.position.set(0, 0, 3);// 设置目标位置light.target.position.set(0,0,0); // 如果把 target 设置为某物体(例如：light.target=mesh)，聚光灯就会随该物体运动 阴影注意： 只有“平行光”和“聚光灯”才能形成阴影。 只有“Lambert材质”和“Phong材质”的物体才能形成阴影。 使用方法： 设置渲染器渲染阴影 renderer.shadowMapEnabled = true; 光源渲染阴影 light.castShandow = true; 设置显示阴影的物体 mesh.receiveShaow = true; 设置产生光源阴影范围 (1) 对于聚光灯，需要设置shadowCameraNear、shadowCameraFar、shadowCameraFov（这三个参数类似透视投影照相机）。 只有在 shadowCameraNear 和 shadowCameraFar 之间的物体才会产生阴影; shadowCameraFov表示夹角。 (2) 对于平行光，需要设置shadowCameraNear、shadowCameraFar、shadowCameraLeft、shadowCameraRight、shadowCameraTop、shadowCameraBottom六个值（类似于正交投影照相机的六个面）。 在这六个面围成的范围内的物体，才会产生阴影 （ps：为了使结果更直观，可以在调试时开启light.shadowCameraVisible=true，把光的范围用线表示出来） 其他参数： shadowDarkness：阴影的深浅，该值的范围是0到1，越小越浅 shadowMapSoft：软阴影","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gxkord.github.io/categories/JavaScript/"}],"tags":[{"name":"3D","slug":"3D","permalink":"https://gxkord.github.io/tags/3D/"},{"name":"WebGL","slug":"WebGL","permalink":"https://gxkord.github.io/tags/WebGL/"},{"name":"Three.js入门","slug":"Three-js入门","permalink":"https://gxkord.github.io/tags/Three-js入门/"}]},{"title":"4. Median of Two Sorted Arrays(Hard)","slug":"算法/LeetCode/4. Median of Two Sorted Arrays(Hard)","date":"2018-12-03T11:02:03.000Z","updated":"2019-10-16T07:40:39.153Z","comments":true,"path":"2018/12/03/算法/LeetCode/4. Median of Two Sorted Arrays(Hard)/","link":"","permalink":"https://gxkord.github.io/2018/12/03/算法/LeetCode/4. Median of Two Sorted Arrays(Hard)/","excerpt":"","text":"题目描述原题 Description: There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: Input: nums1 = [1, 3]nums2 = [2] Output: 2.0Explanation: The median is 2.0. Example 2: Input: nums1 = [1, 2]nums2 = [3, 4] Output: 2.5Explanation: The median is (2 + 3)/2 = 2.5 原题翻译 描述： 有两个有序的数组nums1和nums2，长度分别为m和n。 找到两个排序数组的中位数。总运行时间复杂度应为O(log(m + n))。 您可以假设nums1和nums2不能都为空。 例1： 输入： nums1 = [1, 3]nums2 = [2] 输出：2.0解释：[1, 2, 3]的中位数为2.0 例2： 输入： nums1 = [1, 2]nums2 = [3, 4] 输出：2.5解释：[1, 2, 3, 4]的中位数为(2 + 3) / 2 = 2.5 解法一（mine）主要思想首尾指针法，分别为两数组设置两个指针 运行速度：超过了99.97%的解答。 内存使用：超过了89.58%的解答。 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int m = 0, n = nums2.length - 1; if (nums1.length == 0) &#123; while (n - m &gt; 1) &#123; m++; n--; &#125; return (m == n) ? (double)nums2[m] : ((double)nums2[m] + (double)nums2[n]) / 2; &#125; int j = 0, k = nums1.length - 1; if (nums2.length == 0) &#123; while (j &lt; k) &#123; j++; k--; &#125; return (j == k) ? (double)nums1[j] : ((double)nums1[j] + (double)nums1[k]) / 2; &#125; while ((k - j) + (n - m) &gt; 0) &#123; /* 这里使用了一个知识点： * || 运算符：如果该运算符前面的条件为true，后面的条件不计算 * &amp;&amp; 运算符：如果该运算符前面对条件为false，后面的条件不计算 */ if (m == nums2.length || (j != nums1.length &amp;&amp; nums1[j] &lt; nums2[m])) &#123; j++; &#125; else if (j == nums1.length || nums1[j] &gt;= nums2[m])&#123; m++; &#125; // 上面的if-else语句也可以写成这样： // if (m == nums2.length) // j++; // else if (j == nums1.length) // m++; // else if (nums1[j] &lt; nums2[m]) // j++; // else if (nums1[j] &gt;= nums2[m]) // m++; if (k == -1 || (n != -1 &amp;&amp; nums1[k] &lt; nums2[n])) &#123; n--; &#125; else if (n == -1 || nums1[k] &gt;= nums2[n])&#123; k--; &#125; &#125; if (j &gt; k) return ((double)nums2[m] + (double)nums2[n]) / 2; if (m &gt; n) return ((double)nums1[j] + (double)nums1[k]) / 2; return ((double)nums1[j] + (double)nums2[m]) / 2; &#125;&#125; 解法二 第一名的答案。这道题的难度不亏为最高的Hard，活活研究了两天才能勉强看懂。 运行速度：超过了99.97%的解答。 内存使用：超过了84.03%的解答。 主要思想 解题思路 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public double findMedianSortedArrays(int[] A, int[] B) &#123; int m = A.length; int n = B.length; if (m &gt; n) &#123; // 保证m&lt;=n int[] temp = A; A = B; B = temp; int tmp = m; m = n; n = tmp; &#125; int iMin = 0, iMax = m, halfLen = (m + n + 1) / 2; while (iMin &lt;= iMax) &#123; int i = (iMin + iMax) / 2; int j = halfLen - i; if (i &lt; iMax &amp;&amp; B[j-1] &gt; A[i])&#123; // i is too small iMin = i + 1; &#125; else if (i &gt; iMin &amp;&amp; A[i-1] &gt; B[j]) &#123; // i is too big iMax = i - 1; &#125; else &#123; // i is perfect int maxLeft = 0; if (i == 0) &#123; maxLeft = B[j-1]; &#125; else if (j == 0) &#123; maxLeft = A[i-1]; &#125; else &#123; maxLeft = Math.max(A[i-1], B[j-1]); &#125; if ((m + n) % 2 == 1) &#123; return maxLeft; &#125; int minRight = 0; if (i == m) &#123; minRight = B[j]; &#125; else if (j == n) &#123; minRight = A[i]; &#125; else &#123; minRight = Math.min(B[j], A[i]); &#125; return (maxLeft + minRight) / 2.0; &#125; &#125; return 0.0; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Hard","slug":"LeetCode-Hard","permalink":"https://gxkord.github.io/tags/LeetCode-Hard/"}]},{"title":"3. Longest Substring Without Repeating Characters(Medium)","slug":"算法/LeetCode/3. Longest Substring Without Repeating Characters(Medium)","date":"2018-12-02T11:20:03.000Z","updated":"2019-10-16T07:39:42.357Z","comments":true,"path":"2018/12/02/算法/LeetCode/3. Longest Substring Without Repeating Characters(Medium)/","link":"","permalink":"https://gxkord.github.io/2018/12/02/算法/LeetCode/3. Longest Substring Without Repeating Characters(Medium)/","excerpt":"","text":"题目描述原题 Description: Given a string, find the length of the longest substring without repeating characters. Example 1: Input: “abcabcbb”Output: 3Explanation: The answer is “abc”, with the length of 3. Example 2: Input: “bbbbb”Output: 1Explanation: The answer is “b”, with the length of 1. Example 3: Input: “pwwkew”Output: 3Explanation: The answer is “wke”, with the length of 3.Note that the answer must be a substring, “pwke” is a subsequence and not a substring. 原题翻译 描述： 给定一个字符串，找到最长的不重复子串的长度。 例1： 输入：“abcabcbb”输出：3解释：最长的不重复子串为”abc”，长度为3。 例2： 输入：“bbbbb”输出：1解释：最长的不重复子串为”b”，长度为3。 例3： 输入：“pwwkew”输出：3解释：最长的不重复子串为”wke”，长度为3。注意，答案必须是子字符串，“pwke”是子数组而不是子字符串。 解法一主要思想遍历String对应的char[]，将char和index放入Map，对Map中已有的char进行覆盖。 运行速度：超过了64.86%的解答。 内存使用：超过了99.76%的解答。 源码123456789101112131415161718192021222324252627public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int len = s.length(); if(len &lt;= 1) return len; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); char[] chars = s.toCharArray(); int temp = 0; int max = 0; for(int i = 0; i &lt; len; i++) &#123; if(!map.containsKey(chars[i])) &#123; map.put(chars[i], i); temp++; &#125; else &#123; if(i - map.get(chars[i]) &gt; temp) &#123; // 当前字母不在temp里 temp++; &#125; else &#123; max = Math.max(max, temp); temp = i - map.get(chars[i]); &#125; map.put(chars[i], i); &#125; &#125; max = Math.max(max, temp); return max; &#125;&#125; 解法二主要思想利用StringBuilder的API。 运行速度：超过了86.34%的解答。 内存使用：超过了52.36%的解答。 源码1234567891011121314151617public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; StringBuilder substring = new StringBuilder(); int longestLength = 0; for(int i =0; i&lt; s.length(); i++) &#123; String currentLetter = Character.toString(s.charAt(i)); if (substring.indexOf(currentLetter) != -1 ) &#123; // StringBuilder中已存在该字符 longestLength = Math.max(substring.length(), longestLength); int endIndexToDelete = substring.indexOf(currentLetter) +1; substring.delete(0, endIndexToDelete); &#125; substring.append(currentLetter); &#125; longestLength = Math.max(substring.length(), longestLength); return longestLength; &#125;&#125; 解法三 第一名答案，难以想象它竟然是一位中国人给出的(代码里有中文注释)。作为一个中国人，给出一个String，他竟然能想到ascii码… 主要思想一个boolean[128]表示128个ascii字符。 运行速度：超过了99.82%的解答。 内存使用：超过了89.62%的解答。 源码1234567891011121314151617181920212223242526public class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; boolean[] exist = new boolean[128]; // 表示acii码的128个字符 int max = 0, start = 0; // start用来记录无重复子串的开始位置 for (int i = 0, len = s.length(); i &lt; len; i++) &#123; char c = s.charAt(i); if (exist[c]) &#123; max = Math.max(max, i - start); // 每次当数组中出现一个重复字符 c 的时候，将之前一个重复的 c 之前的元素设为未出现（exist[i]=false） for (int j = start; j &lt; i; j++) &#123; if (s.charAt(j) == c) &#123; start = j + 1; break; &#125; exist[s.charAt(j)] = false; &#125; &#125; else &#123; exist[c] = true; &#125; &#125; return Math.max(s.length() - start, max); &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Medium","slug":"LeetCode-Medium","permalink":"https://gxkord.github.io/tags/LeetCode-Medium/"}]},{"title":"2. Java内存区域与内存溢出异常","slug":"Java/JVM/《深入理解java虚拟机》第2版/2. Java内存区域与内存溢出异常","date":"2018-12-02T09:43:13.000Z","updated":"2019-01-23T07:49:52.585Z","comments":true,"path":"2018/12/02/Java/JVM/《深入理解java虚拟机》第2版/2. Java内存区域与内存溢出异常/","link":"","permalink":"https://gxkord.github.io/2018/12/02/Java/JVM/《深入理解java虚拟机》第2版/2. Java内存区域与内存溢出异常/","excerpt":"","text":"概述对于从事C、C++程序开发的开发人员来说，他们既拥有每个对象的“所有权”，又担负着每一个对象生命开始到终结的维护责任。 对于java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要对每个对象都去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题。但也正是因为这样，一旦出现了内存泄漏和内存溢出的问题，如果不了解虚拟机是如何使用内存的，那么排错将会成为一项异常艰难的工作。 运行时数据区域 运行时数据区域 程序计数器它是一块很小的内存空间，可以把它看做当前线程所执行的字节码的行号指示器。分支、循环、跳转、异常处理等基础功能都是依赖它完成的。 如果线程执行的是个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果线程执行的是个Native方法，这个计数器值为空（Undefined）。 Native方法是指由其他编程语言编写，再由JVM调用的方法。 每个线程都有一个独立的程序计数器，各线程之间的计数器互不影响，独立存储。我们称这类内存区域为“线程私有”的内存。 Java虚拟机栈它也是线程私有的，其生命周期和线程相同。其描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。一个方法从执行到结束，对应一个栈帧在虚拟机栈的入栈到出栈的过程。 栈帧（Stack Frame）：方法运行时的一种基础数据结构，详见第八章对帧的讲解 局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）和returnAddress类型。其中64位长度的long和double类型数据会占用2个局部变量空间（Slot），其他占1个。局部变量表需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧内分配多大的局部变量空间是完全确定的。 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflewError异常；如果虚拟机栈可以动态扩展，但扩展时无法申请到足够的空间，就会抛出OutOfMemoryError异常。 本地方法栈与虚拟机栈的作用相似。区别在于：虚拟机栈为虚拟机执行的Java方法服务，而本地方法栈则为虚拟机使用的Native方法服务。 与虚拟机栈一样，它也会抛出StackOverflewError和OutOfMemoryError异常 Java堆对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块。它是所有线程共享的一块内存区域，在虚拟机启动时创建。这块区域的唯一目的就是存放对象实例，几乎所有的对象实例都在此分配。Java虚拟机规范里是这么描述的：“所有对象实例以及数组都要在堆上分配”。但随着JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换技术将会让这句话不再“绝对”。 逃逸分析与标量替换的相关内容，参照第11章 Java堆是垃圾收集器管理的主要区域，也被称为“GC堆”（Garbage Collected Heap）。Java堆可以处于逻辑上连续、物理上不连续的内存空间中。如果堆中没有内存完成实例分配，并且堆也没有再扩展时，将会抛出OutOfMemoryError异常。 方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。它还有个别名：NonHeap（非堆）。 Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。 运行时常量池运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。 既然它是方法区的一部分，那么当它无法申请到内存时也将抛出OutOfMemoryError异常。 直接内存直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。它属于本机内存。 当超过本机物理内存限制时，会出现OutOfMemoryError异常。 HotSpot虚拟机对象探秘对象的创建在语言层面，创建对象，只需要一个new关键字即可，而在虚拟机中，对象（限于普通java对象，不包括数组和Class对象）创建又是怎样一个过程呢？ 虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。 Java堆分配空间的方式： 假设Java堆中内存时绝对规整的，所有用过的内存放在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，那么只需将指针向空闲内存一侧移动所需内存即可完成分配。这种分配方式称为“指针碰撞”（Bump the Pointer）。 假如Java堆中内存并不是规整的，已使用的内存和空闲内存互相交错，虚拟机就必须维护一个列表，来记录哪块内存可用，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表。这种分配方式称为“空闲列表”（Free List）。 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定） 除了如何划分可用空间外，还有另外一个需要考虑的问题。 对象创建在虚拟机中是非常频繁的行为，在并发情况下也不是线程安全的。可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。 解决方案有两个：一种是对分配内存空间的动作进行同步处理；另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），只有TLAB用完并需要分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定 内存分配完成后，虚拟机需要将分配到的内存空间初始化为零值（不包括对象头），如果使用了TLAB，也可以在TLAB分配时初始化。这一步保证了对象在Java代码中不需要初始化也可以直接使用。 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码等信息。这些信息存放在对象头（Object Header）中。 在上面的工作完成后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序员的视角来看，对象创建才刚刚开始——方法还没有执行，所有字段都还为零。所以执行完new指令后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个对象才算完成了创建。 对象的内存布局在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。 对象头包括两部分信息。 第一部分用于存储对象自身的运行时数据。如：哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。 对象头的另外一部分是类型指针，即指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。另外，如果对象是一个Java数组，那在对象头中还必须有一块记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但从数组的元数据信息中却无法确定数组大小。 并不是所有虚拟机都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息不一定要经过对象本身，具体见下个部分的“对象访问定位”。 实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承的，还是子类定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义的顺序的影响。 对齐填充并不是必然存在的，它只起到占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，也就是说对象的大小必须是8字节的整数倍，而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 对象的访问定位在Java虚拟机规范中，只规定了reference类型是一个指向对象的引用，并没有规定这个引用应该通过何种方式去定位、访问堆中的对象的具体位置。所以对象的访问方式取决于虚拟机如何来实现它。目前主流的访问方式有使用句柄和直接指针两种。 如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 句柄方式访问对象 如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。 直接指针方式访问对象 这两种访问方式各有优势。使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄的实例数据指针，而reference本身不需要修改。 使用直接指针访问方式的最大好处是速度更快，它节省了一次指针定位的时间开销。","categories":[{"name":"Java","slug":"Java","permalink":"https://gxkord.github.io/categories/Java/"}],"tags":[{"name":"《深入理解Java虚拟机》","slug":"《深入理解Java虚拟机》","permalink":"https://gxkord.github.io/tags/《深入理解Java虚拟机》/"},{"name":"第二部分 自动内存管理机制","slug":"第二部分-自动内存管理机制","permalink":"https://gxkord.github.io/tags/第二部分-自动内存管理机制/"},{"name":"JVM","slug":"JVM","permalink":"https://gxkord.github.io/tags/JVM/"}]},{"title":"1. 走近Java","slug":"Java/JVM/《深入理解java虚拟机》第2版/1. 走近Java","date":"2018-12-02T08:14:13.000Z","updated":"2019-01-23T07:49:14.339Z","comments":true,"path":"2018/12/02/Java/JVM/《深入理解java虚拟机》第2版/1. 走近Java/","link":"","permalink":"https://gxkord.github.io/2018/12/02/Java/JVM/《深入理解java虚拟机》第2版/1. 走近Java/","excerpt":"","text":"声明：本专题为周志明老师所著《深入理解Java虚拟机》的笔记 Java技术体系从传统意义上来讲，Sun公司所定义的Java技术体系包括： Java程序设计语言 各种硬件平台上的Java虚拟机 Class文件格式 Java API类库 来自商业机构和开源社区的第三方Java类库 我们可以把Java程序设计语言，Java虚拟机，Java API类库这三部分统称为JDK（JAVA Development Kit）,JDK是支持Java程序开发的最小环境。另外，我们把Java SE API子集和Java虚拟机这两部分统称为JRE（Java Runtime Environment），JRE是支持程序运行的标准环境。 Java技术体系所包含的内容（JDK1.8） 如果按照技术所服务的领域来划分，Java技术体系可分为4个平台： Java Card：支持一些小程序运行在小内存设备（如智能卡）上的平台。 Java ME（Micro Edition）：支持Java运行在移动终端上的平台。 Java SE（Standard Edition）：支持面向桌面级应用的Java平台。 Java EE（Enterprise Edition）：支持使用多层架构的企业应用的Java平台。 Java的发展历程1995年5月23日，Java语言诞生；1996年1月，第一个JDK-JDK1.0诞生；1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入Java技术；1996年9月，约8.3万个网页应用了Java技术来制作；1997年2月18日，JDK1.1发布；1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议纪录；1997年9月，JavaDeveloperConnection社区成员超过十万；1998年2月，JDK1.1被下载超过2,000,000次；1998年12月8日，Java 2企业平台J2EE发布 (J2EE1.2)；1999年6月，SUN公司发布Java三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME）；2000年5月8日，JDK1.3发布；2000年5月29日，JDK1.4发布；2001年6月5日，Nokia宣布到2003年将出售1亿部支持Java的手机；2001年9月24日，J2EE1.3发布；2002年2月26日，J2SE1.4发布，此后Java的计算能力有了大幅提升；同年微软发布.NET Framework；2004年9月30日，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0；2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字“2”： J2ME更名为Java ME， J2SE更名为Java SE， J2EE更名为Java EE；2006年12月，SUN公司发布JRE6.0；2009年12月，SUN公司发布Java EE 6；2010年11月，由于Oracle对Java社区的不友善，因此Apache扬言将退出JCP；2011年7月，Oracle发布Java SE 7；2014年3月，Oracle发表Java SE 8；Java SE 9 Oracle宣布 2016年9月发布；2017年9月21延期了好几次的Java9正式发布；2018年3月20号，Oracle发布了Java10；2018年9月25号，Oracle发布了Java11； JVM的发展Sun Classic / Exact VM以今天的视角来看，Sun Classic VM的技术可能很原始，这款虚拟机的使命也早已终结。但仅凭它“世界上第一款商用Java虚拟机”的头衔，就足够有让历史记住它的理由。 1996年1月23日，Sun公司发布JDK 1.0，Java语言首次拥有了商用的正式运行环境，这个JDK中所带的虚拟机就是Classic VM。这款虚拟机只能使用纯解释器方式来执行Java代码，如果要使用JIT编译器，就必须进行外挂。但是假如外挂了JIT编译器，JIT编译器就完全接管了虚拟机的执行系统，解释器便不再工作了。用户在这款虚拟机上执行java -version命令，将会看到类似下面这行输出： java version “1.2.2”Classic VM (build JDK-1.2.2-001, green threads, sunwjit) 其中的“sunwjit”就是Sun提供的外挂编译器，其他类似的外挂编译器还有Symantec JIT和shuJIT等。由于解释器和编译器不能配合工作，这就意味着如果要使用编译器执行，编译器就不得不对每一个方法、每一行代码都进行编译，而无论它们执行的频率是否具有编译的价值。基于程序响应时间的压力，这些编译器根本不敢应用编译耗时稍高的优化技术，因此这个阶段的虚拟机即使用了JIT编译器输出本地代码，执行效率也和传统的C/C++程序有很大差距，“Java语言很慢”的形象就是在这时候开始在用户心中树立起来的。 Sun的虚拟机团队努力去解决Classic VM所面临的各种问题，提升运行效率。在JDK 1.2时，曾在Solaris平台上发布过一款名为Exact VM的虚拟机，它的执行系统已经具备现代高性能虚拟机的雏形：如两级即时编译器、编译器与解释器混合工作模式等。Exact VM因它使用准确式内存管理（Exact Memory Management，也可以叫Non-Conservative/Accurate Memory Management）而得名，即虚拟机可以知道内存中某个位置的数据具体是什么类型。 虽然Exact VM的技术相对Classic VM来说先进了许多，但是在商业应用上只存在了很短暂的时间就被更为优秀的HotSpot VM所取代，甚至还没有来得及发布Windows和Linux平台下的商用版本。而Classic VM的生命周期则相对长了许多，它在JDK 1.2之前是Sun JDK中唯一的虚拟机，在JDK 1.2时，它与HotSpot VM并存，但默认使用的是Classic VM（用户可用java-hotspot参数切换至HotSpot VM），而在JDK 1.3时，HotSpot VM成为默认虚拟机，但Classic VM仍作为虚拟机的“备用选择”发布（使用java-classic参数切换），直到JDK 1.4的时候，Classic VM才完全退出商用虚拟机的历史舞台，与Exact VM一起进入了Sun Labs Research VM之中。 Sun HotSpot VM提起HotSpot VM，相信所有Java程序员都知道，它是Sun JDK和OpenJDK中所带的虚拟机，也是目前使用范围最广的Java虚拟机。但不一定所有人都知道的是，这个目前看起来“血统纯正”的虚拟机在最初并非由Sun公司开发，而是由一家名为“Longview Technologies”的小公司设计的；甚至这个虚拟机最初并非是为Java语言而开发的，它来源于Strongtalk VM，而这款虚拟机中相当多的技术又是来源于一款支持Self语言实现“达到C语言50%以上的执行效率”的目标而设计的虚拟机，Sun公司注意到了这款虚拟机在JIT编译上有许多优秀的理念和实际效果，在1997年收购了Longview Technologies公司，从而获得了HotSpot VM。 HotSpot VM既继承了Sun之前两款商用虚拟机的优点，也有许多自己新的技术优势，如它名称中的HotSpot指的就是它的热点代码探测技术，HotSpot VM的热点代码探测能力可以通过执行计数器找出最具有编译价值的代码，然后通知JIT编译器以方法为单位进行编译。如果一个方法被频繁调用，或方法中有效循环次数很多，将会分别触发标准编译和OSR（栈上替换）编译动作。通过编译器与解释器恰当地协同工作，可以在最优化的程序响应时间与最佳执行性能中取得平衡，而且无须等待本地代码输出才能执行程序，即时编译的时间压力也相对减小，这样有助于引入更多的代码优化技术，输出质量更高的本地代码。 在2006年的JavaOne大会上，Sun公司宣布最终会把Java开源，并在随后的一年，陆续将JDK的各个部分（其中当然也包括了HotSpot VM）在GPL协议下公开了源码，并在此基础上建立了OpenJDK。这样，HotSpot VM便成为了Sun JDK和OpenJDK两个实现极度接近的JDK项目的共同虚拟机。 在2008年和2009年，Oracle公司分别收购了BEA公司和Sun公司，这样Oracle就同时拥有了两款优秀的Java虚拟机：JRockit VM和HotSpot VM。Oracle公司宣布在不久的将来（大约应在发布JDK 8的时候）会完成这两款虚拟机的整合工作，使之优势互补。整合的方式大致上是在HotSpot的基础上，移植JRockit的优秀特性，譬如使用JRockit的垃圾回收器与MissionControl服务，使用HotSpot的JIT编译器与混合的运行时系统。 Sun Mobile-Embedded VM / Meta-Circular VMSun公司所研发的虚拟机可不仅有前面介绍的服务器、桌面领域的商用虚拟机，除此之外，Sun公司面对移动和嵌入式市场，也发布过虚拟机产品，另外还有一类虚拟机，在设计之初就没抱有商用的目的，仅仅是用于研究、验证某种技术和观点，又或者是作为一些规范的标准实现。这些虚拟机对于大部分不从事相关领域开发的Java程序员来说可能比较陌生。Sun公司发布的其他Java虚拟机有： (1) KVMKVM中的K是“Kilobyte”的意思，它强调简单、轻量、高度可移植，但是运行速度比较慢。在Android、iOS等智能手机操作系统出现前曾经在手机平台上得到非常广泛的应用。 (2) CDC/CLDC HotSpot ImplementationCDC/CLDC全称是Connected（Limited）Device Configuration，在JSR-139/JSR-218规范中进行定义，它希望在手机、电子书、PDA等设备上建立统一的Java编程接口，而CDC-HI VM和CLDC-HI VM则是它们的一组参考实现。CDC/CLDC是整个Java ME的重要支柱，但从目前Android和iOS二分天下的移动数字设备市场看来，在这个领域中，Sun的虚拟机所面临的局面远不如服务器和桌面领域乐观。 (3) Squawk VMSquawk VM由Sun公司开发，运行于Sun SPOT（Sun Small Programmable Object Technology，一种手持的WiFi设备），也曾经运用于Java Card。这是一个Java代码比重很高的嵌入式虚拟机实现，其中诸如类加载器、字节码验证器、垃圾收集器、解释器、编译器和线程调度都是Java语言本身完成的，仅仅靠C语言来编写设备I/O和必要的本地代码。 (4)JavaInJavaJavaInJava是Sun公司于1997年～1998年间研发的一个实验室性质的虚拟机，从名字就可以看出，它试图以Java语言来实现Java语言本身的运行环境，既所谓的“元循环”（Meta-Circular，是指使用语言自身来实现其运行环境）。它必须运行在另外一个宿主虚拟机之上，内部没有JIT编译器，代码只能以解释模式执行。在20世纪末主流Java虚拟机都未能很好解决性能问题的时代，开发这种项目，其执行速度可想而知。 (5) Maxine VMMaxine VM和上面的JavaInJava非常相似，它也是一个几乎全部以Java代码实现（只有用于启动JVM的加载器使用C语言编写）的元循环Java虚拟机。这个项目于2005年开始，到现在仍然在发展之中，比起JavaInJava，Maxine VM就显得“靠谱”很多，它有先进的JIT编译器和垃圾收集器（但没有解释器），可在宿主模式或独立模式下执行，其执行效率已经接近了HotSpot Client VM的水平。 BEA JRockit / IBM J9 VMJRockit VM曾经号称“世界上速度最快的Java虚拟机”它是BEA公司在2002年从Appeal Virtual Machines公司收购的虚拟机。BEA公司将其发展为一款专门为服务器硬件和服务器端应用场景高度优化的虚拟机，由于专注于服务器端应用，它可以不太关注程序启动速度，因此JRockit内部不包含解析器实现，全部代码都靠即时编译器编译后执行。除此之外，JRockit的垃圾收集器和MissionControl服务套件等部分的实现，在众多Java虚拟机中也一直处于领先水平。 IBM J9 VM并不是IBM公司唯一的Java虚拟机，不过是目前其主力发展的Java虚拟机。IBM J9 VM原本是内部开发代号，正式名称是“IBM Technology for Java Virtual Machine”，简称IT4J，只是这个名字太拗口了一点，普及程度不如J9。J9 VM最初是由IBM Ottawa实验室一个名为SmallTalk的虚拟机扩展而来的，当时这个虚拟机有一个bug是由8k值定义错误引起的，工程师花了很长时间终于发现并解决了这个错误，此后这个版本的虚拟机就称为K8了，后来扩展出支持Java的虚拟机就被称为J9了。与BEA JRockit专注于服务器端应用不同，IBM J9的市场定位与Sun HotSpot比较接近，它是一款设计上从服务器端到桌面应用再到嵌入式都全面考虑的多用途虚拟机，J9的开发目的是作为IBM公司各种Java产品的执行平台，它的主要市场是和IBM产品（如IBM WebSphere等）搭配以及在IBM AIX和z/OS这些平台上部署Java应用。 Azul VM / BEA Liquid VM我们平时所提及的“高性能Java虚拟机”一般是指HotSpot、JRockit、J9这类在通用平台上运行的商用虚拟机，但其实Azul VM和BEA Liquid VM这类特定硬件平台专有的虚拟机才是“高性能”的武器。 Azul VM是Azul Systems 公司在HotSpot基础上进行大量改进，运行于Azul Systems公司的专有硬件Vega系统上的Java虚拟机，每个Azul VM实例都可以管理至少数十个CPU和数百GB内存的硬件资源，并提供在巨大内存范围内实现可控的GC时间的垃圾收集器、为专有硬件优化的线程调度等优秀特性。在2010年，Azul Systems公司开始从硬件转向软件，发布了自己的Zing JVM，可以在通用x86平台上提供接近于Vega系统的特性。 Liquid VM即是现在的JRockit VE（Virtual Edition），它是BEA公司开发的，可以直接运行在自家Hypervisor系统上的JRockit VM的虚拟化版本，Liquid VM不需要操作系统的支持，或者说它自己本身实现了一个专用操作系统的必要功能，如文件系统、网络支持等。由虚拟机越过通用操作系统直接控制硬件可以获得很多好处，如在线程调度时，不需要再进行内核态/用户态的切换等，这样可以最大限度地发挥硬件的能力，提升Java程序的执行性能。 Apache Harmony / Google Android Dalvik VMHarmony VM和Dalvik VM只能称做“虚拟机”，而不能称做“Java虚拟机”，但是这两款虚拟机（以及所代表的技术体系）对最近几年的Java世界产生了非常大的影响和挑战，甚至有些悲观的评论家认为成熟的Java生态系统有崩溃的可能。 Apache Harmony是一个Apache软件基金会旗下以Apache License协议开源的实际兼容于JDK 1.5和JDK 1.6的Java程序运行平台，这个介绍相当拗口。它包含自己的虚拟机和Java库，用户可以在上面运行Eclipse、Tomcat、Maven等常见的Java程序，但是它没有通过TCK认证，所以我们不得不用那么一长串拗口的语言来介绍它，而不能用一句“Apache的JDK”来说明。如果一个公司要宣布自己的运行平台“兼容于Java语言”，那就必须要通过TCK（Technology Compatibility Kit）的兼容性测试。Apache基金会曾要求Sun公司提供TCK的使用授权，但是一直遭到拒绝，直到Oracle公司收购了Sun公司之后，双方关系越闹越僵，最终导致Apache愤然退出JCP（Java Community Process）组织，这是目前为止Java社区最严重的一次“分裂”。 在Sun将JDK开源形成OpenJDK之后，Apache Harmony开源的优势被极大地削弱，甚至连Harmony项目的最大参与者IBM公司也宣布辞去Harmony项目管理主席的职位，并参与OpenJDK项目的开发。虽然Harmony没有经过真正大规模的商业运用，但是它的许多代码（基本上是Java库部分的代码）被吸纳进IBM的JDK 7实现及Google Android SDK之中，尤其是对Android的发展起到了很大的推动作用。 说到Android，这个时下最热门的移动数码设备平台在最近几年间的发展过程中所取得的成果已经远远超越了Java ME在过去十多年所获得的成果，Android让Java语言真正走进了移动数码设备领域，只是走的并非Sun公司原本想象的那一条路。 Dalvik VM是Android平台的核心组成部分之一，它的名字来源于冰岛一个名为Dalvik的小渔村。Dalvik VM并不是一个Java虚拟机，它没有遵循Java虚拟机规范，不能直接执行Java的Class文件，使用的是寄存器架构而不是JVM中常见的栈架构。但是它与Java又有着千丝万缕的联系，它执行的dex（Dalvik Executable）文件可以通过Class文件转化而来，使用Java语法编写应用程序，可以直接使用大部分的Java API等。目前Dalvik VM随着Android一起处于迅猛发展阶段，在Android 2.2中已提供即时编译器实现，在执行性能上有了很大的提高。 Microsoft JVM及其他在十几年的Java虚拟机发展过程中，除去上面介绍的那些被大规模商业应用过的Java虚拟机外，还有许多虚拟机是不为人知的或者曾经“绚丽”过但最终湮灭的。我们以其中微软公司的JVM为例来介绍一下。 也许Java程序员听起来可能会觉得惊讶，微软公司曾经是Java技术的铁杆支持者（也必须承认，与Sun公司争夺Java的控制权，令Java从跨平台技术变为绑定在Windows上的技术是微软公司的主要目的）。在Java语言诞生的初期（1996年～1998年，以JDK 1.2发布为分界），它的主要应用之一是在浏览器中运行Java Applets程序，微软公司为了在IE3中支持Java Applets应用而开发了自己的Java虚拟机，虽然这款虚拟机只有Windows平台的版本，却是当时Windows下性能最好的Java虚拟机，它在1997年和1998年连续两年获得了《PC Magazine》杂志的“编辑选择奖”。但好景不长，在1997年10月，Sun公司正式以侵犯商标、不正当竞争等罪名控告微软公司，在随后对微软公司的垄断调查之中，这款虚拟机也曾作为证据之一被呈送法庭。这场官司的结果是微软公司赔偿2000万美金给Sun公司（最终微软公司因垄断赔偿给Sun公司的总金额高达10亿美元），承诺终止其Java虚拟机的发展，并逐步在产品中移除Java虚拟机相关功能。具有讽刺意味的是，到最后在Windows XP SP3中Java虚拟机被完全抹去的时候，Sun公司却又到处登报希望微软公司不要这样做。Windows XP高级产品经理Jim Cullinan称：“我们花费了3年的时间和Sun打官司，当时他们试图阻止我们在Windows中支持Java，现在我们这样做了，可他们又在抱怨，这太具有讽刺意味了。” 我们试想一下，如果当年Sun公司没有起诉微软公司，微软公司继续保持着对Java技术的热情，那Java的世界会变得怎么样呢？.NET技术是否会发展起来？但历史是没有假设的。 Java技术展望可以看到，Java作为最受欢迎的后台语言，依然在不断地汲取其他语言的优点。本书作者就模块化，混合语言，多核并行，进一步丰富语法，64位虚拟机方面对当时Java的未来做出了展望。 事实证明，文章提到的这几个未来，正在一步一步的走进现实。 比如，模块化已经在Java9中实现，Java8中lambda表达式的出现和Java9对lambda表达式的进一步优化，证明Java正在慢慢向函数式编程方向发展，多核编程正是Java语言未来的方向。更丰富的语法，64位的虚拟机也早已经成为了现实。 在网上我们经常看到“世界上最好的语言”云云。编程语言的多样性，竟带来了程序员之间的鄙视链。 但其实，这个世界上根本没有万能的编程语言，所有编程语言都存在缺点。编程语言只是编写代码的工具，程序员才是代码的灵魂。不管选定了哪个方向，一步一步的往上走，修炼到深处都是大牛。能够让你跟别人产生差距的的永远不可能是语言，而是你本身，与君共勉。","categories":[{"name":"Java","slug":"Java","permalink":"https://gxkord.github.io/categories/Java/"}],"tags":[{"name":"《深入理解Java虚拟机》","slug":"《深入理解Java虚拟机》","permalink":"https://gxkord.github.io/tags/《深入理解Java虚拟机》/"},{"name":"JVM","slug":"JVM","permalink":"https://gxkord.github.io/tags/JVM/"},{"name":"第一部分 走近Java","slug":"第一部分-走近Java","permalink":"https://gxkord.github.io/tags/第一部分-走近Java/"}]},{"title":"2. 照相机","slug":"JavaScript/Three.js/2. 照相机","date":"2018-12-02T07:20:12.000Z","updated":"2019-04-19T09:54:05.644Z","comments":true,"path":"2018/12/02/JavaScript/Three.js/2. 照相机/","link":"","permalink":"https://gxkord.github.io/2018/12/02/JavaScript/Three.js/2. 照相机/","excerpt":"","text":"什么是照相机？照相机（camera）一种将三维场景投影到二维显示器的工具。 分类(1) 正交投影(orthographic projection) – 平行投影，投影线垂直于投影面 – 用途：制图，建模(2)透视投影(perspective projection) – 中心投影，近大远小 – 用途：用于模仿人眼观察 正交投影相机 正交相机 1234THREE.OrthographicCamera(left,right,top,bottom,near,far)// 这六个参数分别表示照相机拍到的空间的六个面的位置，这六个面围成的长方体，称为视景体(Frustum)// 若要保持相机横纵比，(right-left)与(top-bottom)的比例需要与canvas的宽高比一致// near和far应为正值，且far&gt;near 透视投影相机 透视相机 - 主视图 透视相机 - 侧视图 透视相机 - 俯视图 12345THREE.PerspectiveCamera(fov,aspect,near,far)// fov：可视角度// aspect：实际窗口的纵横比// near：近处的裁面的距离// far：远处的裁面的距离 注意事项照相机默认的观察方向是指向z轴负方向（就是朝向屏幕），所以当变化坐标以后，就要将照相机指向原点，才能观察到物体。 1camera.lookAt(new THREE.Vector3(0,0,0));","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gxkord.github.io/categories/JavaScript/"}],"tags":[{"name":"3D","slug":"3D","permalink":"https://gxkord.github.io/tags/3D/"},{"name":"WebGL","slug":"WebGL","permalink":"https://gxkord.github.io/tags/WebGL/"},{"name":"Three.js入门","slug":"Three-js入门","permalink":"https://gxkord.github.io/tags/Three-js入门/"}]},{"title":"1. 概述","slug":"JavaScript/Three.js/1. 概述","date":"2018-12-02T06:57:13.000Z","updated":"2019-04-19T09:53:30.769Z","comments":true,"path":"2018/12/02/JavaScript/Three.js/1. 概述/","link":"","permalink":"https://gxkord.github.io/2018/12/02/JavaScript/Three.js/1. 概述/","excerpt":"","text":"什么是WebGLWebGL（Web Graphics Library）是基于OpenGL ES2.0的Web标准。可以为HTNL5的Canvas元素提供硬件3D加速渲染。 什么是three.js一种3D JavaScript库。 基本要素(1) 渲染器(Render)(2) 场景(Scene)(3) 照相机(Camera) 渲染器绑定方法和已有的Canvas元素绑定123var renderer = new THREE.WebGLRenderer(&#123; canvas: document.getElementById('mainCanvas');&#125;); Three.js自动生成Canvas元素123var renderer = new THREE.WebGLRenderer();renderer.setSize(400,300); // 设置Canvas的宽高document.getElementsByTagName('body')[0].appendChild(render.domElement); // 将Canvas添加到&lt;body&gt;中 相关方法12// 设置背景色renderer.setClearColor(0x000000); 场景12// 初始化场景var scene = new THREE.Scene(); 照相机 坐标 Three.js使用的是右手坐标系 12camera.position.set(0,0,5);scene.add(camera); 物体 几何形状（Geometry） 材质(Material) 渲染1renderer.render(scene,camera);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gxkord.github.io/categories/JavaScript/"}],"tags":[{"name":"3D","slug":"3D","permalink":"https://gxkord.github.io/tags/3D/"},{"name":"WebGL","slug":"WebGL","permalink":"https://gxkord.github.io/tags/WebGL/"},{"name":"Three.js入门","slug":"Three-js入门","permalink":"https://gxkord.github.io/tags/Three-js入门/"}]},{"title":"0. 前言","slug":"JavaScript/Three.js/0. 前言","date":"2018-12-02T03:14:02.000Z","updated":"2019-04-19T09:50:34.864Z","comments":true,"path":"2018/12/02/JavaScript/Three.js/0. 前言/","link":"","permalink":"https://gxkord.github.io/2018/12/02/JavaScript/Three.js/0. 前言/","excerpt":"","text":"引入 曾经，3D（three-dimensional）对于我来说，是遥不可及的东西。它只是我玩的某款游戏，或者看过的某部动画。 直到一次偶然的机会，我看到了腾讯的xplan计划的主页。（手机打开该网页有奇效） 在了解了WebGL后，我完全相信，它必将统治HTML的“数据展示”。 简介 Three.js是基于WebGL的，它是为了简化WebGl的开发而存在的js库。 Three.js也是为没有学过图形知识的开发者准备的。 这一点体现在： (1) 场景、物体、照相机等都可以通过一条语句直接得到； (2) 着色器对于初学者来说较难理解，Three.js“聪明地”取消了WebGL“着色器必须定义”的要求（如果开发者没有定义，就会使用默认渲染方法）。 注意 Three.js只内置了一些简单的模型，如果想使用更好地使用Three.js开发一个具有复杂模型网站，需要具备3d建模的能力（如C4D等）。 在引入3D模型的页面，一般需要 ‘禁用鼠标选中DOM元素’ 和 ‘禁用鼠标右键菜单’。 123456document.onselectstart = function() &#123; return false;&#125;;document.oncontextmenu = function() &#123; return false;&#125;; 3D模型的加载速度可能较慢，可以考虑使用异步的进度条插件。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://gxkord.github.io/categories/JavaScript/"}],"tags":[{"name":"3D","slug":"3D","permalink":"https://gxkord.github.io/tags/3D/"},{"name":"WebGL","slug":"WebGL","permalink":"https://gxkord.github.io/tags/WebGL/"},{"name":"Three.js入门","slug":"Three-js入门","permalink":"https://gxkord.github.io/tags/Three-js入门/"}]},{"title":"2. Add Two Numbers(Medium)","slug":"算法/LeetCode/2. Add Two Numbers(Medium)","date":"2018-12-01T14:00:03.000Z","updated":"2019-10-16T07:38:20.150Z","comments":true,"path":"2018/12/01/算法/LeetCode/2. Add Two Numbers(Medium)/","link":"","permalink":"https://gxkord.github.io/2018/12/01/算法/LeetCode/2. Add Two Numbers(Medium)/","excerpt":"","text":"题目描述原题 Description: You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 原题翻译 描述： 给定两个非空链表，表示两个非负整数。数字以相反的顺序存储，每个节点包含一个数字。将两个数字相加并将其作为链表返回。 可以认为这两个数字不包含任何前导0，除了数字0本身。 例如： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8解释：342 + 465 = 807. 解法一（mine）主要思想将两个数字表示出来，相加，再转化成结果链表（考虑到两数和可能超过了int的限制，选择BigInteger）。想法很简单，然而…Memory Limit Exceeded（内存超过限制） 未通过 源码1234567891011121314151617181920212223242526272829303132public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode ln1 = l1, ln2 = l2; //不破坏原链表 BigInteger a, b, temp1, temp2, b10; b10 = new BigInteger(\"10\"); temp1 = temp2 = new BigInteger(\"1\"); a = b = new BigInteger(\"0\"); while(ln1 != null) &#123; a = a.add(new BigInteger(ln1.val + \"\").multiply(temp1)); ln1 = ln1.next; temp1 = temp1.multiply(b10); &#125; while(ln2 != null) &#123; b = b.add(new BigInteger(ln2.val + \"\").multiply(temp2)); ln2 = ln2.next; temp2 = temp2.multiply(b10); &#125; BigInteger result = a.add(b); ListNode res; ListNode t = new ListNode(result.mod(b10).intValue()); result = result.divide(b10); res = t; while(result != new BigInteger(\"0\")) &#123; t.next = new ListNode(result.mod(b10).intValue()); t = t.next; result = result.divide(b10); &#125; return res; &#125;&#125; 解法二主要思想同时遍历两链表，将对应位上对两数相加（超过10的部分除以10再存起来，下一位继续用） 运行速度：超过了79.73%的解答。 内存使用：超过了90.28%的解答。 源码1234567891011121314151617public class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode ln1 = l1, ln2 = l2, head = null, node = null; int carry = 0, remainder = 0, sum = 0; head = node = new ListNode(-1); // 遍历l1和l2 while(ln1 != null || ln2 != null || carry != 0) &#123; sum = (ln1 != null ? ln1.val : 0) + (ln2 != null ? ln2.val : 0) + carry; carry = sum / 10; remainder = sum % 10; node = node.next = new ListNode(remainder); ln1 = (ln1 != null ? ln1.next : null); ln2 = (ln2 != null ? ln2.next : null); &#125; return head.next; &#125;&#125; 解法三 第一名答案 主要思想与解法二的思想类似。 运行速度：超过了100%的解答。 内存使用：超过了86.83%的解答。 源码12345678910111213141516171819202122class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode dummyHead = new ListNode(0), p1 = l1, p2 = l2, p = dummyHead; int carry = 0; while (p1 != null || p2 != null || carry != 0) &#123; int digit = 0 + carry; if (p1 != null) &#123; digit += p1.val; p1 = p1.next; &#125; if (p2 != null) &#123; digit += p2.val; p2 = p2.next; &#125; carry = digit / 10; p.next = new ListNode(digit % 10); p = p.next; &#125; return dummyHead.next; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Medium","slug":"LeetCode-Medium","permalink":"https://gxkord.github.io/tags/LeetCode-Medium/"}]},{"title":"1. Two Sum(Easy)","slug":"算法/LeetCode/1. Two Sum(Easy)","date":"2018-12-01T12:00:03.000Z","updated":"2019-10-16T07:37:10.503Z","comments":true,"path":"2018/12/01/算法/LeetCode/1. Two Sum(Easy)/","link":"","permalink":"https://gxkord.github.io/2018/12/01/算法/LeetCode/1. Two Sum(Easy)/","excerpt":"","text":"题目描述原题 Description: Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 原题翻译 描述： 给定一个整数数组，返回两个数字的索引，使它们相加到特定目标。假设每个输入仅有一个解决方案，且不能两次使用相同的元素。 例如： 给定 nums = [2, 7, 11, 15]， target = 9。 由于 nums[0] + nums[1] = 2 + 7 = 9，返回 [0, 1]。 解法一（mine）主要思想Exm？怎么会这么简单？我真的不是在做《C语言程序设计》的期中考试题？ 但细细想来，也确实配得上Easy的难度，两层for循环，即可轻松解决。 运行速度：超过了15.90%的解答。 内存使用：超过了98.95%的解答。 源码1234567891011121314public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i + 1; j &lt; nums.length; j++) &#123; if (nums[i] + nums[j] == target) &#123; result[0] = i; result[1] = j; &#125; &#125; &#125; return result; &#125;&#125; 解法二 大佬的答案…渐渐自闭… 主要思想 创建一个 HashMap&lt;Integer, Integer&gt; 类型的map，key 存放数值，value 存放下标。 循环遍历数组nums，并把key-value放入map，判断在 map 中是否存在 target-nums[i]： （1）若存在，直接将两个下标存入 result 数组，并返回； （2）若不存在，将 nums[i] 的值和下标放入 map，进入下一次循环。 运行速度：超过了98.87%的解答。 内存使用：超过了65.49%的解答。 源码123456789101112131415public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; nums.length; i++) &#123; if(map.containsKey(target-nums[i])) &#123; result[0] = map.get(target-nums[i]); result[1] = i; return result; &#125; map.put(nums[i], i); &#125; return result; &#125;&#125; Warning：这个解法虽然看起来完美，但它仅仅打败了71.76%的回答… 解法三 巨佬的答案，打败了99%的回答…深度自闭… 主要思想 复制一份原数组，对新数组排序，再使用快速查找算法得到答案。 如果拿到了答案，遍历原序数组，得到索引值，并加入结果数组。 源码123456789101112131415161718192021222324252627282930public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int low = 0; int high = nums.length-1; int[] result = new int[2]; int[] aux = Arrays.copyOf(nums, nums.length); Arrays.sort(nums); while(low &lt; high) &#123; int sum = nums[low] + nums[high]; if(sum == target) &#123; result[0] = nums[low]; result[1] = nums[high]; break; &#125;else if(sum &gt; target) &#123; high--; &#125; else &#123; low++; &#125; &#125; int index = 0; int[] finalRes = new int[2]; for(int i=0; i&lt;aux.length; i++) &#123; if(aux[i] == result[0] || aux[i] == result[1]) &#123; finalRes[index] = i; index++; &#125; &#125; return finalRes; &#125;&#125; 解法四 让我们来看一下剩下的1%写了些什么？ 主要思想 抱歉…在写下这篇笔记的时候，我依然没看懂…（如果有大神看到，请救救孩子…） 运行速度：超过了100%的解答。 内存使用：超过了98.43%的解答。 源码1234567891011121314151617181920public class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int max = 2048; int[] indexes = new int[max]; int bitMode = --max; int first = nums[0]; for (int i = 1; i &lt; nums.length; i++) &#123; int difference = target - nums[i]; if (difference == first) &#123; return new int[]&#123;0, i&#125;; &#125; int index = indexes[difference &amp; bitMode]; if(index != 0) &#123; return new int[]&#123;index, i&#125;; &#125; indexes[nums[i]&amp;bitMode] = i; &#125; return new int[0]; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://gxkord.github.io/categories/算法/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://gxkord.github.io/tags/LeetCode/"},{"name":"LeetCode - Easy","slug":"LeetCode-Easy","permalink":"https://gxkord.github.io/tags/LeetCode-Easy/"}]}]}